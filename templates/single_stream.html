<!DOCTYPE html>
<!-- IMPORTANT: Keep single stream page UI-free. Do not add headers or extra UI
without explicit instruction; content should be edge-to-edge for immersion. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ stream_id|capitalize }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='stream.css') }}">
  </head>
<body>
<!-- NOTE: No header/toolbars here; keep media full-screen friendly. -->
<div class="stream-wrapper" id="stream-wrapper">
  <div class="media-backdrop" id="media-backdrop" aria-hidden="true"></div>
  <div id="container" class="media-container"></div>
</div>
<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
// Apply saved theme (silently, no UI)
(function(){
  const root = document.documentElement;
  const saved = localStorage.getItem('theme');
  root.setAttribute('data-theme', saved === 'light' ? 'light' : 'dark');
})();

const streamId = "{{ stream_id }}";
const socket = io();
const MAX_BACKDROP_BLUR = 40;
const backdropEl = document.getElementById('media-backdrop');
let rotationTimer = null;
let cancelRotation = null;
let hlsLoaderPromise = null;
let activeHls = null;
let backdropState = {
  enabled: false,
  amount: 50,
};
let backdropSource = '';

let currentConfig = null;
let activeVideoElement = null;
let activeVideoHandlers = null;
let playbackTimer = null;
let currentMediaController = null;
let serverPlaybackState = null;
let activeMediaPath = null;
let usingSynchronizedPlayback = false;
const VIDEO_PLAYBACK_MODES = new Set(['duration', 'until_end', 'loop']);

socket.on('connect', () => {
  socket.emit('stream_subscribe', { stream_id: streamId });
});

socket.on('disconnect', () => {
  serverPlaybackState = null;
});

const VIDEO_EXTENSIONS = new Set(['.mp4', '.mkv', '.webm', '.mov', '.avi', '.m4v', '.mpg', '.mpeg']);

function clampBlurAmount(raw) {
  const num = Number(raw);
  if (!Number.isFinite(num)) {
    return 50;
  }
  return Math.min(100, Math.max(0, Math.round(num)));
}

function applyBackdropState() {
  if (!backdropEl) {
    return;
  }
  const amount = clampBlurAmount(backdropState.amount);
  const blurPx = Math.round((amount / 100) * MAX_BACKDROP_BLUR);
  backdropEl.style.setProperty('--backdrop-blur', `${blurPx}px`);
  const active = Boolean(backdropState.enabled && backdropSource);
  if (active) {
    backdropEl.style.backgroundImage = `url(${JSON.stringify(backdropSource)})`;
    backdropEl.classList.add('is-active');
  } else {
    backdropEl.classList.remove('is-active');
    if (!backdropSource) {
      backdropEl.style.backgroundImage = '';
    }
  }
}

function setBackdropSettings(enabled, amount) {
  backdropState = {
    enabled: Boolean(enabled),
    amount: clampBlurAmount(amount),
  };
  applyBackdropState();
}

function updateBackdropSource(url) {
  backdropSource = url || '';
  applyBackdropState();
}

function createNoopMediaController() {
  return {
    skipNext: () => {},
    skipPrev: () => {},
    play: () => {},
    pause: () => {},
    toggle: () => {},
    setVolume: () => {},
  };
}

function setMediaController(controller) {
  currentMediaController = controller || createNoopMediaController();
}

function normalizePlaybackMode(mode) {
  const value = typeof mode === 'string' ? mode.trim().toLowerCase() : '';
  return VIDEO_PLAYBACK_MODES.has(value) ? value : 'duration';
}

function clampVolume(value) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    return 1.0;
  }
  return Math.min(1, Math.max(0, numeric));
}

function detectMediaKind(path, explicitKind) {
  if (explicitKind && typeof explicitKind === 'string') {
    const normalized = explicitKind.trim().toLowerCase();
    if (normalized === 'image' || normalized === 'video') {
      return normalized;
    }
  }
  if (!path) {
    return 'image';
  }
  const lastDot = String(path).lastIndexOf('.');
  if (lastDot === -1) {
    return 'image';
  }
  const ext = String(path).slice(lastDot).toLowerCase();
  return VIDEO_EXTENSIONS.has(ext) ? 'video' : 'image';
}

function clearPlaybackTimer() {
  if (playbackTimer) {
    clearTimeout(playbackTimer);
    playbackTimer = null;
  }
}

function teardownActiveVideo() {
  if (!activeVideoElement) {
    return;
  }
  try {
    activeVideoElement.pause();
  } catch (err) {
    /* no-op */
  }
  if (activeVideoHandlers) {
    if (activeVideoHandlers.ended) {
      activeVideoElement.removeEventListener('ended', activeVideoHandlers.ended);
    }
    if (activeVideoHandlers.error) {
      activeVideoElement.removeEventListener('error', activeVideoHandlers.error);
    }
  }
  activeVideoElement.src = '';
  if (typeof activeVideoElement.load === 'function') {
    try {
      activeVideoElement.load();
    } catch (err) {
      /* ignore */
    }
  }
  activeVideoElement = null;
  activeVideoHandlers = null;
}

function setActiveVideoElement(video, handlers) {
  teardownActiveVideo();
  activeVideoElement = video;
  activeVideoHandlers = handlers || null;
}

function updateVideoVolume(volume) {
  const clamped = clampVolume(volume);
  if (activeVideoElement) {
    activeVideoElement.volume = clamped;
    activeVideoElement.muted = clamped <= 0;
  }
  if (currentConfig) {
    currentConfig.video_volume = clamped;
  }
  return clamped;
}

function computeServerPlaybackPosition(state) {
  if (!state || typeof state !== 'object') {
    return 0;
  }
  const base = Number(state.position);
  const startedAt = Number(state.started_at);
  const duration = Number(state.duration);
  let position = Number.isFinite(base) ? base : 0;
  if (!state.is_paused && Number.isFinite(startedAt)) {
    const nowSeconds = Date.now() / 1000;
    position += Math.max(0, nowSeconds - startedAt);
  }
  if (Number.isFinite(duration) && duration > 0) {
    position = Math.min(position, duration);
  }
  return Math.max(0, position);
}

function computeDesiredVolume(state) {
  if (state && state.video_volume !== undefined) {
    return clampVolume(state.video_volume);
  }
  if (currentConfig && currentConfig.video_volume !== undefined) {
    return clampVolume(currentConfig.video_volume);
  }
  return 1.0;
}

function syncVideoCurrentTime(video, state) {
  if (!video || !state) {
    return;
  }
  const target = computeServerPlaybackPosition(state);
  const seek = () => {
    if (!Number.isFinite(target)) {
      return;
    }
    if (Math.abs(video.currentTime - target) > 0.35) {
      try {
        video.currentTime = target;
      } catch (err) {
        console.debug('Failed to adjust video position', err);
      }
    }
  };
  if (video.readyState >= 1) {
    seek();
  } else {
    const handler = () => {
      video.removeEventListener('loadedmetadata', handler);
      seek();
    };
    video.addEventListener('loadedmetadata', handler, { once: true });
  }
}

function applyVideoPlaybackState(video, state) {
  if (!video) {
    return;
  }
  const desiredVolume = computeDesiredVolume(state);
  updateVideoVolume(desiredVolume);
  if (!state || state.is_paused) {
    video.pause();
    return;
  }
  const playPromise = video.play();
  if (playPromise && typeof playPromise.catch === 'function') {
    playPromise.catch(err => {
      console.warn('Muted autoplay fallback', err);
      video.muted = true;
      video.play().catch(() => {});
    });
  }
}

setMediaController(createNoopMediaController());

const VALID_QUALITIES = new Set(['auto', 'thumb', 'medium', 'full']);
const TEMPLATE_QUALITY = {{ default_quality|tojson }};
const queryQualityRaw = (new URLSearchParams(window.location.search).get('size') || '').toLowerCase();
const queryQuality = VALID_QUALITIES.has(queryQualityRaw) && queryQualityRaw !== '' ? queryQualityRaw : '';
let imageQuality = queryQuality || (VALID_QUALITIES.has(TEMPLATE_QUALITY) ? TEMPLATE_QUALITY : 'auto');
if (!VALID_QUALITIES.has(imageQuality)) {
  imageQuality = 'auto';
}
const qualityOverride = queryQuality;
// Request downsized images based on real display size so browsers avoid downloading full-resolution assets.
function computeSizedImageUrl(path, container) {
  const base = `/stream/image/${path}`;
  if (imageQuality !== 'auto') {
    const params = new URLSearchParams({ size: imageQuality });
    return `${base}?${params.toString()}`;
  }
  const width = Math.max(container.clientWidth || container.offsetWidth || window.innerWidth || 1, 1);
  const height = Math.max(container.clientHeight || container.offsetHeight || window.innerHeight || 1, 1);
  const dpr = window.devicePixelRatio || 1;
  const targetWidth = Math.max(Math.round(width * dpr), 1);
  const targetHeight = Math.max(Math.round(height * dpr), 1);
  const params = new URLSearchParams({
    width: targetWidth.toString(),
    height: targetHeight.toString(),
  });
  return `${base}?${params.toString()}`;
}

// Preload upcoming images off-screen so swaps are instant and flicker-free when the visible element is replaced.
function startPreload(url) {
  const preloadImg = document.createElement('img');
  preloadImg.style.position = 'absolute';
  preloadImg.style.left = '-10000px';
  preloadImg.style.top = '-10000px';
  preloadImg.style.width = '1px';
  preloadImg.style.height = '1px';
  preloadImg.style.pointerEvents = 'none';
  preloadImg.setAttribute('aria-hidden', 'true');
  preloadImg.decoding = 'async';
  preloadImg.loading = 'eager';
  preloadImg.alt = '';
  document.body.appendChild(preloadImg);

  let settled = false;
  const ready = new Promise((resolve, reject) => {
    const cleanup = () => {
      preloadImg.removeEventListener('load', handleLoad);
      preloadImg.removeEventListener('error', handleError);
    };
    function handleLoad() {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      resolve(preloadImg);
    }
    function handleError(err) {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      preloadImg.remove();
      reject(err || new Error('Failed to preload image'));
    }
    preloadImg.addEventListener('load', handleLoad, { once: true });
    preloadImg.addEventListener('error', handleError, { once: true });
  });

  preloadImg.src = url;
  return { element: preloadImg, ready };
}

// Reset styles before showing the preloaded element so layouts remain responsive.
function prepareImageForDisplay(img) {
  img.style.position = '';
  img.style.left = '';
  img.style.top = '';
  img.style.width = '';
  img.style.height = '';
  img.style.pointerEvents = '';
  img.style.maxWidth = '100%';
  img.style.maxHeight = '100%';
  img.style.objectFit = 'contain';
  img.removeAttribute('aria-hidden');
  img.loading = 'eager';
  img.decoding = 'async';
  img.alt = img.alt || '';
}

function stopRotationLoop() {
  if (cancelRotation) {
    cancelRotation();
    cancelRotation = null;
  }
  if (rotationTimer) {
    clearTimeout(rotationTimer);
    rotationTimer = null;
  }
  setMediaController(createNoopMediaController());
}

function teardownHlsInstance() {
  if (activeHls) {
    try {
      activeHls.destroy();
    } catch (err) {
      console.warn('Failed to destroy Hls instance', err);
    }
    activeHls = null;
  }
}

// Load hls.js lazily so we only download the library when the server actually provides an HLS stream.
function ensureHlsLibrary() {
  if (window.Hls) {
    return Promise.resolve(window.Hls);
  }
  if (!hlsLoaderPromise) {
    hlsLoaderPromise = new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
      script.async = true;
      script.onload = () => resolve(window.Hls);
      script.onerror = () => reject(new Error('Failed to load hls.js'));
      document.head.appendChild(script);
    });
  }
  return hlsLoaderPromise;
}

async function displaySingleImage(path, container) {
  setMediaController(createNoopMediaController());
  clearPlaybackTimer();
  teardownActiveVideo();
  if (!path) {
    container.textContent = 'No image selected';
    updateBackdropSource('');
    return;
  }
  container.textContent = 'Loading...';
  try {
    const sizedUrl = computeSizedImageUrl(path, container);
    const preload = startPreload(sizedUrl);
    const img = await preload.ready;
    prepareImageForDisplay(img);
    container.replaceChildren(img);
    updateBackdropSource(img.currentSrc || img.src || sizedUrl);
  } catch (err) {
    console.error('Failed to load image', err);
    container.textContent = 'Unable to load image';
    updateBackdropSource('');
  }
}

async function displaySingleMedia(config, container) {
  const path = config && config.selected_image ? config.selected_image : null;
  const kind = detectMediaKind(path, config && config.selected_media_kind);
  if (kind === 'video') {
    clearPlaybackTimer();
    teardownActiveVideo();
    if (!path) {
      container.textContent = 'No media selected';
      updateBackdropSource('');
      setMediaController(createNoopMediaController());
      return;
    }
    const playbackMode = normalizePlaybackMode(config && config.video_playback_mode);
    const controller = {
      skipNext: () => {},
      skipPrev: () => {},
      play: () => { if (activeVideoElement) { activeVideoElement.play().catch(() => {}); } },
      pause: () => { if (activeVideoElement) { activeVideoElement.pause(); } },
      toggle: () => {
        if (!activeVideoElement) {
          return;
        }
        if (activeVideoElement.paused) {
          activeVideoElement.play().catch(() => {});
        } else {
          activeVideoElement.pause();
        }
      },
      setVolume: value => updateVideoVolume(value),
    };
    setMediaController(controller);
    const video = document.createElement('video');
    video.className = 'stream-video';
    video.playsInline = true;
    video.autoplay = true;
    video.controls = false;
    video.preload = 'auto';
    const volume = clampVolume(config && config.video_volume);
    video.volume = volume;
    video.muted = volume <= 0;
    video.style.width = '100%';
    video.style.height = '100%';
    if (playbackMode === 'loop') {
      video.loop = true;
    }
    video.src = `/stream/video/${path}`;
    container.replaceChildren(video);
    updateBackdropSource('');
    const handlers = {
      error: () => console.error('Single video playback error'),
    };
    video.addEventListener('error', handlers.error);
    setActiveVideoElement(video, handlers);
    const playPromise = video.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(err => {
        console.warn('Muted autoplay fallback', err);
        video.muted = true;
        video.play().catch(() => {});
      });
    }
  } else {
    await displaySingleImage(path, container);
  }
}

async function renderServerImage(media, state, container) {
  if (!media || !media.path) {
    container.textContent = 'No media available';
    updateBackdropSource('');
    return;
  }
  activeMediaPath = media.path;
  cancelRotation = () => {};
  await displaySingleImage(media.path, container);
}

function renderServerVideo(media, state, container) {
  if (!media || !media.path) {
    container.textContent = 'No media available';
    updateBackdropSource('');
    teardownActiveVideo();
    activeMediaPath = null;
    return;
  }
  const path = media.path;
  if (activeVideoElement && activeMediaPath === path) {
    syncVideoCurrentTime(activeVideoElement, state);
    applyVideoPlaybackState(activeVideoElement, state);
    return;
  }

  cancelRotation = () => {};
  activeMediaPath = path;
  clearPlaybackTimer();
  teardownActiveVideo();

  const video = document.createElement('video');
  video.className = 'stream-video';
  video.playsInline = true;
  video.autoplay = true;
  video.controls = false;
  video.preload = 'auto';
  video.style.width = '100%';
  video.style.height = '100%';

  container.replaceChildren(video);
  updateBackdropSource('');

  const handlers = {
    error: () => {
      console.error('Synchronized video playback error for', path);
    },
  };
  video.addEventListener('error', handlers.error);

  setActiveVideoElement(video, handlers);
  setMediaController({
    skipNext: () => {},
    skipPrev: () => {},
    play: () => { if (video.paused) { video.play().catch(() => {}); } },
    pause: () => { if (!video.paused) { video.pause(); } },
    toggle: () => {
      if (video.paused) {
        video.play().catch(() => {});
      } else {
        video.pause();
      }
    },
    setVolume: value => updateVideoVolume(value),
  });

  video.src = `/stream/video/${path}`;
  syncVideoCurrentTime(video, state);
  applyVideoPlaybackState(video, state);
}

function startSynchronizedStream(config, container) {
  usingSynchronizedPlayback = true;
  cancelRotation = () => {};
  clearPlaybackTimer();
  teardownActiveVideo();
  activeMediaPath = null;
  container.textContent = 'Waiting for stream...';
  updateBackdropSource('');
  if (config && config.video_volume !== undefined) {
    currentConfig.video_volume = clampVolume(config.video_volume);
  }
  socket.emit('stream_subscribe', { stream_id: streamId });
  if (serverPlaybackState && serverPlaybackState.stream_id === streamId) {
    handleStreamUpdate(serverPlaybackState);
  }
}

function handleStreamUpdate(payload) {
  if (!payload || payload.stream_id !== streamId) {
    return;
  }
  serverPlaybackState = payload;
  if (!usingSynchronizedPlayback) {
    return;
  }
  const container = document.getElementById('container');
  if (!container) {
    return;
  }
  const media = payload.media;
  if (!media || !media.path) {
    activeMediaPath = null;
    teardownActiveVideo();
    const message = payload.error === 'no_media' ? 'No media available' : 'Stream idle';
    container.textContent = message;
    updateBackdropSource('');
    return;
  }
  const kind = detectMediaKind(media.path, media.kind);
  if (kind === 'video') {
    renderServerVideo(media, payload, container);
  } else {
    renderServerImage(media, payload, container).catch(err => {
      console.error('Failed to render synchronized image', err);
      container.textContent = 'Unable to load media';
      updateBackdropSource('');
    });
  }
}

function startAiRotation(paths, config, container) {
  setMediaController(createNoopMediaController());
  clearPlaybackTimer();
  teardownActiveVideo();
  if (!paths.length) {
    container.textContent = 'No AI image generated yet';
    updateBackdropSource('');
    return;
  }
  if (paths.length === 1) {
    displaySingleImage(paths[0], container);
    return;
  }

  const delayMs = Math.max((Number(config.duration) || 10) * 1000, 2000);
  let index = 0;
  let cancelled = false;
  let pendingPreload = null;

  cancelRotation = () => {
    cancelled = true;
    if (rotationTimer) {
      clearTimeout(rotationTimer);
      rotationTimer = null;
    }
    if (pendingPreload && pendingPreload.parentNode) {
      pendingPreload.remove();
    }
  };

  container.textContent = 'Loading...';

  async function cycle() {
    if (cancelled) {
      return;
    }
    const path = paths[index % paths.length];
    index += 1;
    try {
      const sizedUrl = computeSizedImageUrl(path, container);
      const preload = startPreload(sizedUrl);
      pendingPreload = preload.element;
      const img = await preload.ready;
      pendingPreload = null;
      if (cancelled) {
        img.remove();
        return;
      }
      prepareImageForDisplay(img);
      container.replaceChildren(img);
      updateBackdropSource(img.currentSrc || img.src || sizedUrl);
    } catch (err) {
      console.error('AI rotation failed', err);
      if (!cancelled) {
        container.textContent = 'Unable to load AI image';
        updateBackdropSource('');
      }
      cancelRotation();
      return;
    }

    if (!cancelled) {
      rotationTimer = setTimeout(cycle, delayMs);
    }
  }

  cycle();
}

async function render(config) {
  currentConfig = config;
  usingSynchronizedPlayback = false;
  if (!qualityOverride) {
    const fromConfig = (config && typeof config.image_quality === 'string') ? config.image_quality.trim().toLowerCase() : 'auto';
    imageQuality = VALID_QUALITIES.has(fromConfig) ? fromConfig : 'auto';
  }
  const container = document.getElementById('container');
  stopRotationLoop();
  clearPlaybackTimer();
  teardownActiveVideo();
  teardownHlsInstance();
  container.innerHTML = '';
  setBackdropSettings(config && config.background_blur_enabled, config && config.background_blur_amount);
  setMediaController(createNoopMediaController());
  const mediaMode = (config && typeof config.media_mode === 'string') ? config.media_mode.trim().toLowerCase() : ((config && typeof config.mode === 'string' && config.mode.toLowerCase() === 'livestream') ? 'livestream' : (config && typeof config.mode === 'string' && config.mode.toLowerCase() === 'ai') ? 'ai' : (config && config.selected_media_kind === 'video') ? 'video' : 'image');
  const modeValue = (config && typeof config.mode === 'string') ? config.mode.trim().toLowerCase() : 'random';
  if (mediaMode === 'livestream') {
    updateBackdropSource('');
    if (config.stream_url) {
      try {
        const response = await fetch(`/stream/live?stream_id=${encodeURIComponent(streamId)}`);
        if (!response.ok) {
          throw new Error(`Stream metadata request failed (${response.status})`);
        }
        const data = await response.json();
        if (data.embed_type === 'youtube') {
          const params = `?autoplay=1&mute=${config.yt_mute ? 1 : 0}&cc_load_policy=${config.yt_cc ? 1 : 0}`;
          const iframe = document.createElement('iframe');
          iframe.src = `https://www.youtube.com/embed/${data.embed_id}${params}`;
          iframe.allow = 'autoplay';
          container.appendChild(iframe);
        } else if (data.embed_type === 'twitch') {
          const iframe = document.createElement('iframe');
          iframe.src = `https://player.twitch.tv/?channel=${data.embed_id}&parent=${location.hostname}&autoplay=true`;
          iframe.allow = 'autoplay';
          container.appendChild(iframe);
        } else if (data.embed_type === 'hls') {
          const video = document.createElement('video');
          video.controls = true;
          video.autoplay = true;
          video.playsInline = true;
          video.preload = 'auto';
          video.style.width = '100%';
          video.style.height = '100%';
          container.appendChild(video);

          if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = data.hls_url;
          } else {
            try {
              const Hls = await ensureHlsLibrary();
              if (Hls && Hls.isSupported()) {
                activeHls = new Hls();
                activeHls.loadSource(data.hls_url);
                activeHls.attachMedia(video);
              } else {
                video.src = data.hls_url;
              }
            } catch (err) {
              console.error('Failed to initialise hls.js', err);
              video.src = data.hls_url;
            }
          }
        } else {
          const iframe = document.createElement('iframe');
          iframe.src = data.original_url;
          container.appendChild(iframe);
        }
      } catch (err) {
        console.error('Failed to load livestream metadata', err);
        container.textContent = 'Unable to load stream';
      }
    } else {
      container.textContent = 'Stream URL not configured';
    }
    return;
  }

  if (mediaMode === 'ai' || modeValue === 'ai') {
    const aiImages = (config.ai_state && Array.isArray(config.ai_state.images)) ? config.ai_state.images : [];
    const paths = aiImages
      .map(item => (item && item.path) ? item.path : item)
      .filter(Boolean);
    if (!paths.length && config.selected_image) {
      paths.push(config.selected_image);
    }
    startAiRotation(paths, config, container);
    return;
  }

  if (mediaMode === 'video') {
    if (modeValue === 'specific') {
      await displaySingleMedia(config, container);
      return;
    }
    if (modeValue === 'random') {
      startSynchronizedStream(config, container);
      return;
    }
    container.textContent = 'No video content configured';
    updateBackdropSource('');
    return;
  }

  if (modeValue === 'specific') {
    await displaySingleMedia(config, container);
    return;
  }

  if (modeValue === 'random') {
    startSynchronizedStream(config, container);
    return;
  }

  container.textContent = 'No content configured';
  updateBackdropSource('');
}

function handleVideoControl(payload) {
  if (!payload || payload.stream_id !== streamId) {
    return;
  }
  const action = typeof payload.action === 'string' ? payload.action.trim().toLowerCase() : '';
  if (!action) {
    return;
  }
  if (!currentMediaController) {
    setMediaController(createNoopMediaController());
  }
  switch (action) {
    case 'play':
      currentMediaController.play();
      break;
    case 'pause':
      currentMediaController.pause();
      break;
    case 'toggle':
      currentMediaController.toggle();
      break;
    case 'skip_next':
      currentMediaController.skipNext();
      break;
    case 'skip_prev':
      currentMediaController.skipPrev();
      break;
    case 'set_volume':
      if (payload.volume !== undefined) {
        currentMediaController.setVolume(payload.volume);
      }
      break;
    default:
      break;
  }
}

async function load() {
  try {
    const res = await fetch(`/get-settings/${encodeURIComponent(streamId)}`);
    if (!res.ok) {
      throw new Error(`Settings request failed (${res.status})`);
    }
    const conf = await res.json();
    await render(conf);
  } catch (err) {
    console.error('Failed to load stream settings', err);
    const container = document.getElementById('container');
    container.textContent = 'Unable to load stream configuration';
  }
}

socket.on('refresh', data => {
  if (data.stream_id === streamId) {
    render(data.config);
  }
});

socket.on('video_control', handleVideoControl);
socket.on('stream_update', handleStreamUpdate);

load();
</script>
</body>
</html>
