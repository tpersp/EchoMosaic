<!DOCTYPE html>
<!-- IMPORTANT: Keep single stream page UI-free. Do not add headers or extra UI
without explicit instruction; content should be edge-to-edge for immersion. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ stream_id|capitalize }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='stream.css') }}">
  </head>
<body>
<!-- NOTE: No header/toolbars here; keep media full-screen friendly. -->
<div class="stream-wrapper" id="stream-wrapper">
  <div class="media-backdrop" id="media-backdrop" aria-hidden="true"></div>
  <div id="container" class="media-container"></div>
</div>
<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
// Apply saved theme (silently, no UI)
(function(){
  const root = document.documentElement;
  const saved = localStorage.getItem('theme');
  root.setAttribute('data-theme', saved === 'light' ? 'light' : 'dark');
})();

const streamId = "{{ stream_id }}";
const socket = io();
const MAX_BACKDROP_BLUR = 40;
const backdropEl = document.getElementById('media-backdrop');
let rotationTimer = null;
let cancelRotation = null;
let hlsLoaderPromise = null;
let activeHls = null;
let backdropState = {
  enabled: false,
  amount: 50,
};
let backdropSource = '';

let currentConfig = null;
let activeVideoElement = null;
let activeVideoHandlers = null;
let playbackTimer = null;
let mediaHistory = [];
let mediaHistoryIndex = -1;
let currentMediaController = null;
const VIDEO_PLAYBACK_MODES = new Set(['duration', 'until_end', 'loop']);

const VIDEO_EXTENSIONS = new Set(['.mp4', '.mkv', '.webm', '.mov', '.avi', '.m4v', '.mpg', '.mpeg']);

function clampBlurAmount(raw) {
  const num = Number(raw);
  if (!Number.isFinite(num)) {
    return 50;
  }
  return Math.min(100, Math.max(0, Math.round(num)));
}

function applyBackdropState() {
  if (!backdropEl) {
    return;
  }
  const amount = clampBlurAmount(backdropState.amount);
  const blurPx = Math.round((amount / 100) * MAX_BACKDROP_BLUR);
  backdropEl.style.setProperty('--backdrop-blur', `${blurPx}px`);
  const active = Boolean(backdropState.enabled && backdropSource);
  if (active) {
    backdropEl.style.backgroundImage = `url(${JSON.stringify(backdropSource)})`;
    backdropEl.classList.add('is-active');
  } else {
    backdropEl.classList.remove('is-active');
    if (!backdropSource) {
      backdropEl.style.backgroundImage = '';
    }
  }
}

function setBackdropSettings(enabled, amount) {
  backdropState = {
    enabled: Boolean(enabled),
    amount: clampBlurAmount(amount),
  };
  applyBackdropState();
}

function updateBackdropSource(url) {
  backdropSource = url || '';
  applyBackdropState();
}

function createNoopMediaController() {
  return {
    skipNext: () => {},
    skipPrev: () => {},
    play: () => {},
    pause: () => {},
    toggle: () => {},
    setVolume: () => {},
  };
}

function setMediaController(controller) {
  currentMediaController = controller || createNoopMediaController();
}

function normalizePlaybackMode(mode) {
  const value = typeof mode === 'string' ? mode.trim().toLowerCase() : '';
  return VIDEO_PLAYBACK_MODES.has(value) ? value : 'duration';
}

function clampVolume(value) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    return 1.0;
  }
  return Math.min(1, Math.max(0, numeric));
}

function detectMediaKind(path, explicitKind) {
  if (explicitKind && typeof explicitKind === 'string') {
    const normalized = explicitKind.trim().toLowerCase();
    if (normalized === 'image' || normalized === 'video') {
      return normalized;
    }
  }
  if (!path) {
    return 'image';
  }
  const lastDot = String(path).lastIndexOf('.');
  if (lastDot === -1) {
    return 'image';
  }
  const ext = String(path).slice(lastDot).toLowerCase();
  return VIDEO_EXTENSIONS.has(ext) ? 'video' : 'image';
}

function clearPlaybackTimer() {
  if (playbackTimer) {
    clearTimeout(playbackTimer);
    playbackTimer = null;
  }
}

function teardownActiveVideo() {
  if (!activeVideoElement) {
    return;
  }
  try {
    activeVideoElement.pause();
  } catch (err) {
    /* no-op */
  }
  if (activeVideoHandlers) {
    if (activeVideoHandlers.ended) {
      activeVideoElement.removeEventListener('ended', activeVideoHandlers.ended);
    }
    if (activeVideoHandlers.error) {
      activeVideoElement.removeEventListener('error', activeVideoHandlers.error);
    }
  }
  activeVideoElement.src = '';
  if (typeof activeVideoElement.load === 'function') {
    try {
      activeVideoElement.load();
    } catch (err) {
      /* ignore */
    }
  }
  activeVideoElement = null;
  activeVideoHandlers = null;
}

function setActiveVideoElement(video, handlers) {
  teardownActiveVideo();
  activeVideoElement = video;
  activeVideoHandlers = handlers || null;
}

function updateVideoVolume(volume) {
  const clamped = clampVolume(volume);
  if (activeVideoElement) {
    activeVideoElement.volume = clamped;
    activeVideoElement.muted = clamped <= 0;
  }
  if (currentConfig) {
    currentConfig.video_volume = clamped;
  }
  return clamped;
}

setMediaController(createNoopMediaController());

const VALID_QUALITIES = new Set(['auto', 'thumb', 'medium', 'full']);
const TEMPLATE_QUALITY = {{ default_quality|tojson }};
const queryQualityRaw = (new URLSearchParams(window.location.search).get('size') || '').toLowerCase();
const queryQuality = VALID_QUALITIES.has(queryQualityRaw) && queryQualityRaw !== '' ? queryQualityRaw : '';
let imageQuality = queryQuality || (VALID_QUALITIES.has(TEMPLATE_QUALITY) ? TEMPLATE_QUALITY : 'auto');
if (!VALID_QUALITIES.has(imageQuality)) {
  imageQuality = 'auto';
}
const qualityOverride = queryQuality;
// Request downsized images based on real display size so browsers avoid downloading full-resolution assets.
function computeSizedImageUrl(path, container) {
  const base = `/stream/image/${path}`;
  if (imageQuality !== 'auto') {
    const params = new URLSearchParams({ size: imageQuality });
    return `${base}?${params.toString()}`;
  }
  const width = Math.max(container.clientWidth || container.offsetWidth || window.innerWidth || 1, 1);
  const height = Math.max(container.clientHeight || container.offsetHeight || window.innerHeight || 1, 1);
  const dpr = window.devicePixelRatio || 1;
  const targetWidth = Math.max(Math.round(width * dpr), 1);
  const targetHeight = Math.max(Math.round(height * dpr), 1);
  const params = new URLSearchParams({
    width: targetWidth.toString(),
    height: targetHeight.toString(),
  });
  return `${base}?${params.toString()}`;
}

// Preload upcoming images off-screen so swaps are instant and flicker-free when the visible element is replaced.
function startPreload(url) {
  const preloadImg = document.createElement('img');
  preloadImg.style.position = 'absolute';
  preloadImg.style.left = '-10000px';
  preloadImg.style.top = '-10000px';
  preloadImg.style.width = '1px';
  preloadImg.style.height = '1px';
  preloadImg.style.pointerEvents = 'none';
  preloadImg.setAttribute('aria-hidden', 'true');
  preloadImg.decoding = 'async';
  preloadImg.loading = 'eager';
  preloadImg.alt = '';
  document.body.appendChild(preloadImg);

  let settled = false;
  const ready = new Promise((resolve, reject) => {
    const cleanup = () => {
      preloadImg.removeEventListener('load', handleLoad);
      preloadImg.removeEventListener('error', handleError);
    };
    function handleLoad() {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      resolve(preloadImg);
    }
    function handleError(err) {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      preloadImg.remove();
      reject(err || new Error('Failed to preload image'));
    }
    preloadImg.addEventListener('load', handleLoad, { once: true });
    preloadImg.addEventListener('error', handleError, { once: true });
  });

  preloadImg.src = url;
  return { element: preloadImg, ready };
}

// Reset styles before showing the preloaded element so layouts remain responsive.
function prepareImageForDisplay(img) {
  img.style.position = '';
  img.style.left = '';
  img.style.top = '';
  img.style.width = '';
  img.style.height = '';
  img.style.pointerEvents = '';
  img.style.maxWidth = '100%';
  img.style.maxHeight = '100%';
  img.style.objectFit = 'contain';
  img.removeAttribute('aria-hidden');
  img.loading = 'eager';
  img.decoding = 'async';
  img.alt = img.alt || '';
}

function stopRotationLoop() {
  if (cancelRotation) {
    cancelRotation();
    cancelRotation = null;
  }
  if (rotationTimer) {
    clearTimeout(rotationTimer);
    rotationTimer = null;
  }
  setMediaController(createNoopMediaController());
}

function teardownHlsInstance() {
  if (activeHls) {
    try {
      activeHls.destroy();
    } catch (err) {
      console.warn('Failed to destroy Hls instance', err);
    }
    activeHls = null;
  }
}

// Load hls.js lazily so we only download the library when the server actually provides an HLS stream.
function ensureHlsLibrary() {
  if (window.Hls) {
    return Promise.resolve(window.Hls);
  }
  if (!hlsLoaderPromise) {
    hlsLoaderPromise = new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
      script.async = true;
      script.onload = () => resolve(window.Hls);
      script.onerror = () => reject(new Error('Failed to load hls.js'));
      document.head.appendChild(script);
    });
  }
  return hlsLoaderPromise;
}

async function displaySingleImage(path, container) {
  setMediaController(createNoopMediaController());
  clearPlaybackTimer();
  teardownActiveVideo();
  if (!path) {
    container.textContent = 'No image selected';
    updateBackdropSource('');
    return;
  }
  container.textContent = 'Loading...';
  try {
    const sizedUrl = computeSizedImageUrl(path, container);
    const preload = startPreload(sizedUrl);
    const img = await preload.ready;
    prepareImageForDisplay(img);
    container.replaceChildren(img);
    updateBackdropSource(img.currentSrc || img.src || sizedUrl);
  } catch (err) {
    console.error('Failed to load image', err);
    container.textContent = 'Unable to load image';
    updateBackdropSource('');
  }
}

async function displaySingleMedia(config, container) {
  const path = config && config.selected_image ? config.selected_image : null;
  const kind = detectMediaKind(path, config && config.selected_media_kind);
  if (kind === 'video') {
    clearPlaybackTimer();
    teardownActiveVideo();
    if (!path) {
      container.textContent = 'No media selected';
      updateBackdropSource('');
      setMediaController(createNoopMediaController());
      return;
    }
    const playbackMode = normalizePlaybackMode(config && config.video_playback_mode);
    const controller = {
      skipNext: () => {},
      skipPrev: () => {},
      play: () => { if (activeVideoElement) { activeVideoElement.play().catch(() => {}); } },
      pause: () => { if (activeVideoElement) { activeVideoElement.pause(); } },
      toggle: () => {
        if (!activeVideoElement) {
          return;
        }
        if (activeVideoElement.paused) {
          activeVideoElement.play().catch(() => {});
        } else {
          activeVideoElement.pause();
        }
      },
      setVolume: value => updateVideoVolume(value),
    };
    setMediaController(controller);
    const video = document.createElement('video');
    video.className = 'stream-video';
    video.playsInline = true;
    video.autoplay = true;
    video.controls = false;
    video.preload = 'auto';
    const volume = clampVolume(config && config.video_volume);
    video.volume = volume;
    video.muted = volume <= 0;
    video.style.width = '100%';
    video.style.height = '100%';
    if (playbackMode === 'loop') {
      video.loop = true;
    }
    video.src = `/stream/video/${path}`;
    container.replaceChildren(video);
    updateBackdropSource('');
    const handlers = {
      error: () => console.error('Single video playback error'),
    };
    video.addEventListener('error', handlers.error);
    setActiveVideoElement(video, handlers);
    const playPromise = video.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(err => {
        console.warn('Muted autoplay fallback', err);
        video.muted = true;
        video.play().catch(() => {});
      });
    }
  } else {
    await displaySingleImage(path, container);
  }
}

function startRandomRotation(config, container) {
  const folder = config.folder || 'all';
  const hideNsfw = Boolean(config.hide_nsfw);
  const mediaMode = (config.media_mode || 'image').toLowerCase();
  const sequential = config.shuffle === false;
  const playbackMode = normalizePlaybackMode(config.video_playback_mode);
  const durationSeconds = Math.max(Number(config.duration) || 5, 1);
  let cancelled = false;
  let seqIndex = 0;
  let pendingPreload = null;
  let isAdvancing = false;
  mediaHistory = [];
  mediaHistoryIndex = -1;

  clearPlaybackTimer();
  teardownActiveVideo();
  if (rotationTimer) {
    clearTimeout(rotationTimer);
    rotationTimer = null;
  }

  container.textContent = 'Loading...';

  const baseParams = new URLSearchParams({ folder });
  if (hideNsfw) {
    baseParams.set('hide_nsfw', '1');
  }
  if (mediaMode === 'image') {
    baseParams.set('kind', 'image');
  } else if (mediaMode === 'video') {
    baseParams.set('kind', 'video');
  }

  function getVolume() {
    const sourceVol = currentConfig && currentConfig.video_volume !== undefined ? currentConfig.video_volume : config.video_volume;
    return clampVolume(sourceVol);
  }

  function scheduleImageAdvance() {
    if (cancelled) {
      return;
    }
    clearPlaybackTimer();
    rotationTimer = setTimeout(() => { advance('timer').catch(err => console.error('Advance failed', err)); }, Math.max(durationSeconds * 1000, 1000));
  }

  function scheduleVideoDuration() {
    if (cancelled) {
      return;
    }
    clearPlaybackTimer();
    playbackTimer = setTimeout(() => { advance('timer').catch(err => console.error('Advance failed', err)); }, Math.max(durationSeconds * 1000, 500));
  }

  function registerController() {
    setMediaController({
      skipNext: () => {
        const useHistoryForward = mediaHistoryIndex < mediaHistory.length - 1;
        advance('manual', { useHistoryForward }).catch(err => console.error('Skip next failed', err));
      },
      skipPrev: () => { showPrevious().catch(err => console.error('Skip prev failed', err)); },
      play: () => {
        if (activeVideoElement) {
          activeVideoElement.play().catch(() => {});
        }
      },
      pause: () => {
        if (activeVideoElement) {
          activeVideoElement.pause();
        }
      },
      toggle: () => {
        if (activeVideoElement) {
          if (activeVideoElement.paused) {
            activeVideoElement.play().catch(() => {});
          } else {
            activeVideoElement.pause();
          }
        } else {
          advance('manual').catch(err => console.error('Toggle advance failed', err));
        }
      },
      setVolume: value => updateVideoVolume(value),
    });
  }

  registerController();

  cancelRotation = () => {
    cancelled = true;
    if (rotationTimer) {
      clearTimeout(rotationTimer);
      rotationTimer = null;
    }
    clearPlaybackTimer();
    teardownActiveVideo();
    if (pendingPreload && pendingPreload.parentNode) {
      pendingPreload.remove();
    }
  };

  async function fetchSequentialMedia() {
    const params = new URLSearchParams(baseParams);
    params.set('offset', String(seqIndex));
    params.set('limit', '1');
    const res = await fetch(`/media?${params.toString()}`);
    if (!res.ok) {
      throw new Error(`Media list request failed (${res.status})`);
    }
    const payload = await res.json();
    if (Array.isArray(payload) && payload.length) {
      seqIndex += 1;
      return payload[0];
    }
    if (seqIndex !== 0) {
      seqIndex = 0;
      return fetchSequentialMedia();
    }
    return null;
  }

  async function fetchRandomMedia() {
    const params = new URLSearchParams(baseParams);
    params.set('stream_id', streamId);
    const res = await fetch(`/media/random?${params.toString()}`);
    if (!res.ok) {
      if (res.status === 404) {
        return null;
      }
      throw new Error(`Random media request failed (${res.status})`);
    }
    return await res.json();
  }

  async function obtainNextMedia() {
    return sequential ? fetchSequentialMedia() : fetchRandomMedia();
  }

  async function renderImageMedia(media) {
    const sizedUrl = computeSizedImageUrl(media.path, container);
    const preload = startPreload(sizedUrl);
    pendingPreload = preload.element;
    const img = await preload.ready;
    pendingPreload = null;
    if (cancelled) {
      img.remove();
      return;
    }
    prepareImageForDisplay(img);
    container.replaceChildren(img);
    updateBackdropSource(img.currentSrc || img.src || sizedUrl);
    teardownActiveVideo();
    clearPlaybackTimer();
    if (rotationTimer) {
      clearTimeout(rotationTimer);
      rotationTimer = null;
    }
    if (playbackMode === 'duration' || playbackMode === 'until_end') {
      scheduleImageAdvance();
    }
  }

  function renderVideoMedia(media) {
    const video = document.createElement('video');
    video.className = 'stream-video';
    video.playsInline = true;
    video.autoplay = true;
    video.controls = false;
    video.preload = 'auto';
    const volume = getVolume();
    video.volume = volume;
    video.muted = volume <= 0;
    video.style.width = '100%';
    video.style.height = '100%';
    video.src = `/stream/video/${media.path}`;
    container.replaceChildren(video);
    updateBackdropSource('');
    const handlers = {};
    if (playbackMode === 'until_end') {
      handlers.ended = () => { advance('ended').catch(err => console.error('Advance after end failed', err)); };
      video.addEventListener('ended', handlers.ended);
    } else if (playbackMode === 'loop') {
      video.loop = true;
    }
    handlers.error = () => { advance('error').catch(err => console.error('Advance after error failed', err)); };
    video.addEventListener('error', handlers.error);
    setActiveVideoElement(video, handlers);
    clearPlaybackTimer();
    if (rotationTimer) {
      clearTimeout(rotationTimer);
      rotationTimer = null;
    }
    const playPromise = video.play();
    if (playbackMode === 'duration') {
      scheduleVideoDuration();
    }
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(err => {
        console.warn('Muted autoplay fallback', err);
        video.muted = true;
        video.play().catch(() => {});
      });
    }
  }

  async function showMedia(media, { fromHistory = false } = {}) {
    if (!media || !media.path) {
      container.textContent = 'No media available';
      updateBackdropSource('');
      return;
    }
    const kind = detectMediaKind(media.path, media.kind);
    if (!fromHistory) {
      mediaHistory = mediaHistory.slice(0, mediaHistoryIndex + 1);
      mediaHistory.push({ path: media.path, kind, extension: media.extension || null });
      mediaHistoryIndex = mediaHistory.length - 1;
    }
    if (kind === 'video') {
      renderVideoMedia(media);
    } else {
      await renderImageMedia(media);
    }
  }

  async function advance(reason = 'auto', options = {}) {
    if (cancelled || isAdvancing) {
      return;
    }
    isAdvancing = true;
    try {
      if (options.useHistoryForward && mediaHistoryIndex < mediaHistory.length - 1) {
        mediaHistoryIndex += 1;
        await showMedia(mediaHistory[mediaHistoryIndex], { fromHistory: true });
        return;
      }
      const media = await obtainNextMedia();
      if (cancelled) {
        return;
      }
      if (!media) {
        container.textContent = 'No media available';
        updateBackdropSource('');
        cancelRotation();
        return;
      }
      await showMedia(media);
    } catch (err) {
      console.error('Media rotation failed', err);
      if (!cancelled) {
        container.textContent = 'Unable to load media';
        updateBackdropSource('');
      }
      cancelRotation();
    } finally {
      isAdvancing = false;
    }
  }

  async function showPrevious() {
    if (mediaHistoryIndex <= 0) {
      return;
    }
    mediaHistoryIndex -= 1;
    await showMedia(mediaHistory[mediaHistoryIndex], { fromHistory: true });
  }

  mediaHistory = [];
  mediaHistoryIndex = -1;
  advance('initial').catch(err => console.error('Initial media advance failed', err));
}

function startAiRotation(paths, config, container) {
  setMediaController(createNoopMediaController());
  clearPlaybackTimer();
  teardownActiveVideo();
  if (!paths.length) {
    container.textContent = 'No AI image generated yet';
    updateBackdropSource('');
    return;
  }
  if (paths.length === 1) {
    displaySingleImage(paths[0], container);
    return;
  }

  const delayMs = Math.max((Number(config.duration) || 10) * 1000, 2000);
  let index = 0;
  let cancelled = false;
  let pendingPreload = null;

  cancelRotation = () => {
    cancelled = true;
    if (rotationTimer) {
      clearTimeout(rotationTimer);
      rotationTimer = null;
    }
    if (pendingPreload && pendingPreload.parentNode) {
      pendingPreload.remove();
    }
  };

  container.textContent = 'Loading...';

  async function cycle() {
    if (cancelled) {
      return;
    }
    const path = paths[index % paths.length];
    index += 1;
    try {
      const sizedUrl = computeSizedImageUrl(path, container);
      const preload = startPreload(sizedUrl);
      pendingPreload = preload.element;
      const img = await preload.ready;
      pendingPreload = null;
      if (cancelled) {
        img.remove();
        return;
      }
      prepareImageForDisplay(img);
      container.replaceChildren(img);
      updateBackdropSource(img.currentSrc || img.src || sizedUrl);
    } catch (err) {
      console.error('AI rotation failed', err);
      if (!cancelled) {
        container.textContent = 'Unable to load AI image';
        updateBackdropSource('');
      }
      cancelRotation();
      return;
    }

    if (!cancelled) {
      rotationTimer = setTimeout(cycle, delayMs);
    }
  }

  cycle();
}

async function render(config) {
  currentConfig = config;
  if (!qualityOverride) {
    const fromConfig = (config && typeof config.image_quality === 'string') ? config.image_quality.trim().toLowerCase() : 'auto';
    imageQuality = VALID_QUALITIES.has(fromConfig) ? fromConfig : 'auto';
  }
  const container = document.getElementById('container');
  stopRotationLoop();
  clearPlaybackTimer();
  teardownActiveVideo();
  teardownHlsInstance();
  container.innerHTML = '';
  setBackdropSettings(config && config.background_blur_enabled, config && config.background_blur_amount);
  setMediaController(createNoopMediaController());
  const mediaMode = (config && typeof config.media_mode === 'string') ? config.media_mode.trim().toLowerCase() : ((config && typeof config.mode === 'string' && config.mode.toLowerCase() === 'livestream') ? 'livestream' : (config && typeof config.mode === 'string' && config.mode.toLowerCase() === 'ai') ? 'ai' : (config && config.selected_media_kind === 'video') ? 'video' : 'image');
  const modeValue = (config && typeof config.mode === 'string') ? config.mode.trim().toLowerCase() : 'random';
  if (mediaMode === 'livestream') {
    updateBackdropSource('');
    if (config.stream_url) {
      try {
        const response = await fetch(`/stream/live?stream_id=${encodeURIComponent(streamId)}`);
        if (!response.ok) {
          throw new Error(`Stream metadata request failed (${response.status})`);
        }
        const data = await response.json();
        if (data.embed_type === 'youtube') {
          const params = `?autoplay=1&mute=${config.yt_mute ? 1 : 0}&cc_load_policy=${config.yt_cc ? 1 : 0}`;
          const iframe = document.createElement('iframe');
          iframe.src = `https://www.youtube.com/embed/${data.embed_id}${params}`;
          iframe.allow = 'autoplay';
          container.appendChild(iframe);
        } else if (data.embed_type === 'twitch') {
          const iframe = document.createElement('iframe');
          iframe.src = `https://player.twitch.tv/?channel=${data.embed_id}&parent=${location.hostname}&autoplay=true`;
          iframe.allow = 'autoplay';
          container.appendChild(iframe);
        } else if (data.embed_type === 'hls') {
          const video = document.createElement('video');
          video.controls = true;
          video.autoplay = true;
          video.playsInline = true;
          video.preload = 'auto';
          video.style.width = '100%';
          video.style.height = '100%';
          container.appendChild(video);

          if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = data.hls_url;
          } else {
            try {
              const Hls = await ensureHlsLibrary();
              if (Hls && Hls.isSupported()) {
                activeHls = new Hls();
                activeHls.loadSource(data.hls_url);
                activeHls.attachMedia(video);
              } else {
                video.src = data.hls_url;
              }
            } catch (err) {
              console.error('Failed to initialise hls.js', err);
              video.src = data.hls_url;
            }
          }
        } else {
          const iframe = document.createElement('iframe');
          iframe.src = data.original_url;
          container.appendChild(iframe);
        }
      } catch (err) {
        console.error('Failed to load livestream metadata', err);
        container.textContent = 'Unable to load stream';
      }
    } else {
      container.textContent = 'Stream URL not configured';
    }
    return;
  }

  if (mediaMode === 'ai' || modeValue === 'ai') {
    const aiImages = (config.ai_state && Array.isArray(config.ai_state.images)) ? config.ai_state.images : [];
    const paths = aiImages
      .map(item => (item && item.path) ? item.path : item)
      .filter(Boolean);
    if (!paths.length && config.selected_image) {
      paths.push(config.selected_image);
    }
    startAiRotation(paths, config, container);
    return;
  }

  if (mediaMode === 'video') {
    if (modeValue === 'specific') {
      await displaySingleMedia(config, container);
      return;
    }
    if (modeValue === 'random') {
      startRandomRotation(config, container);
      return;
    }
    container.textContent = 'No video content configured';
    updateBackdropSource('');
    return;
  }

  if (modeValue === 'specific') {
    await displaySingleMedia(config, container);
    return;
  }

  if (modeValue === 'random') {
    startRandomRotation(config, container);
    return;
  }

  container.textContent = 'No content configured';
  updateBackdropSource('');
}

function handleVideoControl(payload) {
  if (!payload || payload.stream_id !== streamId) {
    return;
  }
  const action = typeof payload.action === 'string' ? payload.action.trim().toLowerCase() : '';
  if (!action) {
    return;
  }
  if (!currentMediaController) {
    setMediaController(createNoopMediaController());
  }
  switch (action) {
    case 'play':
      currentMediaController.play();
      break;
    case 'pause':
      currentMediaController.pause();
      break;
    case 'toggle':
      currentMediaController.toggle();
      break;
    case 'skip_next':
      currentMediaController.skipNext();
      break;
    case 'skip_prev':
      currentMediaController.skipPrev();
      break;
    case 'set_volume':
      if (payload.volume !== undefined) {
        currentMediaController.setVolume(payload.volume);
      }
      break;
    default:
      break;
  }
}

async function load() {
  try {
    const res = await fetch(`/get-settings/${encodeURIComponent(streamId)}`);
    if (!res.ok) {
      throw new Error(`Settings request failed (${res.status})`);
    }
    const conf = await res.json();
    await render(conf);
  } catch (err) {
    console.error('Failed to load stream settings', err);
    const container = document.getElementById('container');
    container.textContent = 'Unable to load stream configuration';
  }
}

socket.on('refresh', data => {
  if (data.stream_id === streamId) {
    render(data.config);
  }
});

socket.on('video_control', handleVideoControl);

load();
</script>
</body>
</html>
