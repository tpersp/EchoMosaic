<!DOCTYPE html>
<!-- IMPORTANT: Keep single stream page UI-free. Do not add headers or extra UI
without explicit instruction; content should be edge-to-edge for immersion. -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ stream_id|capitalize }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='stream.css') }}">
  </head>
<body>
<!-- NOTE: No header/toolbars here; keep media full-screen friendly. -->
<div class="stream-wrapper" id="stream-wrapper">
  <div class="media-backdrop" id="media-backdrop" aria-hidden="true"></div>
  <div id="container" class="media-container"></div>
</div>
<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
// Apply saved theme (silently, no UI)
(function(){
  const root = document.documentElement;
  const saved = localStorage.getItem('theme');
  root.setAttribute('data-theme', saved === 'light' ? 'light' : 'dark');
})();

const streamId = "{{ stream_id }}";
const socket = io();
const MAX_BACKDROP_BLUR = 40;
const backdropEl = document.getElementById('media-backdrop');
let rotationTimer = null;
let cancelRotation = null;
let hlsLoaderPromise = null;
let activeHls = null;
let backdropState = {
  enabled: false,
  amount: 50,
};
let backdropSource = '';

let currentConfig = null;
let activeVideoElement = null;
let activeVideoHandlers = null;
let playbackTimer = null;
let currentMediaController = null;
let serverPlaybackState = null;
let activeMediaPath = null;
let usingSynchronizedPlayback = false;
const VIDEO_PLAYBACK_MODES = new Set(['duration', 'until_end', 'loop']);
let youTubePlayer = null;
let youTubeApiPromise = null;
let youTubeLiveRetryTimer = null;

socket.on('connect', () => {
  if (usingSynchronizedPlayback) {
    socket.emit('stream_subscribe', { stream_id: streamId });
  }
});

socket.on('disconnect', () => {
  serverPlaybackState = null;
});

const VIDEO_EXTENSIONS = new Set(['.mp4', '.mkv', '.webm', '.mov', '.avi', '.m4v', '.mpg', '.mpeg']);

function clampBlurAmount(raw) {
  const num = Number(raw);
  if (!Number.isFinite(num)) {
    return 50;
  }
  return Math.min(100, Math.max(0, Math.round(num)));
}

function applyBackdropState() {
  if (!backdropEl) {
    return;
  }
  const amount = clampBlurAmount(backdropState.amount);
  const blurPx = Math.round((amount / 100) * MAX_BACKDROP_BLUR);
  backdropEl.style.setProperty('--backdrop-blur', `${blurPx}px`);
  const active = Boolean(backdropState.enabled && backdropSource);
  if (active) {
    backdropEl.style.backgroundImage = `url(${JSON.stringify(backdropSource)})`;
    backdropEl.classList.add('is-active');
  } else {
    backdropEl.classList.remove('is-active');
    if (!backdropSource) {
      backdropEl.style.backgroundImage = '';
    }
  }
}

function setBackdropSettings(enabled, amount) {
  backdropState = {
    enabled: Boolean(enabled),
    amount: clampBlurAmount(amount),
  };
  applyBackdropState();
}

function updateBackdropSource(url) {
  backdropSource = url || '';
  applyBackdropState();
}

function createNoopMediaController() {
  return {
    skipNext: () => {},
    skipPrev: () => {},
    play: () => {},
    pause: () => {},
    toggle: () => {},
    setVolume: () => {},
  };
}

function setMediaController(controller) {
  currentMediaController = controller || createNoopMediaController();
}

function ensureYouTubeIframeApi() {
  if (window.YT && typeof window.YT.Player === 'function') {
    return Promise.resolve(window.YT);
  }
  if (youTubeApiPromise) {
    return youTubeApiPromise;
  }
  youTubeApiPromise = new Promise((resolve, reject) => {
    const finish = () => {
      if (window.YT && typeof window.YT.Player === 'function') {
        resolve(window.YT);
      } else {
        reject(new Error('YouTube API unavailable'));
      }
    };
    const timeoutId = setTimeout(() => {
      youTubeApiPromise = null;
      reject(new Error('Timed out loading YouTube API'));
    }, 10000);
    const previous = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = () => {
      clearTimeout(timeoutId);
      if (typeof previous === 'function') {
        try { previous(); } catch (err) { console.warn('iframe API callback error', err); }
      }
      finish();
    };
    if (!document.getElementById('youtube-iframe-api')) {
      const script = document.createElement('script');
      script.id = 'youtube-iframe-api';
      script.src = 'https://www.youtube.com/iframe_api';
      script.async = true;
      script.onerror = () => {
        clearTimeout(timeoutId);
        youTubeApiPromise = null;
        reject(new Error('Failed to load YouTube API script'));
      };
      document.head.appendChild(script);
    }
  }).catch(err => {
    youTubeApiPromise = null;
    throw err;
  });
  return youTubeApiPromise;
}

function destroyYouTubePlayer() {
  if (youTubeLiveRetryTimer) {
    clearTimeout(youTubeLiveRetryTimer);
    youTubeLiveRetryTimer = null;
  }
  if (youTubePlayer && typeof youTubePlayer.destroy === 'function') {
    try {
      youTubePlayer.destroy();
    } catch (err) {
      console.warn('Failed to destroy YouTube player', err);
    }
  }
  youTubePlayer = null;
}

function handleYouTubeStateChange(meta, event) {
  if (!meta || !event || typeof event.data !== 'number') {
    return;
  }
  const yt = window.YT;
  if (!yt || !yt.PlayerState) {
    return;
  }
  if (meta.content_type === 'live') {
    if (event.data === yt.PlayerState.ENDED || event.data === yt.PlayerState.UNSTARTED) {
      if (youTubeLiveRetryTimer) {
        clearTimeout(youTubeLiveRetryTimer);
      }
      youTubeLiveRetryTimer = setTimeout(() => {
        try {
          event.target.stopVideo();
          event.target.playVideo();
        } catch (err) {
          console.warn('YouTube live restart failed', err);
        }
      }, 2000);
    } else if (event.data === yt.PlayerState.PLAYING) {
      if (youTubeLiveRetryTimer) {
        clearTimeout(youTubeLiveRetryTimer);
        youTubeLiveRetryTimer = null;
      }
    }
    return;
  }
  if (event.data === yt.PlayerState.ENDED) {
    try {
      if (meta.content_type === 'playlist') {
        event.target.playVideo();
      } else {
        event.target.seekTo(0, true);
        event.target.playVideo();
      }
    } catch (err) {
      console.warn('YouTube loop restart failed', err);
    }
  }
}

async function loadYouTubeEmbed(container, config, data) {
  destroyYouTubePlayer();
  const host = document.createElement('div');
  const playerId = `yt-player-${Math.random().toString(36).slice(2)}`;
  host.id = playerId;
  host.className = 'youtube-embed';
  container.appendChild(host);

  try {
    const YT = await ensureYouTubeIframeApi();
    const playerVars = {
      autoplay: 1,
      controls: 0,
      rel: 0,
      modestbranding: 1,
      playsinline: 1,
      loop: 0,
      disablekb: 1,
      fs: 0,
      iv_load_policy: 3,
      enablejsapi: 1,
    };
    if (config && config.yt_cc) {
      playerVars.cc_load_policy = 1;
    }
    if (window.location && window.location.origin) {
      playerVars.origin = window.location.origin;
    }

    const contentType = (data && data.content_type) ? String(data.content_type).toLowerCase() : 'video';
    const videoId = data && data.video_id ? String(data.video_id) : undefined;
    const playlistId = data && data.playlist_id ? String(data.playlist_id) : undefined;
    if (contentType === 'playlist' && playlistId) {
      playerVars.listType = 'playlist';
      playerVars.list = playlistId;
      playerVars.loop = 1;
      if (typeof data.start_index === 'number' && Number.isFinite(data.start_index) && data.start_index >= 0) {
        playerVars.index = Math.floor(data.start_index);
      }
    } else if (contentType === 'video') {
      playerVars.loop = 1;
      if (videoId) {
        playerVars.playlist = videoId;
      }
    } else {
      playerVars.loop = 0;
    }

    youTubePlayer = new YT.Player(playerId, {
      host: 'https://www.youtube-nocookie.com',
      videoId: videoId,
      playerVars,
      events: {
        onReady: (event) => {
          try {
            if (config && config.yt_mute) {
              event.target.mute();
            } else {
              event.target.unMute();
            }
            if (typeof data.start_seconds === 'number' && Number.isFinite(data.start_seconds) && data.start_seconds > 0) {
              event.target.seekTo(Math.max(0, data.start_seconds), true);
            }
            if (playerVars.loop && typeof event.target.setLoop === 'function') {
              event.target.setLoop(true);
            }
            if (contentType === 'playlist' && typeof event.target.setShuffle === 'function') {
              event.target.setShuffle(false);
            }
            event.target.playVideo();
          } catch (err) {
            console.warn('YouTube player ready handler error', err);
          }
        },
        onStateChange: (event) => {
          handleYouTubeStateChange({ content_type: contentType }, event);
        },
        onError: (event) => {
          console.warn('YouTube player error', event && event.data);
        },
      },
    });
  } catch (err) {
    console.error('Failed to initialise YouTube embed', err);
    container.textContent = 'Unable to load YouTube content';
  }
}

function normalizePlaybackMode(mode) {
  const value = typeof mode === 'string' ? mode.trim().toLowerCase() : '';
  return VIDEO_PLAYBACK_MODES.has(value) ? value : 'duration';
}

function clampVolume(value) {
  const numeric = Number(value);
  if (!Number.isFinite(numeric)) {
    return 1.0;
  }
  return Math.min(1, Math.max(0, numeric));
}

function detectMediaKind(path, explicitKind) {
  if (explicitKind && typeof explicitKind === 'string') {
    const normalized = explicitKind.trim().toLowerCase();
    if (normalized === 'image' || normalized === 'video') {
      return normalized;
    }
  }
  if (!path) {
    return 'image';
  }
  const lastDot = String(path).lastIndexOf('.');
  if (lastDot === -1) {
    return 'image';
  }
  const ext = String(path).slice(lastDot).toLowerCase();
  return VIDEO_EXTENSIONS.has(ext) ? 'video' : 'image';
}

function clearPlaybackTimer() {
  if (playbackTimer) {
    clearTimeout(playbackTimer);
    playbackTimer = null;
  }
}

function teardownActiveVideo() {
  if (!activeVideoElement) {
    return;
  }
  try {
    activeVideoElement.pause();
  } catch (err) {
    /* no-op */
  }
  if (activeVideoHandlers) {
    if (activeVideoHandlers.ended) {
      activeVideoElement.removeEventListener('ended', activeVideoHandlers.ended);
    }
    if (activeVideoHandlers.error) {
      activeVideoElement.removeEventListener('error', activeVideoHandlers.error);
    }
  }
  activeVideoElement.src = '';
  if (typeof activeVideoElement.load === 'function') {
    try {
      activeVideoElement.load();
    } catch (err) {
      /* ignore */
    }
  }
  activeVideoElement = null;
  activeVideoHandlers = null;
}

function setActiveVideoElement(video, handlers) {
  teardownActiveVideo();
  activeVideoElement = video;
  activeVideoHandlers = handlers || null;
}

function updateVideoVolume(volume) {
  const clamped = clampVolume(volume);
  if (activeVideoElement) {
    activeVideoElement.volume = clamped;
    activeVideoElement.muted = clamped <= 0;
  }
  if (currentConfig) {
    currentConfig.video_volume = clamped;
  }
  return clamped;
}

function computeServerPlaybackPosition(state) {
  if (!state || typeof state !== 'object') {
    return 0;
  }
  const base = Number(state.position);
  const serverTime = Number(state.server_time);
  const startedAt = Number(state.started_at);
  const duration = Number(state.duration);
  let position = Number.isFinite(base) ? base : 0;
  if (!state.is_paused) {
    const nowSeconds = Date.now() / 1000;
    if (Number.isFinite(serverTime)) {
      position += Math.max(0, nowSeconds - serverTime);
    } else if (Number.isFinite(startedAt)) {
      position = Math.max(0, nowSeconds - startedAt);
    }
  }
  if (Number.isFinite(duration) && duration > 0) {
    position = Math.min(position, duration);
  }
  return Math.max(0, position);
}

function computeDesiredVolume(state) {
  if (state && state.video_volume !== undefined) {
    return clampVolume(state.video_volume);
  }
  if (currentConfig && currentConfig.video_volume !== undefined) {
    return clampVolume(currentConfig.video_volume);
  }
  return 1.0;
}

function syncVideoCurrentTime(video, state) {
  if (!video || !state) {
    return;
  }
  const target = computeServerPlaybackPosition(state);
  const seek = () => {
    if (!Number.isFinite(target)) {
      return;
    }
    if (Math.abs(video.currentTime - target) > 0.2) {
      try {
        video.currentTime = target;
      } catch (err) {
        console.debug('Failed to adjust video position', err);
      }
    }
  };
  if (video.readyState >= 1) {
    seek();
  } else {
    const handler = () => {
      video.removeEventListener('loadedmetadata', handler);
      seek();
    };
    video.addEventListener('loadedmetadata', handler, { once: true });
  }
}

function applyVideoPlaybackState(video, state) {
  if (!video) {
    return;
  }
  const desiredVolume = computeDesiredVolume(state);
  updateVideoVolume(desiredVolume);
  if (!state || state.is_paused) {
    video.pause();
    return;
  }
  const playPromise = video.play();
  if (playPromise && typeof playPromise.catch === 'function') {
    playPromise.catch(err => {
      console.warn('Muted autoplay fallback', err);
      video.muted = true;
      video.play().catch(() => {});
    });
  }
}

function disableSynchronizedStream() {
  if (!usingSynchronizedPlayback) {
    return;
  }
  usingSynchronizedPlayback = false;
  serverPlaybackState = null;
  activeMediaPath = null;
  if (socket.connected) {
    socket.emit('stream_unsubscribe', { stream_id: streamId });
  }
}

setMediaController(createNoopMediaController());

const VALID_QUALITIES = new Set(['auto', 'thumb', 'medium', 'full']);
const TEMPLATE_QUALITY = {{ default_quality|tojson }};
const queryQualityRaw = (new URLSearchParams(window.location.search).get('size') || '').toLowerCase();
const queryQuality = VALID_QUALITIES.has(queryQualityRaw) && queryQualityRaw !== '' ? queryQualityRaw : '';
let imageQuality = queryQuality || (VALID_QUALITIES.has(TEMPLATE_QUALITY) ? TEMPLATE_QUALITY : 'auto');
if (!VALID_QUALITIES.has(imageQuality)) {
  imageQuality = 'auto';
}
const qualityOverride = queryQuality;
// Request downsized images based on real display size so browsers avoid downloading full-resolution assets.
function computeSizedImageUrl(path, container) {
  if (!path) {
    return '';
  }
  if (/^(https?:)?\/\//i.test(path) || path.startsWith('data:')) {
    return path;
  }
  const base = `/stream/image/${path}`;
  if (imageQuality !== 'auto') {
    const params = new URLSearchParams({ size: imageQuality });
    return `${base}?${params.toString()}`;
  }
  const width = Math.max(container.clientWidth || container.offsetWidth || window.innerWidth || 1, 1);
  const height = Math.max(container.clientHeight || container.offsetHeight || window.innerHeight || 1, 1);
  const dpr = window.devicePixelRatio || 1;
  const targetWidth = Math.max(Math.round(width * dpr), 1);
  const targetHeight = Math.max(Math.round(height * dpr), 1);
  const params = new URLSearchParams({
    width: targetWidth.toString(),
    height: targetHeight.toString(),
  });
  return `${base}?${params.toString()}`;
}

// Preload upcoming images off-screen so swaps are instant and flicker-free when the visible element is replaced.
function startPreload(url) {
  const preloadImg = document.createElement('img');
  preloadImg.style.position = 'absolute';
  preloadImg.style.left = '-10000px';
  preloadImg.style.top = '-10000px';
  preloadImg.style.width = '1px';
  preloadImg.style.height = '1px';
  preloadImg.style.pointerEvents = 'none';
  preloadImg.setAttribute('aria-hidden', 'true');
  preloadImg.decoding = 'async';
  preloadImg.loading = 'eager';
  preloadImg.alt = '';
  document.body.appendChild(preloadImg);

  let settled = false;
  const ready = new Promise((resolve, reject) => {
    const cleanup = () => {
      preloadImg.removeEventListener('load', handleLoad);
      preloadImg.removeEventListener('error', handleError);
    };
    function handleLoad() {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      resolve(preloadImg);
    }
    function handleError(err) {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      preloadImg.remove();
      reject(err || new Error('Failed to preload image'));
    }
    preloadImg.addEventListener('load', handleLoad, { once: true });
    preloadImg.addEventListener('error', handleError, { once: true });
  });

  preloadImg.src = url;
  return { element: preloadImg, ready };
}

// Reset styles before showing the preloaded element so layouts remain responsive.
function prepareImageForDisplay(img) {
  img.style.position = '';
  img.style.left = '';
  img.style.top = '';
  img.style.width = '';
  img.style.height = '';
  img.style.pointerEvents = '';
  img.style.maxWidth = '100%';
  img.style.maxHeight = '100%';
  img.style.objectFit = 'contain';
  img.removeAttribute('aria-hidden');
  img.loading = 'eager';
  img.decoding = 'async';
  img.alt = img.alt || '';
}

function stopRotationLoop() {
  if (cancelRotation) {
    cancelRotation();
    cancelRotation = null;
  }
  if (rotationTimer) {
    clearTimeout(rotationTimer);
    rotationTimer = null;
  }
  setMediaController(createNoopMediaController());
}

function teardownHlsInstance() {
  if (activeHls) {
    try {
      activeHls.destroy();
    } catch (err) {
      console.warn('Failed to destroy Hls instance', err);
    }
    activeHls = null;
  }
}

// Load hls.js lazily so we only download the library when the server actually provides an HLS stream.
function ensureHlsLibrary() {
  if (window.Hls) {
    return Promise.resolve(window.Hls);
  }
  if (!hlsLoaderPromise) {
    hlsLoaderPromise = new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
      script.async = true;
      script.onload = () => resolve(window.Hls);
      script.onerror = () => reject(new Error('Failed to load hls.js'));
      document.head.appendChild(script);
    });
  }
  return hlsLoaderPromise;
}

async function displaySingleImage(path, container) {
  setMediaController(createNoopMediaController());
  clearPlaybackTimer();
  teardownActiveVideo();
  if (!path) {
    container.textContent = 'No image selected';
    updateBackdropSource('');
    return;
  }
  container.textContent = 'Loading...';
  try {
    const sizedUrl = computeSizedImageUrl(path, container);
    const preload = startPreload(sizedUrl);
    const img = await preload.ready;
    prepareImageForDisplay(img);
    container.replaceChildren(img);
    updateBackdropSource(img.currentSrc || img.src || sizedUrl);
  } catch (err) {
    console.error('Failed to load image', err);
    container.textContent = 'Unable to load image';
    updateBackdropSource('');
  }
}

async function displaySingleMedia(config, container) {
  const path = config && config.selected_image ? config.selected_image : null;
  const kind = detectMediaKind(path, config && config.selected_media_kind);
  if (kind === 'video') {
    clearPlaybackTimer();
    teardownActiveVideo();
    if (!path) {
      container.textContent = 'No media selected';
      updateBackdropSource('');
      setMediaController(createNoopMediaController());
      return;
    }
    const playbackMode = normalizePlaybackMode(config && config.video_playback_mode);
    const controller = {
      skipNext: () => {},
      skipPrev: () => {},
      play: () => { if (activeVideoElement) { activeVideoElement.play().catch(() => {}); } },
      pause: () => { if (activeVideoElement) { activeVideoElement.pause(); } },
      toggle: () => {
        if (!activeVideoElement) {
          return;
        }
        if (activeVideoElement.paused) {
          activeVideoElement.play().catch(() => {});
        } else {
          activeVideoElement.pause();
        }
      },
      setVolume: value => updateVideoVolume(value),
    };
    setMediaController(controller);
    const video = document.createElement('video');
    video.className = 'stream-video';
    video.playsInline = true;
    video.autoplay = true;
    video.controls = false;
    video.preload = 'auto';
    const volume = clampVolume(config && config.video_volume);
    video.volume = volume;
    video.muted = volume <= 0;
    video.style.width = '100%';
    video.style.height = '100%';
    if (playbackMode === 'loop') {
      video.loop = true;
    }
    video.src = `/stream/video/${path}`;
    container.replaceChildren(video);
    updateBackdropSource('');
    const handlers = {
      error: () => console.error('Single video playback error'),
    };
    video.addEventListener('error', handlers.error);
    setActiveVideoElement(video, handlers);
    const playPromise = video.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch(err => {
        console.warn('Muted autoplay fallback', err);
        video.muted = true;
        video.play().catch(() => {});
      });
    }
  } else {
    await displaySingleImage(path, container);
  }
}

async function renderServerImage(media, state, container) {
  if (!media || !media.path) {
    container.textContent = 'No media available';
    updateBackdropSource('');
    return;
  }
  const path = media.path;
  const alreadyShowing =
    activeMediaPath === path &&
    container.firstElementChild &&
    container.firstElementChild.tagName === 'IMG';
  activeMediaPath = path;
  cancelRotation = () => {};
  if (alreadyShowing) {
    return;
  }
  await displaySingleImage(path, container);
}

function renderServerVideo(media, state, container) {
  if (!media || !media.path) {
    container.textContent = 'No media available';
    updateBackdropSource('');
    teardownActiveVideo();
    activeMediaPath = null;
    return;
  }
  const path = media.path;
  if (activeVideoElement && activeMediaPath === path) {
    syncVideoCurrentTime(activeVideoElement, state);
    applyVideoPlaybackState(activeVideoElement, state);
    return;
  }

  const triggerServerSkip = reason => {
    if (
      !usingSynchronizedPlayback ||
      !socket.connected ||
      !serverPlaybackState ||
      !serverPlaybackState.media ||
      serverPlaybackState.media.path !== path
    ) {
      return;
    }
    socket.emit('video_control', {
      stream_id: streamId,
      action: 'skip_next',
      reason: reason || 'auto',
    });
  };

  cancelRotation = () => {};
  activeMediaPath = path;
  clearPlaybackTimer();
  teardownActiveVideo();

  const video = document.createElement('video');
  video.className = 'stream-video';
  video.playsInline = true;
  video.autoplay = true;
  video.controls = false;
  video.preload = 'auto';
  video.style.width = '100%';
  video.style.height = '100%';

  container.replaceChildren(video);
  updateBackdropSource('');

  const handlers = {
    ended: () => {
      triggerServerSkip('ended');
    },
    error: () => {
      console.error('Synchronized video playback error for', path);
      triggerServerSkip('error');
    },
  };
  video.addEventListener('ended', handlers.ended);
  video.addEventListener('error', handlers.error);

  setActiveVideoElement(video, handlers);
  setMediaController({
    skipNext: () => {},
    skipPrev: () => {},
    play: () => { if (video.paused) { video.play().catch(() => {}); } },
    pause: () => { if (!video.paused) { video.pause(); } },
    toggle: () => {
      if (video.paused) {
        video.play().catch(() => {});
      } else {
        video.pause();
      }
    },
    setVolume: value => updateVideoVolume(value),
  });

  video.src = `/stream/video/${path}`;
  syncVideoCurrentTime(video, state);
  applyVideoPlaybackState(video, state);
}

function startSynchronizedStream(config, container) {
  usingSynchronizedPlayback = true;
  cancelRotation = () => {};
  clearPlaybackTimer();
  teardownActiveVideo();
  activeMediaPath = null;
  if (!container.firstElementChild) {
    container.textContent = 'Waiting for stream...';
  }
  updateBackdropSource('');
  if (config && config.video_volume !== undefined) {
    currentConfig.video_volume = clampVolume(config.video_volume);
  }
  if (socket.connected) {
    socket.emit('stream_subscribe', { stream_id: streamId });
  } else {
    socket.once('connect', () => {
      socket.emit('stream_subscribe', { stream_id: streamId });
    });
  }
  serverPlaybackState = null;
  fetch(`/stream/state/${encodeURIComponent(streamId)}`)
    .then(res => (res.ok ? res.json() : null))
    .then(state => {
      if (state && usingSynchronizedPlayback) {
        handleStreamUpdate(state);
      }
    })
    .catch(err => {
      console.debug('Failed to fetch synchronized stream state', err);
    });
}

function handleStreamUpdate(payload) {
  if (!payload || payload.stream_id !== streamId) {
    return;
  }
  serverPlaybackState = payload;
  if (!usingSynchronizedPlayback) {
    return;
  }
  const container = document.getElementById('container');
  if (!container) {
    return;
  }
  const media = payload.media;
  if (!media || !media.path) {
    activeMediaPath = null;
    teardownActiveVideo();
    const message = payload.error === 'no_media' ? 'No media available' : 'Stream idle';
    container.textContent = message;
    updateBackdropSource('');
    return;
  }
  const kind = detectMediaKind(media.path, media.kind);
  if (kind === 'video') {
    renderServerVideo(media, payload, container);
  } else {
    renderServerImage(media, payload, container).catch(err => {
      console.error('Failed to render synchronized image', err);
      container.textContent = 'Unable to load media';
      updateBackdropSource('');
    });
  }
}

function handleSyncTime(payload) {
  if (!payload || payload.stream_id !== streamId) {
    return;
  }
  if (!usingSynchronizedPlayback || !serverPlaybackState) {
    return;
  }
  const incomingMedia = payload.media;
  const currentMedia = serverPlaybackState.media;
  if (
    incomingMedia &&
    incomingMedia.path &&
    currentMedia &&
    currentMedia.path &&
    incomingMedia.path !== currentMedia.path
  ) {
    handleStreamUpdate(payload);
    return;
  }
  const updated = { ...serverPlaybackState };
  if (Object.prototype.hasOwnProperty.call(payload, 'media')) {
    updated.media = incomingMedia || null;
  }
  if (Object.prototype.hasOwnProperty.call(payload, 'duration')) {
    updated.duration = payload.duration;
  }
  if (Object.prototype.hasOwnProperty.call(payload, 'position')) {
    const numeric = Number(payload.position);
    updated.position = Number.isFinite(numeric) ? numeric : 0;
  }
  if (Object.prototype.hasOwnProperty.call(payload, 'started_at')) {
    updated.started_at = payload.started_at;
  }
  if (Object.prototype.hasOwnProperty.call(payload, 'is_paused')) {
    updated.is_paused = !!payload.is_paused;
  }
  if (Object.prototype.hasOwnProperty.call(payload, 'server_time')) {
    const asNumber = Number(payload.server_time);
    updated.server_time = Number.isFinite(asNumber) ? asNumber : Date.now() / 1000;
  } else {
    updated.server_time = Date.now() / 1000;
  }
  serverPlaybackState = updated;
  const media = updated.media;
  if (!media) {
    return;
  }
  const kind = detectMediaKind(media.path, media.kind);
  if (kind === 'video' && activeVideoElement) {
    syncVideoCurrentTime(activeVideoElement, updated);
    applyVideoPlaybackState(activeVideoElement, updated);
  }
}

function startAiRotation(paths, config, container) {
  setMediaController(createNoopMediaController());
  clearPlaybackTimer();
  teardownActiveVideo();
  if (!paths.length) {
    container.textContent = 'No AI image generated yet';
    updateBackdropSource('');
    return;
  }
  if (paths.length === 1) {
    displaySingleImage(paths[0], container);
    return;
  }

  const delayMs = Math.max((Number(config.duration) || 10) * 1000, 2000);
  let index = 0;
  let cancelled = false;
  let pendingPreload = null;

  cancelRotation = () => {
    cancelled = true;
    if (rotationTimer) {
      clearTimeout(rotationTimer);
      rotationTimer = null;
    }
    if (pendingPreload && pendingPreload.parentNode) {
      pendingPreload.remove();
    }
  };

  container.textContent = 'Loading...';

  async function cycle() {
    if (cancelled) {
      return;
    }
    const path = paths[index % paths.length];
    index += 1;
    try {
      const sizedUrl = computeSizedImageUrl(path, container);
      const preload = startPreload(sizedUrl);
      pendingPreload = preload.element;
      const img = await preload.ready;
      pendingPreload = null;
      if (cancelled) {
        img.remove();
        return;
      }
      prepareImageForDisplay(img);
      container.replaceChildren(img);
      updateBackdropSource(img.currentSrc || img.src || sizedUrl);
    } catch (err) {
      console.error('AI rotation failed', err);
      if (!cancelled) {
        container.textContent = 'Unable to load AI image';
        updateBackdropSource('');
      }
      cancelRotation();
      return;
    }

    if (!cancelled) {
      rotationTimer = setTimeout(cycle, delayMs);
    }
  }

  cycle();
}

async function render(config) {
  currentConfig = config;
  disableSynchronizedStream();
  if (!qualityOverride) {
    const fromConfig = (config && typeof config.image_quality === 'string') ? config.image_quality.trim().toLowerCase() : 'auto';
    imageQuality = VALID_QUALITIES.has(fromConfig) ? fromConfig : 'auto';
  }
  const container = document.getElementById('container');
  stopRotationLoop();
  clearPlaybackTimer();
  teardownActiveVideo();
  destroyYouTubePlayer();
  teardownHlsInstance();
  container.innerHTML = '';
  setBackdropSettings(config && config.background_blur_enabled, config && config.background_blur_amount);
  setMediaController(createNoopMediaController());
  const mediaMode = (config && typeof config.media_mode === 'string') ? config.media_mode.trim().toLowerCase() : ((config && typeof config.mode === 'string' && config.mode.toLowerCase() === 'livestream') ? 'livestream' : (config && typeof config.mode === 'string' && config.mode.toLowerCase() === 'ai') ? 'ai' : (config && config.selected_media_kind === 'video') ? 'video' : 'image');
  const modeValue = (config && typeof config.mode === 'string') ? config.mode.trim().toLowerCase() : 'random';
  if (mediaMode === 'livestream') {
    updateBackdropSource('');
    if (config.stream_url) {
      try {
        const response = await fetch(`/stream/live?stream_id=${encodeURIComponent(streamId)}`);
        if (!response.ok) {
          throw new Error(`Stream metadata request failed (${response.status})`);
        }
        const data = await response.json();
        if (data.embed_type === 'youtube') {
          await loadYouTubeEmbed(container, config, data);
        } else if (data.embed_type === 'twitch') {
          const iframe = document.createElement('iframe');
          iframe.src = `https://player.twitch.tv/?channel=${data.embed_id}&parent=${location.hostname}&autoplay=true`;
          iframe.allow = 'autoplay';
          container.appendChild(iframe);
        } else if (data.embed_type === 'hls') {
          const video = document.createElement('video');
          video.controls = true;
          video.autoplay = true;
          video.playsInline = true;
          video.preload = 'auto';
          video.style.width = '100%';
          video.style.height = '100%';
          container.appendChild(video);

          if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = data.hls_url;
          } else {
            try {
              const Hls = await ensureHlsLibrary();
              if (Hls && Hls.isSupported()) {
                activeHls = new Hls();
                activeHls.loadSource(data.hls_url);
                activeHls.attachMedia(video);
              } else {
                video.src = data.hls_url;
              }
            } catch (err) {
              console.error('Failed to initialise hls.js', err);
              video.src = data.hls_url;
            }
          }
        } else {
          const iframe = document.createElement('iframe');
          iframe.src = data.original_url;
          container.appendChild(iframe);
        }
      } catch (err) {
        console.error('Failed to load livestream metadata', err);
        container.textContent = 'Unable to load stream';
      }
    } else {
      container.textContent = 'Stream URL not configured';
    }
    return;
  }

  if (mediaMode === 'picsum') {
    const imageUrl = config && typeof config.selected_image === 'string' ? config.selected_image : '';
    if (!imageUrl) {
      container.textContent = 'No Picsum image fetched yet';
      updateBackdropSource('');
      return;
    }
    await displaySingleImage(imageUrl, container);
    return;
  }

  if (mediaMode === 'ai' || modeValue === 'ai') {
    const aiImages = (config.ai_state && Array.isArray(config.ai_state.images)) ? config.ai_state.images : [];
    const paths = aiImages
      .map(item => (item && item.path) ? item.path : item)
      .filter(Boolean);
    if (!paths.length && config.selected_image) {
      paths.push(config.selected_image);
    }
    startAiRotation(paths, config, container);
    return;
  }

  if (mediaMode === 'video') {
    if (modeValue === 'specific') {
      await displaySingleMedia(config, container);
      return;
    }
    if (modeValue === 'random') {
      startSynchronizedStream(config, container);
      return;
    }
    container.textContent = 'No video content configured';
    updateBackdropSource('');
    return;
  }

  if (modeValue === 'specific') {
    await displaySingleMedia(config, container);
    return;
  }

  if (modeValue === 'random') {
    startSynchronizedStream(config, container);
    return;
  }

  container.textContent = 'No content configured';
  updateBackdropSource('');
}

function handleVideoControl(payload) {
  if (!payload || payload.stream_id !== streamId) {
    return;
  }
  const action = typeof payload.action === 'string' ? payload.action.trim().toLowerCase() : '';
  if (!action) {
    return;
  }
  if (!currentMediaController) {
    setMediaController(createNoopMediaController());
  }
  switch (action) {
    case 'play':
      currentMediaController.play();
      break;
    case 'pause':
      currentMediaController.pause();
      break;
    case 'toggle':
      currentMediaController.toggle();
      break;
    case 'skip_next':
      currentMediaController.skipNext();
      break;
    case 'skip_prev':
      currentMediaController.skipPrev();
      break;
    case 'set_volume':
      if (payload.volume !== undefined) {
        currentMediaController.setVolume(payload.volume);
      }
      break;
    default:
      break;
  }
}

async function load() {
  try {
    const res = await fetch(`/get-settings/${encodeURIComponent(streamId)}`);
    if (!res.ok) {
      throw new Error(`Settings request failed (${res.status})`);
    }
    const conf = await res.json();
    await render(conf);
  } catch (err) {
    console.error('Failed to load stream settings', err);
    const container = document.getElementById('container');
    container.textContent = 'Unable to load stream configuration';
  }
}

socket.on('refresh', data => {
  if (data.stream_id === streamId) {
    render(data.config);
  }
});

socket.on('video_control', handleVideoControl);
socket.on('stream_init', handleStreamUpdate);
socket.on('stream_update', handleStreamUpdate);
socket.on('sync_time', handleSyncTime);

load();
</script>
</body>
</html>
