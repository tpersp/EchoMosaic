<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EchoMosaic Settings</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script>
  const SETTINGS_API_KEY = {{ config.get("API_KEY", "")|tojson }};

  function triggerUpdate() {
    window.location.href = '/update';
  }
  function triggerRollback() {
    if (!confirm('Roll back to the previous recorded update? This will replace current files.')) return;
    fetch('/rollback_app', {
      method: 'POST',
      headers: { 'X-API-Key': SETTINGS_API_KEY }
    })
    .then(res => res.text())
    .then(html => { document.body.innerHTML = html; })
    .catch(err => alert('Rollback failed: ' + err));
  }
  function loadUpdateInfo() {
    fetch('/update_info', { headers: { 'X-API-Key': SETTINGS_API_KEY }})
      .then(r => r.json())
      .then(info => {
        const el = (id, v) => document.getElementById(id).textContent = v || '-';
        el('branch', info.branch);
        el('current', info.current_desc || info.current_commit);
        el('remote', info.remote_desc || info.remote_commit);
        el('previous', info.previous_desc || info.previous_commit || 'None');
        const btn = document.getElementById('update-btn');
        const note = document.getElementById('update-note');
        if (info.update_available) {
          btn.disabled = false;
          note.textContent = 'Update available';
        } else {
          btn.disabled = true;
          note.textContent = 'Up to date';
        }
        const rb = document.getElementById('rollback-btn');
        rb.disabled = !info.previous_commit;
      });
  }
  document.addEventListener('DOMContentLoaded', loadUpdateInfo);
  async function loadUpdateHistory() {
    const list = document.getElementById('history-list');
    if (!list) return;
    list.innerHTML = '<li style="opacity:0.8; padding:6px 8px;">Loading…</li>';
    try {
      const res = await fetch('/update_history', { headers: { 'X-API-Key': SETTINGS_API_KEY }});
      const data = await res.json();
      const items = (data.history||[]).slice().reverse();
      if (!items.length) { list.innerHTML = '<li style="opacity:0.8; padding:6px 8px;">No updates recorded yet.</li>'; return; }
      list.innerHTML = '';
      items.forEach(ent => {
        const li = document.createElement('li');
        li.style.padding = '6px 8px';
        li.style.borderBottom = '1px solid var(--border)';
        const ts = ent.timestamp ? new Date(ent.timestamp).toLocaleString() : '';
        const branch = ent.branch || '';
        const from = ent.from_desc || '(none)';
        const to = ent.to_desc || '(unknown)';
        li.textContent = `${ts} [${branch}] ${from} → ${to}`;
        list.appendChild(li);
      });
    } catch (e) {
      list.innerHTML = '<li style="color:#f66; padding:6px 8px;">Failed to load history</li>';
    }
  }

  document.addEventListener('DOMContentLoaded', loadUpdateHistory);

  function setRestorePointStatus(message, ok = true) {
    const note = document.getElementById('restore-point-note');
    if (!note) return;
    if (!message) {
      note.style.display = 'none';
      note.textContent = '';
      return;
    }
    note.textContent = message;
    note.style.display = 'block';
    note.style.color = ok ? 'inherit' : '#f66';
    note.style.opacity = ok ? 0.85 : 1;
  }

  async function loadRestorePoints() {
    const list = document.getElementById('restore-point-list');
    if (!list) return;
    list.innerHTML = '<li style="opacity:0.8; padding:6px 8px;">Loading...</li>';
    setRestorePointStatus('');
    try {
      const res = await fetch('/restore_points', { headers: { 'X-API-Key': SETTINGS_API_KEY }});
      if (!res.ok) {
        throw new Error('Request failed');
      }
      const data = await res.json();
      const points = Array.isArray(data.restore_points) ? data.restore_points : [];
      if (!points.length) {
        list.innerHTML = '<li style="opacity:0.8; padding:6px 8px;">No restore points yet.</li>';
        return;
      }
      list.innerHTML = '';
      points.forEach(point => {
        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.alignItems = 'center';
        li.style.justifyContent = 'space-between';
        li.style.gap = '0.75rem';
        li.style.padding = '8px 10px';
        li.style.borderBottom = '1px solid var(--border)';

        const info = document.createElement('div');
        info.style.flex = '1';
        const title = document.createElement('div');
        title.textContent = point.label || point.id;
        title.style.fontWeight = '600';
        info.appendChild(title);

        const meta = document.createElement('div');
        meta.style.fontSize = '0.85rem';
        meta.style.opacity = '0.85';
        const shortCommit = point.short_commit || (point.commit ? point.commit.slice(0, 7) : '--');
        let commitInfo = 'Commit ' + shortCommit;
        if (point.branch) {
          commitInfo += ' [' + point.branch + ']';
        }
        const createdDate = point.created_at ? new Date(point.created_at) : null;
        const createdValid = createdDate && !Number.isNaN(createdDate.valueOf());
        const createdText = createdValid ? createdDate.toLocaleString() : 'Unknown';
        meta.textContent = commitInfo + ' - Saved ' + createdText;
        info.appendChild(meta);

        if (point.last_restored_at) {
          const restoredDate = new Date(point.last_restored_at);
          if (!Number.isNaN(restoredDate.valueOf())) {
            const restored = document.createElement('div');
            restored.style.fontSize = '0.8rem';
            restored.style.opacity = '0.7';
            restored.textContent = 'Last restored ' + restoredDate.toLocaleString();
            info.appendChild(restored);
          }
        }

        li.appendChild(info);

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '0.5rem';

        const restoreBtn = document.createElement('button');
        restoreBtn.type = 'button';
        restoreBtn.textContent = 'Restore';
        restoreBtn.addEventListener('click', () => restoreNamedPoint(point.id, point.label || point.id, restoreBtn));
        actions.appendChild(restoreBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => deleteRestorePoint(point.id, point.label || point.id, deleteBtn));
        actions.appendChild(deleteBtn);

        li.appendChild(actions);
        list.appendChild(li);
      });
    } catch (err) {
      list.innerHTML = '<li style="color:#f66; padding:6px 8px;">Failed to load restore points</li>';
      setRestorePointStatus('Unable to load restore points.', false);
    }
  }

  async function promptRestorePoint() {
    const label = prompt('Enter a name for this restore point:');
    if (label === null) return;
    const trimmed = label.trim();
    if (!trimmed) {
      alert('Please provide a name for the restore point.');
      return;
    }
    const btn = document.getElementById('create-restore-btn');
    if (btn) btn.disabled = true;
    setRestorePointStatus('Creating restore point...');
    try {
      const res = await fetch('/restore_points', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': SETTINGS_API_KEY
        },
        body: JSON.stringify({ label: trimmed })
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        const msg = data && data.error ? data.error : 'Failed to create restore point';
        setRestorePointStatus(msg, false);
        return;
      }
      setRestorePointStatus('Restore point created.');
      await loadRestorePoints();
    } catch (err) {
      setRestorePointStatus('Failed to create restore point.', false);
    } finally {
      if (btn) btn.disabled = false;
    }
  }

  async function restoreNamedPoint(id, label, sourceButton) {
    const name = label || id;
    if (!confirm('Are you sure you want to roll back to "' + name + '"? This will replace current files.')) return;
    if (sourceButton) sourceButton.disabled = true;
    setRestorePointStatus('Restoring "' + name + '"...');
    try {
      const res = await fetch('/rollback_app', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': SETTINGS_API_KEY
        },
        body: JSON.stringify({ restore_point_id: id })
      });
      const html = await res.text();
      document.body.innerHTML = html;
    } catch (err) {
      setRestorePointStatus('Restore failed. Please try again.', false);
      if (sourceButton) sourceButton.disabled = false;
    }
  }

  async function deleteRestorePoint(id, label, sourceButton) {
    const name = label || id;
    if (!confirm('Delete restore point "' + name + '"?')) return;
    if (sourceButton) sourceButton.disabled = true;
    setRestorePointStatus('Deleting "' + name + '"...');
    try {
      const res = await fetch('/restore_points/' + encodeURIComponent(id), {
        method: 'DELETE',
        headers: { 'X-API-Key': SETTINGS_API_KEY }
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        const msg = data && data.error ? data.error : 'Failed to delete restore point';
        setRestorePointStatus(msg, false);
        if (sourceButton) sourceButton.disabled = false;
        return;
      }
      setRestorePointStatus('Deleted "' + name + '".');
      await loadRestorePoints();
    } catch (err) {
      setRestorePointStatus('Failed to delete restore point.', false);
      if (sourceButton) sourceButton.disabled = false;
    }
  }
  document.addEventListener('DOMContentLoaded', loadRestorePoints);

  function setTimerSnapStatus(message, ok = true) {
    const note = document.getElementById('timer-snap-note');
    if (!note) return;
    if (!message) {
      note.textContent = '';
      note.style.display = 'none';
      return;
    }
    note.textContent = message;
    note.style.display = 'block';
    note.style.color = ok ? 'inherit' : '#f66';
    note.style.opacity = ok ? 0.85 : 1;
  }

  async function loadTimerSettings() {
    const toggle = document.getElementById('timer-snap-toggle');
    if (!toggle) return;
    setTimerSnapStatus('Loading…');
    try {
      const res = await fetch('/api/settings/timers', { cache: 'no-store' });
      if (!res.ok) {
        throw new Error('Request failed');
      }
      const data = await res.json();
      toggle.checked = !!data.timer_snap_enabled;
      setTimerSnapStatus('');
    } catch (err) {
      setTimerSnapStatus('Unable to load timer settings.', false);
    }
  }

  async function handleTimerSnapChange(event) {
    const toggle = event.target;
    if (!toggle) return;
    const desired = toggle.checked;
    setTimerSnapStatus('Saving…');
    toggle.disabled = true;
    try {
      const res = await fetch('/api/settings/timers', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': SETTINGS_API_KEY
        },
        body: JSON.stringify({ timer_snap_enabled: desired })
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        const msg = data && data.error ? data.error : 'Failed to update setting';
        throw new Error(msg);
      }
      const resolved = !!data.timer_snap_enabled;
      toggle.checked = resolved;
      setTimerSnapStatus(resolved ? 'Snap to full increments enabled.' : 'Snap to full increments disabled.');
    } catch (err) {
      toggle.checked = !desired;
      setTimerSnapStatus(err.message || 'Failed to update setting.', false);
    } finally {
      toggle.disabled = false;
    }
  }

  function initTimerSettingsControls() {
    const toggle = document.getElementById('timer-snap-toggle');
    if (!toggle) return;
    toggle.addEventListener('change', handleTimerSnapChange);
    loadTimerSettings();
  }

  document.addEventListener('DOMContentLoaded', initTimerSettingsControls);
</script>
</head>
<body>
  <header class="top-bar">
    <h1>Settings</h1>
    <nav>
      <a href="{{ url_for('dashboard') }}">Dashboard</a>
      <a href="{{ url_for('media_management_page') }}">Media</a>
      <button id="theme-toggle" class="icon-btn" type="button" aria-label="Toggle theme" title="Toggle theme" style="margin-left:.5rem;"></button>
    </nav>
  </header>
  <div class="container">
    <p><strong>Install Dir:</strong> {{ config.INSTALL_DIR }}</p>
    <p><strong>Service Name:</strong> {{ config.SERVICE_NAME }}</p>
    <p><strong>Update Branch:</strong> {{ config.UPDATE_BRANCH }}</p>
    <div style="margin: 1rem 0; padding: 0.75rem; border:1px solid var(--border); border-radius:4px; background: var(--surface-alt);">
      <h3 style="margin-top:0;">Update Status</h3>
      <p><strong>Branch:</strong> <span id="branch">-</span></p>
      <p><strong>Current:</strong> <span id="current">-</span></p>
      <p><strong>Latest:</strong> <span id="remote">-</span></p>
      <p><strong>Previous:</strong> <span id="previous">-</span></p>
      <p id="update-note" style="opacity:0.9;">Checking…</p>
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
        <button id="update-btn" onclick="triggerUpdate()" disabled>Update Now</button>
        <button id="rollback-btn" onclick="triggerRollback()" disabled>Rollback</button>
        <button id="create-restore-btn" type="button" onclick="promptRestorePoint()">Create Restore Point</button>
      </div>
    </div>

    <div style="margin: 1rem 0; padding: 0.75rem; border:1px solid var(--border); border-radius:4px; background: var(--surface-alt);">
      <h3 style="margin-top:0;">Restore Points</h3>
      <p style="margin-top:0; opacity:0.9;">Save a known good state so you can roll back even after additional updates.</p>
      <div style="max-height: 260px; overflow-y: auto; border:1px solid var(--border); border-radius:4px; background: var(--surface);">
        <ul id="restore-point-list" style="list-style:none; margin:0; padding:0;"></ul>
      </div>
      <p id="restore-point-note" style="display:none; margin:0.5rem 0 0; font-size:0.9rem;"></p>
    </div>

    <div style="margin: 1rem 0; padding: 0.75rem; border:1px solid var(--border); border-radius:4px; background: var(--surface-alt);">
      <h3 style="margin-top:0;">Update History</h3>
      <div id="history" style="max-height: 280px; overflow-y: auto; border:1px solid var(--border); border-radius:4px; background: var(--surface);">
        <ul id="history-list" style="list-style:none; margin:0; padding:0;"></ul>
      </div>
    </div>

    <div style="margin: 1rem 0; padding: 0.75rem; border:1px solid var(--border); border-radius:4px; background: var(--surface-alt);">
      <h3 style="margin-top:0;">Auto-Generate Timers</h3>
      <p style="margin-top:0; opacity:0.9;">Control how automatic generation timers calculate their next run across Picsum and AI streams.</p>
      <label class="toggle compact">
        <input type="checkbox" id="timer-snap-toggle">
        <span class="toggle-switch"></span>
        <span class="toggle-label">Snap Timers to Full Increments</span>
      </label>
      <p id="timer-snap-note" style="display:none; margin:0.5rem 0 0; font-size:0.9rem; opacity:0.85;"></p>
    </div>

    <div style="margin: 1rem 0; padding: 0.75rem; border:1px solid var(--border); border-radius:4px; background: var(--surface-alt);">
      <h3 style="margin-top:0;">Stable Horde Defaults</h3>
      <p style="margin-top:0;">These defaults apply whenever a stream switches to AI mode and has not saved its own overrides.</p>
      <form id="ai-defaults-form" style="display:flex; flex-direction:column; gap:0.75rem;">
        <div>
          <label for="ai-defaults-prompt" style="display:block; font-weight:600; margin-bottom:0.35rem;">Prompt</label>
          <textarea id="ai-defaults-prompt" rows="3" style="width:100%; resize:vertical;"></textarea>
        </div>
        <div>
          <label for="ai-defaults-negative" style="display:block; font-weight:600; margin-bottom:0.35rem;">Negative Prompt</label>
          <textarea id="ai-defaults-negative" rows="2" style="width:100%; resize:vertical;"></textarea>
        </div>
        <div class="ai-option-grid">
          <div class="ai-option">
            <label for="ai-defaults-model">Model</label>
            <select id="ai-defaults-model" class="ai-model-select">
              <option value="">Auto-select</option>
            </select>
          </div>
          <div class="ai-option">
            <label for="ai-defaults-sampler">Sampler</label>
            {% set sampler_options = ['k_euler','k_euler_a','k_dpmpp_2m','k_dpmpp_2m_sde','k_dpmpp_sde','k_lms','k_heun','k_dpm_2','k_dpm_2_a','k_dpm_fast','k_dpm_adaptive','ddim','plms'] %}
            <select id="ai-defaults-sampler">
              <option value="">Auto-select</option>
              {% for opt in sampler_options %}
              <option value="{{ opt }}">{{ opt }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="ai-option">
            <label for="ai-defaults-width">Width</label>
            <input id="ai-defaults-width" type="number" min="64" max="2048" step="64">
          </div>
          <div class="ai-option">
            <label for="ai-defaults-height">Height</label>
            <input id="ai-defaults-height" type="number" min="64" max="2048" step="64">
          </div>
          <div class="ai-option">
            <label for="ai-defaults-steps">Steps</label>
            <input id="ai-defaults-steps" type="number" min="1" max="100">
          </div>
          <div class="ai-option">
            <label for="ai-defaults-cfg">CFG</label>
            <input id="ai-defaults-cfg" type="number" step="0.5" min="1" max="20">
          </div>
          <div class="ai-option">
            <label for="ai-defaults-samples">Images</label>
            <input id="ai-defaults-samples" type="number" min="1" max="10">
          </div>
          <div class="ai-option">
            <label for="ai-defaults-seed">Seed</label>
            <input id="ai-defaults-seed" type="text" placeholder="random">
          </div>
          <div class="ai-option">
            <label for="ai-defaults-timeout">Timeout (secs)</label>
            <input id="ai-defaults-timeout" type="number" step="1" min="0">
          </div>
        </div>
        <div style="display:flex; flex-wrap:wrap; gap:0.75rem;">
          <label class="toggle compact"><input type="checkbox" id="ai-defaults-save-output"><span class="toggle-switch"></span><span class="toggle-label">Persist Images</span></label>
          <label class="toggle compact"><input type="checkbox" id="ai-defaults-nsfw"><span class="toggle-switch"></span><span class="toggle-label">Allow NSFW</span></label>
          <label class="toggle compact"><input type="checkbox" id="ai-defaults-censor"><span class="toggle-switch"></span><span class="toggle-label">Censor NSFW</span></label>
        </div>
        <details class="ai-advanced-options" open>
          <summary>Advanced Flags</summary>
          <div class="ai-advanced-grid">
            <div class="ai-advanced-group" style="display:flex; flex-direction:column; gap:0.4rem;">
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-hires-fix"><span class="toggle-switch"></span><span class="toggle-label">Hires Fix</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-karras"><span class="toggle-switch"></span><span class="toggle-label">Karras Noise</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-tiling"><span class="toggle-switch"></span><span class="toggle-label">Tiling</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-transparent"><span class="toggle-switch"></span><span class="toggle-label">Transparent BG</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-trusted"><span class="toggle-switch"></span><span class="toggle-label">Trusted Workers</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-validated"><span class="toggle-switch"></span><span class="toggle-label">Validated Backends</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-slow"><span class="toggle-switch"></span><span class="toggle-label">Allow Slow Workers</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-extra-slow"><span class="toggle-switch"></span><span class="toggle-label">Allow Extra Slow</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-disable-batching"><span class="toggle-switch"></span><span class="toggle-label">Disable Batching</span></label>
              <label class="toggle compact"><input type="checkbox" id="ai-defaults-allow-downgrade"><span class="toggle-switch"></span><span class="toggle-label">Allow Downgrade</span></label>
            </div>
            <div class="ai-advanced-group" style="display:flex; flex-direction:column; gap:0.45rem;">
              <label style="display:flex; flex-direction:column; gap:0.25rem;">
                <span style="font-size:0.8rem; font-weight:600;">Clip Skip</span>
                <input id="ai-defaults-clip-skip" type="number" min="1" max="12" placeholder="Auto">
              </label>
              <label style="display:flex; flex-direction:column; gap:0.25rem;">
                <span style="font-size:0.8rem; font-weight:600;">Face Fixer Strength</span>
                <input id="ai-defaults-facefixer" type="number" min="0" max="1" step="0.01" placeholder="Auto">
              </label>
              <label style="display:flex; flex-direction:column; gap:0.25rem;">
                <span style="font-size:0.8rem; font-weight:600;">Denoising Strength</span>
                <input id="ai-defaults-denoise" type="number" min="0.01" max="1" step="0.01" placeholder="Auto">
              </label>
              <label style="display:flex; flex-direction:column; gap:0.25rem;">
                <span style="font-size:0.8rem; font-weight:600;">Hires Denoise Strength</span>
                <input id="ai-defaults-hires-denoise" type="number" min="0.01" max="1" step="0.01" placeholder="Auto">
              </label>
              <label style="display:flex; flex-direction:column; gap:0.25rem;">
                <span style="font-size:0.8rem; font-weight:600;">Style</span>
                <input id="ai-defaults-style" type="text" placeholder="Optional">
              </label>
            </div>
          </div>
          <div class="ai-post-processing">
            <div class="section-title">Post Processing</div>
            <div class="post-processing-options">
              {% for proc in post_processors %}
              <label><input type="checkbox" class="ai-defaults-post" value="{{ proc }}"> {{ proc }}</label>
              {% endfor %}
            </div>
          </div>
        </details>
        <div class="ai-lora-section" data-max="{{ max_loras }}">
          <div class="lora-header" style="display:flex; align-items:center; justify-content:space-between; gap:0.5rem;">
            <span style="font-weight:600;">Default LoRAs</span>
            <button type="button" class="ai-add-lora">Add LoRA</button>
          </div>
          <div class="ai-lora-search">
            <input type="text" class="ai-lora-search-input" placeholder="Search LoRAs on CivitAI (e.g. 'anime')">
            <button type="button" class="ai-lora-search-btn">Search</button>
            <a class="ai-lora-browse" href="https://civitai.com/models?types=LORA&sort=Highest%20Rated" target="_blank" rel="noopener">Browse</a>
          </div>
          <div class="ai-lora-results" hidden>
            <div class="ai-lora-results-header"></div>
            <div class="ai-lora-results-list"></div>
          </div>
          <div class="ai-lora-list"></div>
          <div class="ai-lora-empty" style="opacity:0.75; font-size:0.85rem;">No default LoRAs selected.</div>
        </div>
        <div style="display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;">
          <button type="button" id="ai-defaults-save">Save Defaults</button>
          <button type="button" id="ai-defaults-reset">Reset to Fallback</button>
          <span id="ai-defaults-status" style="opacity:0.9;"></span>
        </div>
      </form>
    </div>

    <div style="margin: 1rem 0; padding: 0.75rem; border:1px solid var(--border); border-radius:4px; background: var(--surface-alt);">
      <h3 style="margin-top:0;">Backup / Restore</h3>
      <p style="margin-top:0;">Export or import your dashboard streams, groups, layout and notes.</p>
      <div style="display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;">
        <button type="button" id="export-btn">Export Settings</button>
        <span id="export-status" style="opacity:0;"></span>
        <input type="file" id="import-file" accept="application/json">
        <button type="button" id="import-btn">Import</button>
        <span id="import-status" style="opacity:.9;"></span>
      </div>
    </div>

  </div>
  <script>
  (function(){
    const root = document.documentElement;
    const btn = document.getElementById('theme-toggle');
    function apply(theme){
      const t = (theme === 'light') ? 'light' : 'dark';
      root.setAttribute('data-theme', t);
      if (btn) btn.textContent = t === 'light' ? '\u2600' : '\u263D';
    }
    const saved = localStorage.getItem('theme') || 'dark';
    apply(saved);
    if (btn) btn.addEventListener('click', () => {
      const cur = root.getAttribute('data-theme') === 'light' ? 'light' : 'dark';
      const next = cur === 'light' ? 'dark' : 'light';
      apply(next);
      try { localStorage.setItem('theme', next); } catch(e){}
    });
  })();
  </script>
  <script>
  (function(){
    const form = document.getElementById('ai-defaults-form');
    if (!form) return;

    const saveBtn = document.getElementById('ai-defaults-save');
    const resetBtn = document.getElementById('ai-defaults-reset');
    const status = document.getElementById('ai-defaults-status');
    const fallback = {{ ai_fallback_defaults|tojson }};
    let current = {{ ai_defaults|tojson }};

    const aiModelCache = { models: null, promise: null };

    const fieldSelectors = {
      prompt: '#ai-defaults-prompt',
      negative_prompt: '#ai-defaults-negative',
      model: '#ai-defaults-model',
      sampler: '#ai-defaults-sampler',
      width: '#ai-defaults-width',
      height: '#ai-defaults-height',
      steps: '#ai-defaults-steps',
      cfg_scale: '#ai-defaults-cfg',
      samples: '#ai-defaults-samples',
      seed: '#ai-defaults-seed',
      timeout: '#ai-defaults-timeout',
      clip_skip: '#ai-defaults-clip-skip',
      facefixer_strength: '#ai-defaults-facefixer',
      denoising_strength: '#ai-defaults-denoise',
      hires_fix_denoising_strength: '#ai-defaults-hires-denoise',
      style: '#ai-defaults-style',
    };

    const booleanSelectors = {
      save_output: '#ai-defaults-save-output',
      nsfw: '#ai-defaults-nsfw',
      censor_nsfw: '#ai-defaults-censor',
      hires_fix: '#ai-defaults-hires-fix',
      karras: '#ai-defaults-karras',
      tiling: '#ai-defaults-tiling',
      transparent: '#ai-defaults-transparent',
      trusted_workers: '#ai-defaults-trusted',
      validated_backends: '#ai-defaults-validated',
      slow_workers: '#ai-defaults-slow',
      extra_slow_workers: '#ai-defaults-extra-slow',
      disable_batching: '#ai-defaults-disable-batching',
      allow_downgrade: '#ai-defaults-allow-downgrade',
    };

    const postProcessingChecks = Array.from(form.querySelectorAll('.ai-defaults-post'));

    const modelSelect = form.querySelector('#ai-defaults-model');

    const loraSection = form.querySelector('.ai-lora-section');
    const loraList = loraSection ? loraSection.querySelector('.ai-lora-list') : null;
    const loraEmpty = loraSection ? loraSection.querySelector('.ai-lora-empty') : null;
    const loraSearchInput = loraSection ? loraSection.querySelector('.ai-lora-search-input') : null;
    const loraSearchBtn = loraSection ? loraSection.querySelector('.ai-lora-search-btn') : null;
    const loraResultsWrap = loraSection ? loraSection.querySelector('.ai-lora-results') : null;
    const loraResultsHeader = loraResultsWrap ? loraResultsWrap.querySelector('.ai-lora-results-header') : null;
    const loraResultsList = loraResultsWrap ? loraResultsWrap.querySelector('.ai-lora-results-list') : null;
    const addLoraBtn = loraSection ? loraSection.querySelector('.ai-add-lora') : null;

    const setStatus = (msg, ok = true) => {
      if (!status) return;
      status.textContent = msg;
      status.style.color = ok ? 'inherit' : '#f77';
    };

    const ensureSelectOption = (select, value) => {
      if (!select) return;
      const str = value === undefined || value === null ? '' : String(value);
      if (!str) {
        select.value = '';
        return;
      }
      let exists = false;
      for (const opt of select.options) {
        if (opt.value === str) {
          exists = true;
          break;
        }
      }
      if (!exists) {
        const opt = new Option(str, str, true, true);
        select.appendChild(opt);
      }
      select.value = str;
    };

    const assignValue = (selector, value) => {
      const el = form.querySelector(selector);
      if (!el) return;
      if (el.tagName === 'SELECT') {
        ensureSelectOption(el, value);
      } else if (el.type === 'number') {
        if (value === undefined || value === null || value === '') {
          el.value = '';
        } else {
          el.value = value;
        }
      } else {
        el.value = value === undefined || value === null ? '' : String(value);
      }
    };

    const renderLoraEmptyState = () => {
      if (!loraEmpty) return;
      const hasRows = loraList && loraList.querySelector('.ai-lora-row');
      loraEmpty.hidden = !!hasRows;
    };

    const updateLoraAddState = () => {
      if (!loraSection || !addLoraBtn) return;
      const max = parseInt(loraSection.dataset.max || '0', 10) || 0;
      const current = loraList ? loraList.querySelectorAll('.ai-lora-row').length : 0;
      addLoraBtn.disabled = max > 0 && current >= max;
    };

    const bindLoraRow = (row) => {
      if (!row) return;
      const removeBtn = row.querySelector('.ai-lora-remove');
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          row.remove();
          renderLoraEmptyState();
          updateLoraAddState();
          setStatus('');
        });
      }
      row.querySelectorAll('input').forEach(input => {
        input.addEventListener('input', () => setStatus(''));
        input.addEventListener('change', () => setStatus(''));
      });
    };

    const createLoraRow = (data = {}) => {
      const row = document.createElement('div');
      row.className = 'ai-lora-row';
      row.innerHTML = `
        <input type="text" class="ai-lora-name" placeholder="Name or CivitAI ID">
        <input type="number" class="ai-lora-model" placeholder="Model" step="0.05" min="-5" max="5">
        <input type="number" class="ai-lora-clip" placeholder="Clip" step="0.05" min="-5" max="5">
        <input type="text" class="ai-lora-trigger" placeholder="Trigger (optional)">
        <label class="toggle compact ai-lora-flag"><input type="checkbox" class="ai-lora-is-version"><span class="toggle-switch"></span><span class="toggle-label">Version ID</span></label>
        <button type="button" class="ai-lora-remove">Remove</button>
      `;
      const nameInput = row.querySelector('.ai-lora-name');
      if (nameInput) nameInput.value = data.name ? String(data.name) : '';
      const modelInput = row.querySelector('.ai-lora-model');
      if (modelInput && data.model !== undefined && data.model !== null && data.model !== '') {
        modelInput.value = data.model;
      }
      const clipInput = row.querySelector('.ai-lora-clip');
      if (clipInput && data.clip !== undefined && data.clip !== null && data.clip !== '') {
        clipInput.value = data.clip;
      }
      const triggerInput = row.querySelector('.ai-lora-trigger');
      if (triggerInput && data.inject_trigger) {
        triggerInput.value = String(data.inject_trigger);
      }
      const versionChk = row.querySelector('.ai-lora-is-version');
      if (versionChk && data.is_version) {
        versionChk.checked = true;
      }
      bindLoraRow(row);
      return row;
    };

    const appendLoraRow = (data = {}) => {
      if (!loraSection || !loraList) return null;
      const max = parseInt(loraSection.dataset.max || '0', 10) || 0;
      const current = loraList.querySelectorAll('.ai-lora-row').length;
      if (max > 0 && current >= max) {
        setStatus(`Maximum of ${max} LoRAs reached`, false);
        return null;
      }
      const row = createLoraRow(data);
      loraList.appendChild(row);
      renderLoraEmptyState();
      updateLoraAddState();
      return row;
    };

    const renderLoraList = (list) => {
      if (!loraList) return;
      loraList.innerHTML = '';
      const entries = Array.isArray(list) ? list : [];
      entries.forEach(entry => {
        const row = createLoraRow(entry || {});
        loraList.appendChild(row);
      });
      renderLoraEmptyState();
      updateLoraAddState();
    };

    const parseNumber = (value, { allowEmpty = false, int = false } = {}) => {
      const trimmed = String(value ?? '').trim();
      if (!trimmed) {
        return allowEmpty ? null : NaN;
      }
      const num = int ? parseInt(trimmed, 10) : parseFloat(trimmed);
      return Number.isNaN(num) ? NaN : num;
    };

    const gatherLoras = () => {
      if (!loraList) return [];
      const rows = loraList.querySelectorAll('.ai-lora-row');
      const result = [];
      rows.forEach(row => {
        const nameInput = row.querySelector('.ai-lora-name');
        const name = nameInput ? nameInput.value.trim() : '';
        if (!name) return;
        const entry = { name };
        const modelInput = row.querySelector('.ai-lora-model');
        if (modelInput && modelInput.value.trim() !== '') {
          const parsed = parseFloat(modelInput.value);
          if (!Number.isNaN(parsed)) entry.model = parsed;
        }
        const clipInput = row.querySelector('.ai-lora-clip');
        if (clipInput && clipInput.value.trim() !== '') {
          const parsed = parseFloat(clipInput.value);
          if (!Number.isNaN(parsed)) entry.clip = parsed;
        }
        const triggerInput = row.querySelector('.ai-lora-trigger');
        if (triggerInput) {
          const trig = triggerInput.value.trim();
          if (trig) entry.inject_trigger = trig;
        }
        const versionChk = row.querySelector('.ai-lora-is-version');
        if (versionChk && versionChk.checked) {
          entry.is_version = true;
        }
        result.push(entry);
      });
      return result;
    };

    const applyDefaults = (values) => {
      const data = Object.assign({}, fallback, values || {});
      Object.entries(fieldSelectors).forEach(([key, selector]) => {
        assignValue(selector, data[key]);
      });
      Object.entries(booleanSelectors).forEach(([key, selector]) => {
        const el = form.querySelector(selector);
        if (!el) return;
        el.checked = !!data[key];
      });
      const selectedPosts = new Set(Array.isArray(data.post_processing) ? data.post_processing : []);
      postProcessingChecks.forEach(box => {
        box.checked = selectedPosts.has(box.value);
      });
      renderLoraList(Array.isArray(data.loras) ? data.loras : []);
      setStatus('');
    };

    const gatherDefaults = () => {
      const payload = {};
      const requiredInts = ['width', 'height', 'steps', 'samples'];
      const optionalInts = ['clip_skip'];
      const floatFields = ['cfg_scale', 'timeout', 'facefixer_strength', 'denoising_strength', 'hires_fix_denoising_strength'];

      for (const [key, selector] of Object.entries(fieldSelectors)) {
        const el = form.querySelector(selector);
        if (!el) continue;
        if (requiredInts.includes(key)) {
          const parsed = parseNumber(el.value, { int: true });
          if (parsed === null || Number.isNaN(parsed)) {
            setStatus(`Enter a valid number for ${key.replace('_', ' ')}`, false);
            el.focus();
            return null;
          }
          payload[key] = parsed;
        } else if (optionalInts.includes(key)) {
          const parsed = parseNumber(el.value, { int: true, allowEmpty: true });
          if (Number.isNaN(parsed)) {
            setStatus(`Enter a valid number for ${key.replace('_', ' ')}`, false);
            el.focus();
            return null;
          }
          payload[key] = parsed;
        } else if (floatFields.includes(key)) {
          const allowEmpty = key !== 'cfg_scale' && key !== 'timeout';
          const parsed = parseNumber(el.value, { allowEmpty });
          if (Number.isNaN(parsed)) {
            setStatus(`Enter a valid value for ${key.replace('_', ' ')}`, false);
            el.focus();
            return null;
          }
          payload[key] = parsed;
        } else {
          let value = el.value;
          if (['seed', 'model', 'sampler', 'style'].includes(key)) {
            value = value.trim();
          }
          payload[key] = value;
        }
      }

      if (payload.seed === '' || payload.seed === null) {
        payload.seed = 'random';
      }

      Object.entries(booleanSelectors).forEach(([key, selector]) => {
        const el = form.querySelector(selector);
        if (el) payload[key] = el.checked;
      });

      payload.post_processing = postProcessingChecks.filter(box => box.checked).map(box => box.value);
      payload.loras = gatherLoras();

      return payload;
    };

    const renderLoraResults = (results, query) => {
      if (!loraResultsWrap || !loraResultsList) return;
      loraResultsWrap.hidden = false;
      loraResultsList.innerHTML = '';
      if (loraResultsHeader) {
        if (results.length) {
          loraResultsHeader.textContent = query ? `Results for "${query}"` : 'LoRA results';
        } else {
          loraResultsHeader.textContent = query ? `No LoRAs found for "${query}"` : 'No LoRAs found';
        }
      }
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'ai-lora-result-empty';
        empty.textContent = 'Try a different search term.';
        loraResultsList.appendChild(empty);
        return;
      }
      results.forEach(result => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'ai-lora-result';
        const title = document.createElement('div');
        title.className = 'ai-lora-result-title';
        const modelName = result.modelName || 'Unnamed LoRA';
        const versionName = result.versionName || (result.versionId ? `Version ${result.versionId}` : 'Unknown version');
        title.textContent = `${modelName} - ${versionName}`;
        button.appendChild(title);
        if (Array.isArray(result.triggerWords) && result.triggerWords.length) {
          const triggers = document.createElement('div');
          triggers.className = 'ai-lora-result-triggers';
          triggers.textContent = `Triggers: ${result.triggerWords.slice(0, 3).join(', ')}`;
          button.appendChild(triggers);
        }
        button.addEventListener('click', () => {
          const identifier = result.versionId ? String(result.versionId) : (result.modelName || '');
          const row = appendLoraRow({
            name: identifier,
            inject_trigger: Array.isArray(result.triggerWords) && result.triggerWords.length ? result.triggerWords.slice(0, 2).join(', ') : '',
            is_version: Boolean(result.versionId),
          });
          if (row) {
            setStatus('LoRA added (remember to save)');
          }
        });
        loraResultsList.appendChild(button);
      });
    };

    const performLoraSearch = async (query) => {
      const term = (query || '').trim();
      if (!term) {
        setStatus('Enter a search term for LoRAs', false);
        return;
      }
      if (loraResultsWrap) {
        loraResultsWrap.hidden = false;
      }
      if (loraResultsHeader) loraResultsHeader.textContent = 'Searching…';
      if (loraResultsList) loraResultsList.innerHTML = '';
      try {
        const res = await fetch(`/ai/loras?q=${encodeURIComponent(term)}`);
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.error) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        renderLoraResults(data.results || [], term);
      } catch (err) {
        if (loraResultsHeader) loraResultsHeader.textContent = 'Search failed';
        if (loraResultsList) {
          const error = document.createElement('div');
          error.className = 'ai-lora-result-error';
          error.textContent = err && err.message ? err.message : 'Unable to load LoRAs';
          loraResultsList.appendChild(error);
        }
        setStatus('LoRA search failed', false);
      }
    };

    async function fetchAiModels() {
      if (aiModelCache.models) {
        return aiModelCache.models;
      }
      if (!aiModelCache.promise) {
        aiModelCache.promise = fetch('/ai/models')
          .then(res => {
            if (!res.ok) {
              throw new Error(`Request failed (${res.status})`);
            }
            return res.json();
          })
          .then(data => Array.isArray(data.models) ? data.models : [])
          .catch(err => {
            console.error('Failed to fetch Stable Horde models', err);
            setStatus('Unable to load Stable Horde models', false);
            return [];
          })
          .finally(() => {
            aiModelCache.promise = null;
          });
        aiModelCache.promise.then(models => {
          aiModelCache.models = models;
        });
      }
      return aiModelCache.promise;
    }

    const loadModelOptions = (select) => {
      if (!select) return;
      fetchAiModels().then(models => {
        if (!Array.isArray(models) || !models.length) return;
        const existing = new Set(Array.from(select.options).map(opt => opt.value));
        models.forEach(model => {
          const name = model && model.name ? model.name : '';
          if (!name || existing.has(name)) return;
          const opt = new Option(name, name);
          select.appendChild(opt);
          existing.add(name);
        });
      }).catch(() => {});
    };

    applyDefaults(current);

    if (modelSelect) {
      ['focus', 'click'].forEach(evt => {
        modelSelect.addEventListener(evt, () => loadModelOptions(modelSelect));
      });
      modelSelect.addEventListener('change', () => setStatus(''));
    }

    if (addLoraBtn) {
      addLoraBtn.addEventListener('click', () => {
        appendLoraRow();
        setStatus('');
      });
    }
    if (loraSearchBtn) {
      loraSearchBtn.addEventListener('click', () => performLoraSearch(loraSearchInput ? loraSearchInput.value : ''));
    }
    if (loraSearchInput) {
      loraSearchInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          performLoraSearch(loraSearchInput.value);
        }
      });
    }

    Array.from(form.querySelectorAll('input, textarea, select')).forEach(el => {
      if (el === status) return;
      el.addEventListener('change', () => setStatus(''));
      if (el.tagName !== 'SELECT') {
        el.addEventListener('input', () => setStatus(''));
      }
    });

    if (saveBtn) {
      saveBtn.addEventListener('click', async () => {
        const payload = gatherDefaults();
        if (!payload) return;
        setStatus('Saving…');
        try {
          const res = await fetch('/settings/ai-defaults', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || data.status !== 'success') {
            setStatus(data.error || 'Failed to save defaults', false);
            return;
          }
          current = data.defaults || payload;
          applyDefaults(current);
          setStatus('Defaults saved');
        } catch (err) {
          setStatus('Failed to save defaults', false);
        }
      });
    }

    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        applyDefaults(fallback);
        setStatus('Fallback defaults loaded');
      });
    }
    document.addEventListener('settings-imported', evt => {
      const detail = (evt && evt.detail) ? evt.detail : {};
      if (detail && detail.ai_defaults) {
        current = detail.ai_defaults;
        applyDefaults(current);
        setStatus('Defaults updated from import');
      }
    });

  })();
  </script>

<script>
// Backup/Restore import/export handlers
(function(){
  const exportBtn = document.getElementById('export-btn');
  const exportStatus = document.getElementById('export-status');
  const setExportStatus = (message, isError) => {
    if (!exportStatus) return;
    exportStatus.textContent = message || '';
    exportStatus.style.opacity = message ? '0.9' : '0';
    exportStatus.style.color = isError ? '#f66' : 'inherit';
  };
  if (exportBtn) {
    exportBtn.addEventListener('click', async () => {
      let exportSucceeded = false;
      setExportStatus('', false);
      exportBtn.disabled = true;
      try {
        setExportStatus('Preparing download...');
        const res = await fetch('/settings/export', { credentials: 'same-origin' });
        if (!res.ok) {
          throw new Error(`Export failed: ${res.status}`);
        }
        const blob = await res.blob();
        const suggested = res.headers.get('X-Export-Filename');
        const filename = suggested || `echo-settings-${Date.now()}.json`;
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
        exportSucceeded = true;
        setExportStatus('Download ready');
      } catch (err) {
        console.error('Settings export failed', err);
        setExportStatus('Export failed', true);
        alert('Failed to export settings. Check console for details.');
      } finally {
        exportBtn.disabled = false;
        if (exportStatus && exportSucceeded) {
          setTimeout(() => setExportStatus('', false), 2500);
        }
      }
    });
  }

  const importBtn = document.getElementById('import-btn');
  const importInput = document.getElementById('import-file');
  const importStatus = document.getElementById('import-status');
  const setImportStatus = (message, isError = false) => {
    if (!importStatus) return;
    importStatus.textContent = message || '';
    importStatus.style.opacity = message ? '0.9' : '0';
    importStatus.style.color = isError ? '#f66' : 'inherit';
  };
  if (importBtn && importInput) {
    importBtn.addEventListener('click', async () => {
      setImportStatus('');
      if (!importInput.files || !importInput.files[0]) {
        alert('Pick a JSON file to import');
        return;
      }
      const fd = new FormData();
      fd.append('file', importInput.files[0]);
      importBtn.disabled = true;
      setImportStatus('Importing...');
      try {
        const res = await fetch('/settings/import', { method: 'POST', body: fd });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data || data.success !== true) {
          const message = (data && data.error) ? data.error : 'Import failed';
          setImportStatus(message, true);
          return;
        }
        importInput.value = '';
        setImportStatus('Settings imported successfully.');
        document.dispatchEvent(new CustomEvent('settings-imported', { detail: data }));
        if (Array.isArray(data.warnings) && data.warnings.length) {
          console.warn('Settings import warnings:', data.warnings);
        }
        setTimeout(() => setImportStatus('', false), 4000);
      } catch (err) {
        console.error('Settings import failed', err);
        setImportStatus('Import failed', true);
      } finally {
        importBtn.disabled = false;
      }
    });
  }
})();
</script>

</body>
</html>
