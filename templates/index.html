<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EchoMosaic Dashboard</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<header class="top-bar">
  <h1>EchoMosaic</h1>
  <nav>
    <a href="{{ url_for('app_settings') }}">Settings</a>
  </nav>
</header>
<div class="container">

  <!-- Group Manager Card -->
  <div class="stream-card" id="group-manager">
    <div class="card-header">
      <h2>Groups</h2>
    </div>
    <div class="group-section">
      <div id="group-tiles" class="group-tiles"></div>
    </div>
  </div>

  <div class="controls">
    <button id="add-stream">Add Stream</button>
    <button id="open-mosaic">View Streams</button>
  </div>

  <div id="dashboard-grid" class="dashboard-grid">
    {# Generate a card for each stream dynamically #}
    {% for stream_id, conf in stream_settings.items() %}
    <div class="stream-card" data-stream="{{ stream_id }}">
      <div class="card-header">
        <div class="title-row">
          <h2><a class="stream-link" href="{{ url_for('render_stream', name=(conf.label if conf.label else stream_id)|slugify) }}" target="_blank">{{ conf.label if conf.label else stream_id|capitalize }}</a></h2>
          <button class="rename-stream" data-stream="{{ stream_id }}" title="Rename stream">Rename</button>
        </div>
        <button class="remove-stream" data-stream="{{ stream_id }}" aria-label="Remove stream {{ stream_id }}">Remove</button>
      </div>

      <div class="form-grid">
        <!-- Folder Selection -->
        <div class="form-row">
          <label for="folder-{{ stream_id }}">Folder</label>
          <select id="folder-{{ stream_id }}" class="folder-select" data-stream="{{ stream_id }}" title="{{ conf.folder }}">
            {% for f in subfolders %}
              <option value="{{ f }}" title="{{ f }}" {% if conf.folder == f %} selected {% endif %}>{{ f }}</option>
            {% endfor %}
          </select>
        </div>

        <!-- Mode Selection -->
        <div class="form-row">
          <label for="mode-{{ stream_id }}">Mode</label>
          <select id="mode-{{ stream_id }}" class="mode-select" data-stream="{{ stream_id }}">
            <option value="random" {% if conf.mode == 'random' %} selected {% endif %}>Random</option>
            <option value="specific" {% if conf.mode == 'specific' %} selected {% endif %}>Specific</option>
            <option value="livestream" {% if conf.mode == 'livestream' %} selected {% endif %}>Livestream</option>
          </select>
        </div>

        

        <!-- Duration -->
        <div class="form-row duration-container" {% if conf.mode != 'random' %} style="display:none;" {% endif %}>
          <label for="duration-{{ stream_id }}">Duration (sec)</label>
          <input id="duration-{{ stream_id }}" type="number" class="duration-input" data-stream="{{ stream_id }}" value="{{ conf.duration }}" min="1">
        </div>

        <!-- Stream URL -->
        <div class="form-row stream-url-container" {% if conf.mode != 'livestream' %} style="display:none;" {% endif %}>
          <label for="stream-url-{{ stream_id }}">Stream URL</label>
          <input id="stream-url-{{ stream_id }}" type="text" class="stream-url-input" data-stream="{{ stream_id }}" value="{{ conf.stream_url if conf.stream_url else '' }}" placeholder="https://...">
        </div>

        <!-- YT Settings -->
        <div class="form-row yt-settings" data-stream="{{ stream_id }}" style="display:none;">
          <div class="inline-controls">
            <label><input type="checkbox" class="yt-cc-chk" data-stream="{{ stream_id }}" {% if conf.yt_cc %} checked {% endif %}> CC</label>
            <label><input type="checkbox" class="yt-mute-chk" data-stream="{{ stream_id }}" {% if conf.yt_mute %} checked {% endif %}> Mute</label>
            <label for="yt-quality-{{ stream_id }}">Quality</label>
            <input type="text" id="yt-quality-{{ stream_id }}" class="yt-quality-input" data-stream="{{ stream_id }}" value="{{ conf.yt_quality }}" placeholder="auto/hd720/etc">
          </div>
        </div>
      </div>

      <!-- Specific Image Picker -->
      <div class="image-picker" data-stream="{{ stream_id }}" {% if conf.mode != 'specific' %} style="display:none;" {% endif %}>
        <div class="image-picker-header">
          <label>Pick an Image (Folder: {{ conf.folder }})</label>
          <button type="button" class="reload-images-btn" data-stream="{{ stream_id }}">Reload</button>
        </div>
        <div class="image-grid"></div>
      </div>

      <p class="selected-image-row">
        <strong>Selected Image:</strong>
        <span class="selected-image-display">{{ conf.selected_image if conf.selected_image else "None" }}</span>
      </p>
    </div>
    {% endfor %}
  </div>
</div>

<!-- Notification -->
<div id="notification" class="notification">Settings updated!</div>

<!-- Floating Notes Pad -->
<div id="notepad" class="notepad collapsed">
  <div class="notepad-header">
    <span>Notes</span>
    <button id="toggle-notepad">Toggle</button>
  </div>
  <textarea id="notepad-text"></textarea>
  <button id="save-notes">Save</button>
</div>

<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
  const socket = io();
  const notification = document.getElementById('notification');
  const addStreamBtn = document.getElementById('add-stream');
  const openMosaicBtn = document.getElementById('open-mosaic');
  
  // Group Manager elements
  const groupTiles = document.getElementById('group-tiles');

  function showNotification(msg) {
    notification.textContent = msg;
    notification.classList.add('show');
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }

  // No layout settings for global /stream; it adapts dynamically

  if (openMosaicBtn) {
    openMosaicBtn.addEventListener('click', () => {
      window.open('/stream', '_blank');
    });
  }

  // Group manager logic
  function makeEl(tag, attrs = {}, children = []) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v]) => { if (k==='class') e.className=v; else if (k==='style') e.style.cssText=v; else e.setAttribute(k,v); });
    children.forEach(c => e.appendChild(typeof c==='string' ? document.createTextNode(c) : c));
    return e;
  }
  async function loadGroupsUI() {
    try {
      const [streamsMeta, groups] = await Promise.all([
        fetch('/streams_meta').then(r=>r.json()),
        fetch('/groups').then(r=>r.json())
      ]);
      // Build tiles
      if (groupTiles) {
        groupTiles.innerHTML = '';
        // Add tile
        const addTile = makeEl('div', {class:'group-tile add'}, [
          makeEl('div', {class:'tile-header'}, ['+ New Group'])
        ]);
        addTile.addEventListener('click', () => {
          const tile = createGroupTile(streamsMeta, groups, null);
          groupTiles.prepend(tile);
          // open editor immediately
          const body = tile.querySelector('.tile-body');
          if (body) body.hidden = false;
          const nameInput = tile.querySelector('.tile-name');
          if (nameInput) nameInput.focus();
        });
        groupTiles.appendChild(addTile);

        // Existing group tiles
        Object.keys(groups).forEach(name => {
          groupTiles.appendChild(createGroupTile(streamsMeta, groups, name));
        });
      }
    } catch (e) { console.error('Failed to load groups UI', e); }
  }
  function selectedIds(container) {
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(c=>c.value);
  }
  function createGroupTile(streamsMeta, groups, name) {
    const members = new Set(name ? (groups[name]||[]) : []);
    const isNew = !name;
    const tile = makeEl('div', {class:'group-tile'}, []);
    const header = makeEl('div', {class:'tile-header'}, []);
    const title = makeEl('span', {class:'tile-title'}, [name || 'New Group']);
    const actions = makeEl('div', {class:'tile-actions'}, []);
    const open = name ? makeEl('a', {href:`/stream/group/${encodeURIComponent(name)}`, target:'_blank'}, ['Open']) : null;
    const edit = makeEl('button', {class:'tile-edit'}, ['Edit']);
    const del = name ? makeEl('button', {class:'tile-del'}, ['Delete']) : null;
    if (open) actions.appendChild(open);
    actions.appendChild(edit);
    if (del) actions.appendChild(del);
    header.appendChild(title);
    header.appendChild(actions);
    tile.appendChild(header);
    const body = makeEl('div', {class:'tile-body', hidden: true}, []);
    const nameRow = makeEl('div', {class:'tile-row'}, [
      makeEl('label', {}, ['Name: ', makeEl('input', {type:'text', class:'tile-name', value: name || ''}, [])])
    ]);
    body.appendChild(nameRow);
    const list = makeEl('div', {class:'group-list'}, []);
    Object.keys(streamsMeta).forEach(id => {
      const chk = makeEl('input', {type:'checkbox', value:id}, []);
      chk.checked = members.has(id);
      const lbl = makeEl('label', {}, [chk, ' ', (streamsMeta[id].label || id)]);
      const wrap = makeEl('div', {class:'group-item'}, [lbl]);
      list.appendChild(wrap);
    });
    body.appendChild(list);
    const btns = makeEl('div', {class:'tile-buttons'}, []);
    const save = makeEl('button', {class:'tile-save'}, ['Save']);
    const cancel = makeEl('button', {class:'tile-cancel'}, ['Cancel']);
    btns.appendChild(save);
    btns.appendChild(cancel);
    body.appendChild(btns);
    tile.appendChild(body);

    // interactions
    edit.addEventListener('click', () => { body.hidden = !body.hidden; });
    if (del) {
      del.addEventListener('click', async () => {
        if (!confirm(`Delete group ${name}?`)) return;
        await fetch(`/groups/${encodeURIComponent(name)}`, {method:'DELETE'});
        loadGroupsUI();
      });
    }
    save.addEventListener('click', async () => {
      const nameVal = (tile.querySelector('.tile-name').value || '').trim();
      if (!nameVal) { alert('Enter a group name'); return; }
      const ids = selectedIds(list);
      const res = await fetch('/groups', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: nameVal, streams: ids})});
      if (res.ok) {
        showNotification('Saved group');
        loadGroupsUI();
      } else {
        alert('Failed to save group');
      }
    });
    cancel.addEventListener('click', () => { body.hidden = true; });
    return tile;
  }

  // initial load
  document.addEventListener('DOMContentLoaded', loadGroupsUI);

  

  // Add a new stream by posting to /streams
  addStreamBtn.addEventListener('click', () => {
    fetch('/streams', {method:'POST'})
      .then(res => res.json())
      .then(data => {
        if (data.stream_id) {
          location.reload();
        }
      });
  });

  // Remove a stream
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('remove-stream')) {
      const id = e.target.dataset.stream;
      if (confirm('Delete ' + id + '?')) {
        fetch('/streams/' + encodeURIComponent(id), {method:'DELETE'})
          .then(res => res.json())
          .then(data => {
            if (data.status === 'deleted') {
              location.reload();
            }
          });
      }
    }
  });

  // Socket.IO listener for layout updates if needed in future
  socket.on('streams_changed', (data) => {
    // This could be used to update the UI without reload.
    console.log('Streams changed:', data);
  });

  // Notepad behaviour
  const notepad = document.getElementById('notepad');
  const toggleNotepadBtn = document.getElementById('toggle-notepad');
  const notepadText = document.getElementById('notepad-text');
  const saveNotesBtn = document.getElementById('save-notes');
  // Load notes from server
  fetch('/notes')
    .then(r => r.json())
    .then(({text}) => { notepadText.value = text || ''; })
    .catch(() => {});
  toggleNotepadBtn.addEventListener('click', () => {
    notepad.classList.toggle('collapsed');
  });
  saveNotesBtn.addEventListener('click', () => {
    fetch('/notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: notepadText.value })
    })
    .then(r => r.json())
    .then(() => showNotification('Notes saved on server'))
    .catch(() => showNotification('Failed to save notes'));
  });

  // The following section reuses much of the original dashboard logic to
  // handle folder/mode selection, duration changes, image selection and
  // reload.  It has been lightly adapted to support dynamically added
  // streams.  The logic is encapsulated in functions that operate on
  // elements with a ``data-stream`` attribute.

  function saveSettings(streamId, payload) {
    fetch(`/settings/${encodeURIComponent(streamId)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
      if (data.status === 'success') {
        showNotification(`Updated settings for ${streamId}`);
        const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
        if (card && data.new_config.selected_image !== undefined) {
          const disp = card.querySelector('.selected-image-display');
          disp.textContent = data.new_config.selected_image || 'None';
        }
      } else {
        console.error(data.error || 'Unknown error updating settings.');
      }
    })
    .catch(err => console.error('Error saving settings:', err));
  }

  function toggleVisibilityForMode(card, mode, streamUrl) {
    const durationDiv = card.querySelector('.duration-container');
    const urlDiv = card.querySelector('.stream-url-container');
    const imagePicker = card.querySelector('.image-picker');
    const ytSettingsDiv = card.querySelector('.yt-settings');
    if (durationDiv) durationDiv.style.display = (mode === 'random') ? '' : 'none';
    if (urlDiv) urlDiv.style.display = (mode === 'livestream') ? '' : 'none';
    if (imagePicker) imagePicker.style.display = (mode === 'specific') ? '' : 'none';
    if (ytSettingsDiv) {
      if (mode === 'livestream' && (streamUrl.includes('youtube.com') || streamUrl.includes('youtu.be'))) {
        ytSettingsDiv.style.display = '';
      } else {
        ytSettingsDiv.style.display = 'none';
      }
    }
  }

  function loadImagesFor(streamId, folder) {
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    const imageGrid = card.querySelector('.image-picker .image-grid');
    if (!imageGrid) return;
    const selectedDisplay = card.querySelector('.selected-image-display');
    const currentSelected = selectedDisplay ? selectedDisplay.textContent.trim() : null;
    imageGrid.innerHTML = 'Loading...';
    fetch(`/images?folder=${encodeURIComponent(folder)}`)
      .then(res => res.json())
      .then(imgs => {
        imageGrid.innerHTML = '';
        imgs.forEach(path => {
          const imgEl = document.createElement('img');
          imgEl.src = `/stream/image/${path}`;
          imgEl.title = path;
          imgEl.classList.add('picker-thumbnail');
          if (currentSelected === path) {
            imgEl.classList.add('selected-thumb');
          }
          imgEl.addEventListener('click', () => {
            saveSettings(streamId, { selected_image: path });
          });
          imageGrid.appendChild(imgEl);
        });
        if (!imgs.length) {
          imageGrid.innerHTML = '(No images found in this folder)';
        }
      })
      .catch(err => {
        console.error('Error fetching images for folder:', err);
        imageGrid.innerHTML = 'Error loading images.';
      });
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.stream-card').forEach(card => {
      const streamId = card.dataset.stream;
      // Folder change
      const folderSelect = card.querySelector('.folder-select');
      if (folderSelect) {
        // Ensure tooltip shows full folder name on hover
        folderSelect.addEventListener('change', e => {
          const folder = e.target.value;
          e.target.title = folder;
          saveSettings(streamId, { folder, selected_image: null });
        });
      }
      // Mode change
      const modeSelect = card.querySelector('.mode-select');
      const urlInput = card.querySelector('.stream-url-input');
      if (modeSelect) {
        modeSelect.addEventListener('change', e => {
          const mode = e.target.value;
          const payload = { mode };
          if (mode === 'random') {
            const durInput = card.querySelector('.duration-input');
            if (durInput) payload.duration = durInput.value;
          }
          if (mode === 'livestream') {
            if (urlInput) payload.stream_url = urlInput.value;
            const ccChk = card.querySelector('.yt-cc-chk');
            const muteChk = card.querySelector('.yt-mute-chk');
            const qualityInput = card.querySelector('.yt-quality-input');
            if (ccChk) payload.yt_cc = ccChk.checked;
            if (muteChk) payload.yt_mute = muteChk.checked;
            if (qualityInput) payload.yt_quality = qualityInput.value;
          }
          saveSettings(streamId, payload);
          toggleVisibilityForMode(card, mode, urlInput ? urlInput.value : '');
        });
      }
      // Duration change
      const durInput = card.querySelector('.duration-input');
      if (durInput) {
        durInput.addEventListener('change', e => {
          saveSettings(streamId, { duration: e.target.value });
        });
      }
      // URL change
      if (urlInput) {
        urlInput.addEventListener('change', e => {
          saveSettings(streamId, { stream_url: e.target.value });
          toggleVisibilityForMode(card, modeSelect.value, e.target.value);
        });
      }
      // YT settings changes
      const ccChk = card.querySelector('.yt-cc-chk');
      const muteChk = card.querySelector('.yt-mute-chk');
      const qualityInput = card.querySelector('.yt-quality-input');
      const renameBtn = card.querySelector('.rename-stream');
      if (ccChk) {
        ccChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_cc: e.target.checked });
        });
      }
      if (muteChk) {
        muteChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_mute: e.target.checked });
        });
      }
      if (qualityInput) {
        qualityInput.addEventListener('change', e => {
          saveSettings(streamId, { yt_quality: e.target.value });
        });
      }
      
      function slugify(s){
        return (s||'').toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,'');
      }
      if (renameBtn) {
        renameBtn.addEventListener('click', () => {
          const a = card.querySelector('.card-header h2 a.stream-link');
          const current = a ? a.textContent.trim() : streamId;
          const next = prompt('Rename stream', current);
          if (next === null) return; // cancelled
          saveSettings(streamId, { label: next });
          if (a) {
            a.textContent = next || streamId;
            const slug = slugify(next || streamId);
            a.href = '/stream/' + encodeURIComponent(slug);
          }
        });
      }
      // Reload images button
      const reloadBtn = card.querySelector('.reload-images-btn');
      if (reloadBtn) {
        reloadBtn.addEventListener('click', () => {
          const folder = folderSelect ? folderSelect.value : 'all';
          loadImagesFor(streamId, folder);
        });
      }

      toggleVisibilityForMode(card, modeSelect ? modeSelect.value : '', urlInput ? urlInput.value : '');
    });
  });
</script>
</body>
</html>
