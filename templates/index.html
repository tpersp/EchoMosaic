<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EchoMosaic Dashboard</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<header class="top-bar">
  <h1>EchoMosaic</h1>
  <nav>
    <a href="{{ url_for('app_settings') }}">Settings</a>
  </nav>
</header>
<div class="container">

  <div class="controls">
    <button id="add-stream">Add Stream</button>
    <label>Stream Layout:
      <select id="mosaic-layout-select" data-current-cols="{{ mosaic_settings.cols }}">
        <option value="grid" data-cols="1" {% if mosaic_settings.layout == 'grid' and mosaic_settings.cols == 1 %}selected{% endif %}>Grid 1 column</option>
        <option value="grid" data-cols="2" {% if mosaic_settings.layout == 'grid' and mosaic_settings.cols == 2 %}selected{% endif %}>Grid 2 columns</option>
        <option value="grid" data-cols="3" {% if mosaic_settings.layout == 'grid' and mosaic_settings.cols == 3 %}selected{% endif %}>Grid 3 columns</option>
        <option value="grid" data-cols="4" {% if mosaic_settings.layout == 'grid' and mosaic_settings.cols == 4 %}selected{% endif %}>Grid 4 columns</option>
        <option value="grid" data-cols="5" {% if mosaic_settings.layout == 'grid' and mosaic_settings.cols == 5 %}selected{% endif %}>Grid 5 columns</option>
        <option value="grid" data-cols="6" {% if mosaic_settings.layout == 'grid' and mosaic_settings.cols == 6 %}selected{% endif %}>Grid 6 columns</option>
        <option value="horizontal" {% if mosaic_settings.layout == 'horizontal' %}selected{% endif %}>Horizontal Stack</option>
        <option value="vertical" {% if mosaic_settings.layout == 'vertical' %}selected{% endif %}>Vertical Stack</option>
        <option value="focus" {% if mosaic_settings.layout == 'focus' %}selected{% endif %}>Main + Thumbs</option>
        <option value="pip" {% if mosaic_settings.layout == 'pip' %}selected{% endif %}>Picture in Picture</option>
      </select>
    </label>
    <div id="pip-options" style="display:none;">
      <label>Main Stream:
        <select id="pip-main-select">
          {% for sid, conf in stream_settings.items() %}
          <option value="{{ sid }}" {% if mosaic_settings.pip_main == sid %}selected{% endif %}>{{ sid|capitalize }}</option>
          {% endfor %}
        </select>
      </label>
      <label>Corner Stream:
        <select id="pip-pip-select">
          {% for sid, conf in stream_settings.items() %}
          <option value="{{ sid }}" {% if mosaic_settings.pip_pip == sid %}selected{% endif %}>{{ sid|capitalize }}</option>
          {% endfor %}
        </select>
      </label>
      <label>Corner:
        <select id="pip-corner-select">
          <option value="top-left" {% if mosaic_settings.pip_corner == 'top-left' %}selected{% endif %}>Top Left</option>
          <option value="top-right" {% if mosaic_settings.pip_corner == 'top-right' %}selected{% endif %}>Top Right</option>
          <option value="bottom-left" {% if mosaic_settings.pip_corner == 'bottom-left' %}selected{% endif %}>Bottom Left</option>
          <option value="bottom-right" {% if mosaic_settings.pip_corner == 'bottom-right' %}selected{% endif %}>Bottom Right</option>
        </select>
      </label>
      <label>Size (%):
        <input type="number" id="pip-size-input" min="10" max="50" value="{{ mosaic_settings.pip_size or 25 }}">
      </label>
    </div>
    <button id="open-mosaic">View Streams</button>
    <label>Group:
      <select id="group-select">
        <option value="" selected disabled>Select a group</option>
        {% for g in groups %}
        <option value="{{ g }}">{{ g }}</option>
        {% endfor %}
      </select>
    </label>
    <button id="open-group" {% if not groups or groups|length == 0 %}disabled{% endif %}>Open Group</button>
  </div>

  <div id="dashboard-grid" class="dashboard-grid">
    {# Generate a card for each stream dynamically #}
    {% for stream_id, conf in stream_settings.items() %}
    <div class="stream-card" data-stream="{{ stream_id }}">
      <div class="card-header">
        <h2><a class="stream-link" href="{{ url_for('render_stream', name=(conf.label if conf.label else stream_id)|slugify) }}" target="_blank">{{ conf.label if conf.label else stream_id|capitalize }}</a></h2>
        <button class="remove-stream" data-stream="{{ stream_id }}" aria-label="Remove stream {{ stream_id }}">Remove</button>
      </div>

      <div class="form-grid">
        <!-- Folder Selection -->
        <div class="form-row">
          <label for="folder-{{ stream_id }}">Folder</label>
          <select id="folder-{{ stream_id }}" class="folder-select" data-stream="{{ stream_id }}" title="{{ conf.folder }}">
            {% for f in subfolders %}
              <option value="{{ f }}" title="{{ f }}" {% if conf.folder == f %} selected {% endif %}>{{ f }}</option>
            {% endfor %}
          </select>
        </div>

        <!-- Mode Selection -->
        <div class="form-row">
          <label for="mode-{{ stream_id }}">Mode</label>
          <select id="mode-{{ stream_id }}" class="mode-select" data-stream="{{ stream_id }}">
            <option value="random" {% if conf.mode == 'random' %} selected {% endif %}>Random</option>
            <option value="specific" {% if conf.mode == 'specific' %} selected {% endif %}>Specific</option>
            <option value="livestream" {% if conf.mode == 'livestream' %} selected {% endif %}>Livestream</option>
          </select>
        </div>

        <!-- Label -->
        <div class="form-row">
          <label for="label-{{ stream_id }}">Label</label>
          <input id="label-{{ stream_id }}" type="text" class="label-input" data-stream="{{ stream_id }}" value="{{ conf.label if conf.label else stream_id|capitalize }}" placeholder="Display name">
        </div>


        <!-- Include in Global /stream -->
        <div class="form-row">
          <label for="include-{{ stream_id }}">Show on global /stream</label>
          <input id="include-{{ stream_id }}" type="checkbox" class="include-global-chk" data-stream="{{ stream_id }}" {% if conf.include_in_global %}checked{% endif %}>
        </div>

        <!-- Duration -->
        <div class="form-row duration-container" {% if conf.mode != 'random' %} style="display:none;" {% endif %}>
          <label for="duration-{{ stream_id }}">Duration (sec)</label>
          <input id="duration-{{ stream_id }}" type="number" class="duration-input" data-stream="{{ stream_id }}" value="{{ conf.duration }}" min="1">
        </div>

        <!-- Stream URL -->
        <div class="form-row stream-url-container" {% if conf.mode != 'livestream' %} style="display:none;" {% endif %}>
          <label for="stream-url-{{ stream_id }}">Stream URL</label>
          <input id="stream-url-{{ stream_id }}" type="text" class="stream-url-input" data-stream="{{ stream_id }}" value="{{ conf.stream_url if conf.stream_url else '' }}" placeholder="https://...">
        </div>

        <!-- YT Settings -->
        <div class="form-row yt-settings" data-stream="{{ stream_id }}" style="display:none;">
          <div class="inline-controls">
            <label><input type="checkbox" class="yt-cc-chk" data-stream="{{ stream_id }}" {% if conf.yt_cc %} checked {% endif %}> CC</label>
            <label><input type="checkbox" class="yt-mute-chk" data-stream="{{ stream_id }}" {% if conf.yt_mute %} checked {% endif %}> Mute</label>
            <label for="yt-quality-{{ stream_id }}">Quality</label>
            <input type="text" id="yt-quality-{{ stream_id }}" class="yt-quality-input" data-stream="{{ stream_id }}" value="{{ conf.yt_quality }}" placeholder="auto/hd720/etc">
          </div>
        </div>
      </div>

      <!-- Specific Image Picker -->
      <div class="image-picker" data-stream="{{ stream_id }}" {% if conf.mode != 'specific' %} style="display:none;" {% endif %}>
        <div class="image-picker-header">
          <label>Pick an Image (Folder: {{ conf.folder }})</label>
          <button type="button" class="reload-images-btn" data-stream="{{ stream_id }}">Reload</button>
        </div>
        <div class="image-grid"></div>
      </div>

      <p class="selected-image-row">
        <strong>Selected Image:</strong>
        <span class="selected-image-display">{{ conf.selected_image if conf.selected_image else "None" }}</span>
      </p>
    </div>
    {% endfor %}
  </div>
</div>

<!-- Notification -->
<div id="notification" class="notification">Settings updated!</div>

<!-- Floating Notes Pad -->
<div id="notepad" class="notepad collapsed">
  <div class="notepad-header">
    <span>Notes</span>
    <button id="toggle-notepad">Toggle</button>
  </div>
  <textarea id="notepad-text"></textarea>
  <button id="save-notes">Save</button>
</div>

<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
  const socket = io();
  const notification = document.getElementById('notification');
  const addStreamBtn = document.getElementById('add-stream');
  const mosaicLayoutSelect = document.getElementById('mosaic-layout-select');
  const pipOptions = document.getElementById('pip-options');
  const pipMainSelect = document.getElementById('pip-main-select');
  const pipPipSelect = document.getElementById('pip-pip-select');
  const pipCornerSelect = document.getElementById('pip-corner-select');
  const pipSizeInput = document.getElementById('pip-size-input');
  const openMosaicBtn = document.getElementById('open-mosaic');
  const openGroupBtn = document.getElementById('open-group');
  const groupSelect = document.getElementById('group-select');

  function showNotification(msg) {
    notification.textContent = msg;
    notification.classList.add('show');
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }

  function sendMosaicSettings() {
    const opt = mosaicLayoutSelect.selectedOptions[0];
    const layout = opt.value;
    const cols = opt.dataset.cols || mosaicLayoutSelect.dataset.currentCols;
    mosaicLayoutSelect.dataset.currentCols = cols;
    const body = { layout, cols };
    if (layout === 'pip') {
      body.pip_main = pipMainSelect.value;
      body.pip_pip = pipPipSelect.value;
      body.pip_corner = pipCornerSelect.value;
      body.pip_size = parseInt(pipSizeInput.value, 10) || 25;
    }
    fetch('/mosaic-settings', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    }).then(res => res.json()).then(() => {
      showNotification('Stream layout updated');
    });
  }

  if (mosaicLayoutSelect) {
    const handleLayoutChange = () => {
      const layout = mosaicLayoutSelect.value;
      if (pipOptions) {
        pipOptions.style.display = (layout === 'pip') ? 'block' : 'none';
      }
      sendMosaicSettings();
    };
    mosaicLayoutSelect.addEventListener('change', handleLayoutChange);
    ['pip-main-select','pip-pip-select','pip-corner-select','pip-size-input'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('change', sendMosaicSettings);
      }
    });
    handleLayoutChange();
  }

  if (openMosaicBtn) {
    openMosaicBtn.addEventListener('click', () => {
      window.open('/stream', '_blank');
    });
  }

  if (openGroupBtn && groupSelect) {
    openGroupBtn.addEventListener('click', () => {
      const name = groupSelect.value;
      if (!name) return;
      const url = '/stream/group/' + encodeURIComponent(name);
      window.open(url, '_blank');
    });
    groupSelect.addEventListener('change', () => {
      openGroupBtn.disabled = !groupSelect.value;
    });
  }

  // Add a new stream by posting to /streams
  addStreamBtn.addEventListener('click', () => {
    fetch('/streams', {method:'POST'})
      .then(res => res.json())
      .then(data => {
        if (data.stream_id) {
          location.reload();
        }
      });
  });

  // Remove a stream
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('remove-stream')) {
      const id = e.target.dataset.stream;
      if (confirm('Delete ' + id + '?')) {
        fetch('/streams/' + encodeURIComponent(id), {method:'DELETE'})
          .then(res => res.json())
          .then(data => {
            if (data.status === 'deleted') {
              location.reload();
            }
          });
      }
    }
  });

  // Socket.IO listener for layout updates if needed in future
  socket.on('streams_changed', (data) => {
    // This could be used to update the UI without reload.
    console.log('Streams changed:', data);
  });

  // Notepad behaviour
  const notepad = document.getElementById('notepad');
  const toggleNotepadBtn = document.getElementById('toggle-notepad');
  const notepadText = document.getElementById('notepad-text');
  const saveNotesBtn = document.getElementById('save-notes');
  // Load notes from server
  fetch('/notes')
    .then(r => r.json())
    .then(({text}) => { notepadText.value = text || ''; })
    .catch(() => {});
  toggleNotepadBtn.addEventListener('click', () => {
    notepad.classList.toggle('collapsed');
  });
  saveNotesBtn.addEventListener('click', () => {
    fetch('/notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: notepadText.value })
    })
    .then(r => r.json())
    .then(() => showNotification('Notes saved on server'))
    .catch(() => showNotification('Failed to save notes'));
  });

  // The following section reuses much of the original dashboard logic to
  // handle folder/mode selection, duration changes, image selection and
  // reload.  It has been lightly adapted to support dynamically added
  // streams.  The logic is encapsulated in functions that operate on
  // elements with a ``data-stream`` attribute.

  function saveSettings(streamId, payload) {
    fetch(`/settings/${encodeURIComponent(streamId)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
      if (data.status === 'success') {
        showNotification(`Updated settings for ${streamId}`);
        const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
        if (card && data.new_config.selected_image !== undefined) {
          const disp = card.querySelector('.selected-image-display');
          disp.textContent = data.new_config.selected_image || 'None';
        }
      } else {
        console.error(data.error || 'Unknown error updating settings.');
      }
    })
    .catch(err => console.error('Error saving settings:', err));
  }

  function toggleVisibilityForMode(card, mode, streamUrl) {
    const durationDiv = card.querySelector('.duration-container');
    const urlDiv = card.querySelector('.stream-url-container');
    const imagePicker = card.querySelector('.image-picker');
    const ytSettingsDiv = card.querySelector('.yt-settings');
    if (durationDiv) durationDiv.style.display = (mode === 'random') ? '' : 'none';
    if (urlDiv) urlDiv.style.display = (mode === 'livestream') ? '' : 'none';
    if (imagePicker) imagePicker.style.display = (mode === 'specific') ? '' : 'none';
    if (ytSettingsDiv) {
      if (mode === 'livestream' && (streamUrl.includes('youtube.com') || streamUrl.includes('youtu.be'))) {
        ytSettingsDiv.style.display = '';
      } else {
        ytSettingsDiv.style.display = 'none';
      }
    }
  }

  function loadImagesFor(streamId, folder) {
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    const imageGrid = card.querySelector('.image-picker .image-grid');
    if (!imageGrid) return;
    const selectedDisplay = card.querySelector('.selected-image-display');
    const currentSelected = selectedDisplay ? selectedDisplay.textContent.trim() : null;
    imageGrid.innerHTML = 'Loading...';
    fetch(`/images?folder=${encodeURIComponent(folder)}`)
      .then(res => res.json())
      .then(imgs => {
        imageGrid.innerHTML = '';
        imgs.forEach(path => {
          const imgEl = document.createElement('img');
          imgEl.src = `/stream/image/${path}`;
          imgEl.title = path;
          imgEl.classList.add('picker-thumbnail');
          if (currentSelected === path) {
            imgEl.classList.add('selected-thumb');
          }
          imgEl.addEventListener('click', () => {
            saveSettings(streamId, { selected_image: path });
          });
          imageGrid.appendChild(imgEl);
        });
        if (!imgs.length) {
          imageGrid.innerHTML = '(No images found in this folder)';
        }
      })
      .catch(err => {
        console.error('Error fetching images for folder:', err);
        imageGrid.innerHTML = 'Error loading images.';
      });
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.stream-card').forEach(card => {
      const streamId = card.dataset.stream;
      // Folder change
      const folderSelect = card.querySelector('.folder-select');
      if (folderSelect) {
        // Ensure tooltip shows full folder name on hover
        folderSelect.addEventListener('change', e => {
          const folder = e.target.value;
          e.target.title = folder;
          saveSettings(streamId, { folder, selected_image: null });
        });
      }
      // Mode change
      const modeSelect = card.querySelector('.mode-select');
      const urlInput = card.querySelector('.stream-url-input');
      if (modeSelect) {
        modeSelect.addEventListener('change', e => {
          const mode = e.target.value;
          const payload = { mode };
          if (mode === 'random') {
            const durInput = card.querySelector('.duration-input');
            if (durInput) payload.duration = durInput.value;
          }
          if (mode === 'livestream') {
            if (urlInput) payload.stream_url = urlInput.value;
            const ccChk = card.querySelector('.yt-cc-chk');
            const muteChk = card.querySelector('.yt-mute-chk');
            const qualityInput = card.querySelector('.yt-quality-input');
            if (ccChk) payload.yt_cc = ccChk.checked;
            if (muteChk) payload.yt_mute = muteChk.checked;
            if (qualityInput) payload.yt_quality = qualityInput.value;
          }
          saveSettings(streamId, payload);
          toggleVisibilityForMode(card, mode, urlInput ? urlInput.value : '');
        });
      }
      // Duration change
      const durInput = card.querySelector('.duration-input');
      if (durInput) {
        durInput.addEventListener('change', e => {
          saveSettings(streamId, { duration: e.target.value });
        });
      }
      // URL change
      if (urlInput) {
        urlInput.addEventListener('change', e => {
          saveSettings(streamId, { stream_url: e.target.value });
          toggleVisibilityForMode(card, modeSelect.value, e.target.value);
        });
      }
      // YT settings changes
      const ccChk = card.querySelector('.yt-cc-chk');
      const muteChk = card.querySelector('.yt-mute-chk');
      const qualityInput = card.querySelector('.yt-quality-input');
      const includeChk = card.querySelector('.include-global-chk');
      const labelInput = card.querySelector('.label-input');
      if (ccChk) {
        ccChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_cc: e.target.checked });
        });
      }
      if (muteChk) {
        muteChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_mute: e.target.checked });
        });
      }
      if (qualityInput) {
        qualityInput.addEventListener('change', e => {
          saveSettings(streamId, { yt_quality: e.target.value });
        });
      }
      if (includeChk) {
        includeChk.addEventListener('change', e => {
          saveSettings(streamId, { include_in_global: e.target.checked });
        });
      }
      function slugify(s){
        return (s||'').toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,'');
      }
      if (labelInput) {
        labelInput.addEventListener('change', e => {
          saveSettings(streamId, { label: e.target.value });
          // update header text immediately
          const a = card.querySelector('.card-header h2 a.stream-link');
          if (a) {
            a.textContent = e.target.value || streamId;
            const slug = slugify(e.target.value || streamId);
            a.href = '/stream/' + encodeURIComponent(slug);
          }
        });
      }
      // Reload images button
      const reloadBtn = card.querySelector('.reload-images-btn');
      if (reloadBtn) {
        reloadBtn.addEventListener('click', () => {
          const folder = folderSelect ? folderSelect.value : 'all';
          loadImagesFor(streamId, folder);
        });
      }

      toggleVisibilityForMode(card, modeSelect ? modeSelect.value : '', urlInput ? urlInput.value : '');
    });
  });
</script>
</body>
</html>
