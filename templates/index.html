<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EchoMosaic Dashboard</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<header class="top-bar">
  <h1>EchoMosaic</h1>
  <nav>
    <a href="{{ url_for('app_settings') }}">Settings</a>
    <button id="theme-toggle" class="icon-btn" type="button" aria-label="Toggle theme" title="Toggle theme" style="margin-left:.5rem;"></button>
  </nav>
</header>
<div class="container">

  <!-- Group Manager Card -->
  <div class="stream-card" id="group-manager">
    <div class="card-header">
      <h2>Groups</h2>
    </div>
    <div class="group-section">
      <div id="group-tiles" class="group-tiles"></div>
    </div>
  </div>

  <div class="controls">
    <button id="add-stream">Add Stream</button>
    <button id="open-mosaic">View Streams</button>
    <label for="mosaic-layout-select" style="margin-left: .5rem;">Layout</label>
    <select id="mosaic-layout-select">
      <option value="grid" {% if mosaic_settings.layout == 'grid' %}selected{% endif %}>Grid</option>
      <option value="horizontal" {% if mosaic_settings.layout == 'horizontal' %}selected{% endif %}>Horizontal</option>
      <option value="vertical" {% if mosaic_settings.layout == 'vertical' %}selected{% endif %}>Vertical</option>
      <option value="focus" {% if mosaic_settings.layout == 'focus' %}selected{% endif %}>Focus</option>
      <option value="pip" {% if mosaic_settings.layout == 'pip' %}selected{% endif %}>PiP</option>
    </select>
    <label for="mosaic-cols-input" id="mosaic-cols-label" style="display: {% if mosaic_settings.layout == 'grid' %}inline{% else %}none{% endif %};">Cols</label>
    <input id="mosaic-cols-input" type="number" min="1" max="6" value="{{ mosaic_settings.cols }}" style="width: 4.5rem; display: {% if mosaic_settings.layout == 'grid' %}inline-block{% else %}none{% endif %};" />
  </div>

  <div id="dashboard-grid" class="dashboard-grid">
    {# Generate a card for each stream dynamically #}
    {% for stream_id, conf in stream_settings.items() %}
    <div class="stream-card" data-stream="{{ stream_id }}">
      <div class="card-header">
        <div class="title-row">
          <h2><a class="stream-link" href="{{ url_for('render_stream', name=(conf.label if conf.label else stream_id)|slugify) }}" target="_blank">{{ conf.label if conf.label else stream_id|capitalize }}</a></h2>
        </div>
        <div class="card-menu" data-stream="{{ stream_id }}">
          <button class="menu-button" aria-haspopup="true" aria-expanded="false" title="More"><span class="burger"></span></button>
          <div class="menu-dropdown" hidden>
            <button class="menu-rename" data-stream="{{ stream_id }}">Rename</button>
            <button class="menu-remove" data-stream="{{ stream_id }}">Remove</button>
          </div>
        </div>
      </div>

      <div class="form-grid">
        <!-- Mode Selection (moved to top) -->
        <div class="form-row">
          <label for="mode-{{ stream_id }}">Mode</label>
          <select id="mode-{{ stream_id }}" class="mode-select" data-stream="{{ stream_id }}">
            <option value="random" {% if conf.mode == 'random' %} selected {% endif %}>Random</option>
            <option value="specific" {% if conf.mode == 'specific' %} selected {% endif %}>Specific</option>
            <option value="livestream" {% if conf.mode == 'livestream' %} selected {% endif %}>URL / Embed</option>
            <option value="ai" {% if conf.mode == 'ai' %} selected {% endif %}>AI Images</option>
          </select>
        </div>

        <!-- Folder Selection -->
        <div class="form-row folder-row" {% if conf.mode == 'livestream' %} style="display:none;" {% endif %}>
          <label for="folder-{{ stream_id }}">Folder</label>
          <select id="folder-{{ stream_id }}" class="folder-select" data-stream="{{ stream_id }}" title="{{ conf.folder }}">
            {% for f in subfolders %}
              <option value="{{ f }}" title="{{ f }}" {% if conf.folder == f %} selected {% endif %}>{{ f }}</option>
            {% endfor %}
          </select>
        </div>

        

        <!-- Duration + Shuffle (for Random mode) -->
        <div class="form-row duration-container" {% if conf.mode != 'random' %} style="display:none;" {% endif %}>
          <label for="duration-{{ stream_id }}">Duration (sec)</label>
          <div class="inline-controls">
            <input id="duration-{{ stream_id }}" type="number" class="duration-input" data-stream="{{ stream_id }}" value="{{ conf.duration }}" min="1" style="max-width: 110px;">
            <label title="Randomize order each time"><input type="checkbox" class="shuffle-chk" data-stream="{{ stream_id }}" {% if conf.shuffle %} checked {% endif %}> Shuffle</label>
          </div>
        </div>

        <!-- Stream URL -->
        <div class="form-row stream-url-container" {% if conf.mode != 'livestream' %} style="display:none;" {% endif %}>
          <label for="stream-url-{{ stream_id }}">URL</label>
          <div>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap: wrap;">
              <input id="stream-url-{{ stream_id }}" type="text" class="stream-url-input" data-stream="{{ stream_id }}" value="{{ conf.stream_url if conf.stream_url else '' }}" placeholder="https://â€¦">
              <span class="url-type-badge" aria-live="polite"></span>
              <span class="embed-status-badge" aria-live="polite"></span>
            </div>
          </div>
        </div>

        <!-- YT Settings -->
        <div class="form-row yt-settings" data-stream="{{ stream_id }}" style="display:none;">
          <details>
            <summary>YouTube Options</summary>
            <div class="inline-controls" style="margin-top: .4rem;">
              <label title="Closed Captions"><input type="checkbox" class="yt-cc-chk" data-stream="{{ stream_id }}" {% if conf.yt_cc %} checked {% endif %}> CC</label>
              <label title="Start muted"><input type="checkbox" class="yt-mute-chk" data-stream="{{ stream_id }}" {% if conf.yt_mute %} checked {% endif %}> Mute</label>
              <label for="yt-quality-{{ stream_id }}">Quality</label>
              {% set q = (conf.yt_quality or 'auto') %}
              <select id="yt-quality-{{ stream_id }}" class="yt-quality-select" data-stream="{{ stream_id }}">
                {% for opt in ['auto','1080p','720p','480','360p','240p','144p'] %}
                  <option value="{{ opt }}" {% if q|lower == opt|lower %} selected {% endif %}>{{ opt|upper }}</option>
                {% endfor %}
              </select>
            </div>
          </details>
        </div>
        {% set ai = conf.ai_settings or {} %}
        {% set ai_state = conf.ai_state or {} %}
        <div class="ai-summary" data-stream="{{ stream_id }}" {% if conf.mode != 'ai' %} style="display:none;" {% endif %}>
          <div class="ai-summary-grid">
            <div class="ai-summary-item"><span class="ai-summary-label">Model</span><span class="ai-summary-value ai-summary-model">{{ ai.model or 'Auto' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Sampler</span><span class="ai-summary-value ai-summary-sampler">{{ ai.sampler or 'k_euler' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Size</span><span class="ai-summary-value ai-summary-size">{{ ai.width or 512 }}x{{ ai.height or 512 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Steps</span><span class="ai-summary-value ai-summary-steps">{{ ai.steps or 30 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">CFG</span><span class="ai-summary-value ai-summary-cfg">{{ ai.cfg_scale or 7.5 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Images</span><span class="ai-summary-value ai-summary-samples">{{ ai.samples or 1 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">LoRAs</span><span class="ai-summary-value ai-summary-loras">{{ (ai.loras or [])|length }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Post</span><span class="ai-summary-value ai-summary-post">{{ (ai.post_processing or [])|length }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Save</span><span class="ai-summary-value ai-summary-save">{{ 'Yes' if ai.save_output else 'Temp' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Timeout</span><span class="ai-summary-value ai-summary-timeout">{{ ai.timeout if ai.timeout and ai.timeout > 0 else 'No limit' }}</span></div>
          </div>
          <div class="ai-summary-actions">
            <button type="button" class="ai-open-settings" data-stream="{{ stream_id }}">Settings</button>
            <button type="button" class="ai-generate-btn" data-stream="{{ stream_id }}">Queue Images</button>
            <span class="ai-status" data-stream="{{ stream_id }}" data-status="{{ ai_state.status or 'idle' }}">{{ ai_state.status|default('idle')|capitalize }}</span>
          </div>
        </div>
        <div class="ai-modal-backdrop" data-stream="{{ stream_id }}" hidden></div>
        <div class="ai-generator" data-stream="{{ stream_id }}" data-timeout="{{ ai.timeout if ai.timeout else '' }}" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
          <div class="ai-modal-header">
            <h3>AI Image Settings</h3>
            <button type="button" class="ai-close-settings" aria-label="Close">&times;</button>
          </div>
          {% set sampler_options = ['k_euler','k_euler_a','k_dpmpp_2m','k_dpmpp_2m_sde','k_dpmpp_sde','k_lms','k_heun','k_dpm_2','k_dpm_2_a','k_dpm_fast','k_dpm_adaptive','ddim','plms'] %}
          <label for="ai-prompt-{{ stream_id }}">Prompt</label>
          <textarea id="ai-prompt-{{ stream_id }}" class="ai-prompt-input" data-stream="{{ stream_id }}" rows="3" placeholder="Describe the image you want">{{ ai.prompt or '' }}</textarea>
          <label for="ai-negative-{{ stream_id }}">Negative Prompt</label>
          <textarea id="ai-negative-{{ stream_id }}" class="ai-negative-input" data-stream="{{ stream_id }}" rows="2" placeholder="Things to avoid (optional)">{{ ai.negative_prompt or '' }}</textarea>
          <div class="ai-option-grid">
            <div class="ai-option">
              <label for="ai-model-{{ stream_id }}">Model</label>
              <select id="ai-model-{{ stream_id }}" class="ai-model-select" data-stream="{{ stream_id }}">
                {% if ai.model %}
                <option value="{{ ai.model }}" selected>{{ ai.model }}</option>
                {% else %}
                <option value="" selected>Auto-select</option>
                {% endif %}
              </select>
            </div>
            <div class="ai-option">
              <label for="ai-sampler-{{ stream_id }}">Sampler</label>
              {% set current_sampler = ai.sampler or 'k_euler' %}
              {% set sampler_state = namespace(found=false) %}
              <select id="ai-sampler-{{ stream_id }}" class="ai-sampler-select" data-stream="{{ stream_id }}">
                {% for opt in sampler_options %}
                  {% set selected = (current_sampler|lower == opt|lower) %}
                  {% if selected %}{% set sampler_state.found = True %}{% endif %}
                  <option value="{{ opt }}" {% if selected %}selected{% endif %}>{{ opt }}</option>
                {% endfor %}
                {% if current_sampler and not sampler_state.found %}
                  <option value="{{ current_sampler }}" selected>{{ current_sampler }}</option>
                {% endif %}
              </select>
            </div>
            <div class="ai-option">
              <label for="ai-width-{{ stream_id }}">Width</label>
              <input id="ai-width-{{ stream_id }}" type="number" class="ai-width-input" data-stream="{{ stream_id }}" min="64" max="2048" step="64" value="{{ ai.width or 512 }}">
            </div>
            <div class="ai-option">
              <label for="ai-height-{{ stream_id }}">Height</label>
              <input id="ai-height-{{ stream_id }}" type="number" class="ai-height-input" data-stream="{{ stream_id }}" min="64" max="2048" step="64" value="{{ ai.height or 512 }}">
            </div>
            <div class="ai-option">
              <label for="ai-steps-{{ stream_id }}">Steps</label>
              <input id="ai-steps-{{ stream_id }}" type="number" class="ai-steps-input" data-stream="{{ stream_id }}" min="1" max="100" value="{{ ai.steps or 30 }}">
            </div>
            <div class="ai-option">
              <label for="ai-cfg-{{ stream_id }}">CFG</label>
              <input id="ai-cfg-{{ stream_id }}" type="number" class="ai-cfg-input" data-stream="{{ stream_id }}" step="0.5" min="1" max="20" value="{{ ai.cfg_scale or 7.5 }}">
            </div>
            <div class="ai-option">
              <label for="ai-samples-{{ stream_id }}">Images</label>
              <input id="ai-samples-{{ stream_id }}" type="number" class="ai-samples-input" data-stream="{{ stream_id }}" min="1" max="4" value="{{ ai.samples or 1 }}">
            </div>
            <div class="ai-option">
              <label for="ai-seed-{{ stream_id }}">Seed</label>
              <input id="ai-seed-{{ stream_id }}" type="text" class="ai-seed-input" data-stream="{{ stream_id }}" value="{{ ai.seed or 'random' }}" placeholder="random">
            </div>
          </div>
          <details class="ai-advanced-options" data-stream="{{ stream_id }}">
            <summary>Advanced Options</summary>
            <div class="ai-advanced-grid">
              <div class="ai-advanced-group">
                <label class="ai-toggle"><input type="checkbox" class="ai-hires-fix" data-stream="{{ stream_id }}" {% if ai.hires_fix %}checked{% endif %}> Hires Fix</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-karras" data-stream="{{ stream_id }}" {% if ai.karras %}checked{% endif %}> Karras Noise</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-tiling" data-stream="{{ stream_id }}" {% if ai.tiling %}checked{% endif %}> Tiling</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-transparent" data-stream="{{ stream_id }}" {% if ai.transparent %}checked{% endif %}> Transparent BG</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-trusted-workers" data-stream="{{ stream_id }}" {% if ai.trusted_workers %}checked{% endif %}> Trusted Workers</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-validated-backends" data-stream="{{ stream_id }}" {% if ai.validated_backends %}checked{% endif %}> Validated Backends</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-slow-workers" data-stream="{{ stream_id }}" {% if ai.slow_workers %}checked{% endif %}> Allow Slow Workers</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-extra-slow-workers" data-stream="{{ stream_id }}" {% if ai.extra_slow_workers %}checked{% endif %}> Allow Extra Slow</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-disable-batching" data-stream="{{ stream_id }}" {% if ai.disable_batching %}checked{% endif %}> Disable Batching</label>
                <label class="ai-toggle"><input type="checkbox" class="ai-allow-downgrade" data-stream="{{ stream_id }}" {% if ai.allow_downgrade %}checked{% endif %}> Allow Downgrade</label>
              </div>
              <div class="ai-advanced-group">
                <label for="ai-style-{{ stream_id }}">Style Preset</label>
                <input id="ai-style-{{ stream_id }}" type="text" class="ai-style-input" data-stream="{{ stream_id }}" placeholder="Style ID or name" value="{{ ai.style or '' }}">
                <label for="ai-clip-skip-{{ stream_id }}">Clip Skip</label>
                <input id="ai-clip-skip-{{ stream_id }}" type="number" class="ai-clip-skip" data-stream="{{ stream_id }}" min="{{ clip_skip_range[0] }}" max="{{ clip_skip_range[1] }}" step="1" value="{{ ai.clip_skip if ai.clip_skip is not none else '' }}">
                <label for="ai-facefixer-{{ stream_id }}">Face Fix Strength</label>
                <input id="ai-facefixer-{{ stream_id }}" type="number" class="ai-facefixer" data-stream="{{ stream_id }}" min="{{ strength_range[0] }}" max="{{ strength_range[1] }}" step="0.05" value="{{ ai.facefixer_strength if ai.facefixer_strength is not none else '' }}">
                <label for="ai-denoise-{{ stream_id }}">Denoising</label>
                <input id="ai-denoise-{{ stream_id }}" type="number" class="ai-denoise" data-stream="{{ stream_id }}" min="{{ denoise_range[0] }}" max="{{ denoise_range[1] }}" step="0.01" value="{{ ai.denoising_strength if ai.denoising_strength is not none else '' }}">
                <label for="ai-hires-denoise-{{ stream_id }}">Hires Denoise</label>
                <input id="ai-hires-denoise-{{ stream_id }}" type="number" class="ai-hires-denoise" data-stream="{{ stream_id }}" min="{{ denoise_range[0] }}" max="{{ denoise_range[1] }}" step="0.01" value="{{ ai.hires_fix_denoising_strength if ai.hires_fix_denoising_strength is not none else '' }}">
              </div>
            </div>
            <div class="ai-post-processing">
              <div class="section-title">Post Processing</div>
              <div class="post-processing-options">
                {% set selected_post = ai.post_processing or [] %}
                {% for proc in post_processors %}
                  <label><input type="checkbox" class="ai-post-proc" data-stream="{{ stream_id }}" value="{{ proc }}" {% if proc in selected_post %}checked{% endif %}> {{ proc }}</label>
                {% endfor %}
              </div>
            </div>
            <div class="ai-lora-section" data-max="{{ max_loras }}">
              <div class="lora-header">
                <span>LoRAs</span>
                <button type="button" class="ai-add-lora" data-stream="{{ stream_id }}">Add</button>
              </div>
              <div class="ai-lora-search">
                <input type="text" class="ai-lora-search-input" placeholder="Search LoRAs on CivitAI (e.g. 'anime style')">
                <button type="button" class="ai-lora-search-btn" data-stream="{{ stream_id }}">Search</button>
                <a href="https://civitai.com/models?types=LORA&sort=Highest%20Rated" class="ai-lora-browse" target="_blank" rel="noopener">Browse</a>
              </div>
              <div class="ai-lora-results" hidden>
                <div class="ai-lora-results-header"></div>
                <div class="ai-lora-results-list"></div>
              </div>
              <div class="ai-lora-list">
                {% for lora in ai.loras or [] %}
                <div class="ai-lora-row">
                  <input type="text" class="ai-lora-name" placeholder="Name or CivitAI ID" value="{{ lora.name }}">
                  <input type="number" class="ai-lora-model" placeholder="Model" step="0.05" min="-5" max="5" value="{{ lora.model if lora.model is not none else '' }}">
                  <input type="number" class="ai-lora-clip" placeholder="Clip" step="0.05" min="-5" max="5" value="{{ lora.clip if lora.clip is not none else '' }}">
                  <input type="text" class="ai-lora-trigger" placeholder="Trigger (optional)" value="{{ lora.inject_trigger or '' }}">
                  <label class="ai-lora-flag"><input type="checkbox" class="ai-lora-is-version" {% if lora.is_version %}checked{% endif %}> Version ID</label>
                  <button type="button" class="ai-lora-remove">Remove</button>
                </div>
                {% endfor %}
              </div>
              <p class="hint">Up to {{ max_loras }} entries. Strength 1.0 is neutral.</p>
            </div>
          </details>
          <div class="ai-flags">
            <label><input type="checkbox" class="ai-save-output" data-stream="{{ stream_id }}" {% if ai.save_output %}checked{% endif %}> Save to library</label>
            <label><input type="checkbox" class="ai-nsfw" data-stream="{{ stream_id }}" {% if ai.nsfw %}checked{% endif %}> Allow NSFW</label>
            <label><input type="checkbox" class="ai-censor" data-stream="{{ stream_id }}" {% if ai.censor_nsfw %}checked{% endif %}> Censor NSFW</label>
          </div>
          <div class="ai-modal-actions">
            <button type="button" class="ai-generate-btn" data-stream="{{ stream_id }}">Queue Images</button>
            <button type="button" class="ai-close-settings-secondary">Close</button>
          </div>
          <div class="ai-results" data-stream="{{ stream_id }}" data-selected="{{ conf.selected_image or '' }}">
            <div class="ai-generated-grid">
              {% for img in ai_state.images or [] %}
              <div class="ai-generated-item" data-path="{{ img.path }}" data-persisted="{{ 'true' if img.persisted else 'false' }}">
                <img src="/stream/image/{{ img.path }}" alt="Generated image {{ loop.index }}">
                <div class="ai-generated-meta">
                  {% if img.model %}<span class="ai-model-tag">{{ img.model }}</span>{% endif %}
                  {% if img.seed %}<span class="ai-seed-tag">#{{ img.seed }}</span>{% endif %}
                </div>
              </div>
              {% endfor %}
            </div>
            <div class="ai-generated-empty" {% if ai_state.images %}style="display:none;"{% endif %}>No generated images yet.</div>
          </div>
        </div>
      </div>
      <!-- Specific Image Picker -->
      <div class="image-picker" data-stream="{{ stream_id }}" {% if conf.mode != 'specific' %} style="display:none;" {% endif %}>
        <div class="image-picker-header">
          <label>Pick an Image (Folder: {{ conf.folder }})</label>
          <button type="button" class="reload-images-btn" data-stream="{{ stream_id }}">Reload</button>
        </div>
        <div class="image-grid"></div>
      </div>

      <p class="selected-image-row" {% if conf.mode not in ['specific', 'ai'] %} style="display:none;" {% endif %}>
        <strong>Selected Image:</strong>
        <span class="selected-image-display">{{ conf.selected_image if conf.selected_image else "None" }}</span>
      </p>
    </div>
    {% endfor %}
  </div>
</div>

<!-- Notification -->
<div id="notification" class="notification">Settings updated!</div>

<!-- Floating Notes Pad -->
<div id="notepad" class="notepad collapsed">
  <div class="notepad-header">
    <span>Notes</span>
    <button id="toggle-notepad">Toggle</button>
  </div>
  <textarea id="notepad-text"></textarea>
  <button id="save-notes">Save</button>
</div>

<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
  // Theme toggle (sun/moon)
  (function(){
    const root = document.documentElement;
    const btn = document.getElementById('theme-toggle');
    function apply(theme){
      const t = (theme === 'light') ? 'light' : 'dark';
      root.setAttribute('data-theme', t);
      if (btn) btn.textContent = t === 'light' ? 'â˜€ï¸' : 'ðŸŒ™';
    }
    const saved = localStorage.getItem('theme') || 'dark';
    apply(saved);
    if (btn) btn.addEventListener('click', () => {
      const cur = root.getAttribute('data-theme') === 'light' ? 'light' : 'dark';
      const next = cur === 'light' ? 'dark' : 'light';
      apply(next);
      try { localStorage.setItem('theme', next); } catch(e){}
    });
  })();

  const socket = io();
  let openAiCard = null;
  const aiSummaryUpdaters = new WeakMap();

  function openAiSettings(card) {
    if (!card) return;
    const updater = aiSummaryUpdaters.get(card);
    if (updater) updater();
    const aiSection = card.querySelector('.ai-generator');
    if (!aiSection) return;
    const backdrop = card.querySelector('.ai-modal-backdrop');
    if (openAiCard && openAiCard !== card) {
      closeAiSettings(openAiCard);
    }
    card.classList.add('ai-settings-open');
    if (backdrop) backdrop.hidden = false;
    aiSection.setAttribute('aria-hidden', 'false');
    if (typeof aiSection.focus === 'function') {
      try {
        aiSection.focus({ preventScroll: true });
      } catch (err) {
        aiSection.focus();
      }
    }
    openAiCard = card;
    document.body.classList.add('ai-modal-active');
  }

  function closeAiSettings(card) {
    if (!card) return;
    const aiSection = card.querySelector('.ai-generator');
    const backdrop = card.querySelector('.ai-modal-backdrop');
    card.classList.remove('ai-settings-open');
    if (backdrop) backdrop.hidden = true;
    if (aiSection) {
      aiSection.setAttribute('aria-hidden', 'true');
    }
    if (openAiCard === card) {
      openAiCard = null;
    }
    if (!openAiCard) {
      document.body.classList.remove('ai-modal-active');
    }
  }

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && openAiCard) {
      e.preventDefault();
      closeAiSettings(openAiCard);
    }
  });

  const notification = document.getElementById('notification');
  const addStreamBtn = document.getElementById('add-stream');
  const openMosaicBtn = document.getElementById('open-mosaic');
  const mosaicLayoutSel = document.getElementById('mosaic-layout-select');
  const mosaicColsInput = document.getElementById('mosaic-cols-input');
  
  // Group Manager elements
  const groupTiles = document.getElementById('group-tiles');

  // Build a set of taken stream name slugs for client-side validation
  const takenSlugs = {};
  {% for sid, conf in stream_settings.items() %}
  takenSlugs['{{ (conf.label if conf.label else sid)|slugify }}'] = '{{ sid }}';
  {% endfor %}

  function showNotification(msg) {
    notification.textContent = msg;
    notification.classList.add('show');
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }

  // No layout settings for global /stream; it adapts dynamically

  if (openMosaicBtn) {
    openMosaicBtn.addEventListener('click', () => {
      window.open('/stream', '_blank');
    });
  }

  // Mosaic controls
  function updateMosaicControlsVisibility() {
    if (!mosaicLayoutSel || !mosaicColsInput) return;
    const layout = mosaicLayoutSel.value;
    const colsLabel = document.getElementById('mosaic-cols-label');
    const showCols = layout === 'grid';
    mosaicColsInput.style.display = showCols ? 'inline-block' : 'none';
    if (colsLabel) colsLabel.style.display = showCols ? 'inline' : 'none';
  }
  function saveMosaic() {
    if (!mosaicLayoutSel) return;
    const payload = { layout: mosaicLayoutSel.value };
    if (payload.layout === 'grid' && mosaicColsInput) {
      payload.cols = parseInt(mosaicColsInput.value || '2', 10);
    }
    fetch('/mosaic-settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
      .then(r => r.json())
      .then(() => showNotification('Mosaic updated'))
      .catch(() => showNotification('Failed to update mosaic'));
  }
  if (mosaicLayoutSel) {
    mosaicLayoutSel.addEventListener('change', () => { updateMosaicControlsVisibility(); saveMosaic(); });
  }
  if (mosaicColsInput) {
    mosaicColsInput.addEventListener('change', saveMosaic);
  }
  updateMosaicControlsVisibility();

  // Group manager logic
  function makeEl(tag, attrs = {}, children = []) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v]) => { if (k==='class') e.className=v; else if (k==='style') e.style.cssText=v; else e.setAttribute(k,v); });
    children.forEach(c => e.appendChild(typeof c==='string' ? document.createTextNode(c) : c));
    return e;
  }

  // Simple client-side URL type detection so users know what will embed
  function detectUrlType(url) {
    if (!url) return '';
    const u = (url||'').toLowerCase();
    if (u.includes('youtube.com') || u.includes('youtu.be/')) return 'YouTube';
    if (u.includes('twitch.tv/')) return 'Twitch';
    if (u.endsWith('.m3u8') || u.endsWith('.mpd')) return 'HLS';
    if (u.startsWith('http://') || u.startsWith('https://')) return 'Website';
    return '';
  }
  // Persist expanded/collapsed tile state
  function getOpenSet() {
    try { return new Set(JSON.parse(localStorage.getItem('gmOpen') || '[]')); } catch { return new Set(); }
  }
  function setOpenSet(s) { try { localStorage.setItem('gmOpen', JSON.stringify(Array.from(s))); } catch {} }
  function markOpen(name, open) {
    if (!name) return; // only persist named groups
    const s = getOpenSet();
    if (open) s.add(name); else s.delete(name);
    setOpenSet(s);
  }
  let gmOpenSet = new Set();
  let gmCurrentGroups = {};
  function loadOpenSet() {
    try { gmOpenSet = new Set(JSON.parse(localStorage.getItem('gmOpen') || '[]')); } catch (e) { gmOpenSet = new Set(); }
  }
  function persistOpenSet() {
    try { localStorage.setItem('gmOpen', JSON.stringify(Array.from(gmOpenSet))); } catch (e) {}
  }
  function markOpen(name, open) {
    if (!name) return;
    if (open) gmOpenSet.add(name); else gmOpenSet.delete(name);
    persistOpenSet();
  }
  function isOpen(name) { return name && gmOpenSet.has(name); }

  async function loadGroupsUI() {
    try {
      loadOpenSet();
      const [streamsMeta, groupsData] = await Promise.all([
        fetch('/streams_meta').then(r=>r.json()),
        fetch('/groups').then(r=>r.json())
      ]);
      const groups = groupsData || {};
      gmCurrentGroups = groups;
      // Build tiles
      if (groupTiles) {
        groupTiles.innerHTML = '';
        // Add tile
        const addTile = makeEl('div', {class:'group-tile add'}, [
          makeEl('div', {class:'tile-header'}, ['+ New Group'])
        ]);
        addTile.addEventListener('click', () => {
          const tile = createGroupTile(streamsMeta, groups, null);
          groupTiles.prepend(tile);
          // open editor immediately
          const body = tile.querySelector('.tile-body');
          if (body) body.hidden = false;
          tile.classList.add('expanded');
          const nameInput = tile.querySelector('.tile-name');
          if (nameInput) nameInput.focus();
        });
        groupTiles.appendChild(addTile);

        // Existing group tiles
        Object.keys(groups).forEach(name => {
          groupTiles.appendChild(createGroupTile(streamsMeta, groups, name));
        });
      }
    } catch (e) { console.error('Failed to load groups UI', e); }
  }
  function selectedIds(container) {
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(c=>c.value);
  }
  function createGroupTile(streamsMeta, groups, name) {
    const gdata = name ? (groups[name]||[]) : [];
    const initial = Array.isArray(gdata) ? gdata.slice() : ((gdata?.streams || []).slice());
    const order = Array.isArray(initial) ? initial.slice() : [];
    const members = new Set(order);
    const gLayout = Array.isArray(gdata) ? {} : (gdata?.layout || {});
    const isNew = !name;
    const tile = makeEl('div', {class:'group-tile'}, []);
    const header = makeEl('div', {class:'tile-header'}, []);
    const title = makeEl('span', {class:'tile-title'}, [name || 'New Group']);
    const actions = makeEl('div', {class:'tile-actions'}, []);
    const open = name ? makeEl('a', {href:`/stream/group/${encodeURIComponent(name)}`, target:'_blank'}, ['Open']) : null;
    const edit = makeEl('button', {class:'tile-edit'}, ['Edit']);
    const del = name ? makeEl('button', {class:'tile-del'}, ['Delete']) : null;
    if (open) actions.appendChild(open);
    actions.appendChild(edit);
    if (del) actions.appendChild(del);
    header.appendChild(title);
    header.appendChild(actions);
    tile.appendChild(header);
    const body = makeEl('div', {class:'tile-body', hidden: !isOpen(name)}, []);
    if (isOpen(name)) tile.classList.add('expanded');
    const nameRow = makeEl('div', {class:'tile-row'}, [
      makeEl('label', {}, ['Name: ', makeEl('input', {type:'text', class:'tile-name', value: name || ''}, [])])
    ]);
    body.appendChild(nameRow);
    // Layout selection + visual gallery
    const layoutRow = makeEl('div', {class:'tile-row'}, []);
    const layoutSelect = makeEl('select', {class:'tile-layout'}, []);
    ['grid','focus','pip'].forEach(opt => {
      const o = makeEl('option', {value:opt}, [opt.charAt(0).toUpperCase()+opt.slice(1)]);
      layoutSelect.appendChild(o);
    });
    layoutRow.appendChild(makeEl('label', {}, ['Layout: ', layoutSelect]));
    const colsInput = makeEl('input', {type:'number', min:'1', max:'8', class:'tile-cols', value: gLayout.cols || 2}, []);
    const colsWrap = makeEl('span', {class:'tile-cols-wrap'}, [' Cols: ', colsInput]);
    layoutRow.appendChild(colsWrap);
    const rowsInput = makeEl('input', {type:'number', min:'1', max:'8', class:'tile-rows', value: gLayout.rows || 2}, []);
    const rowsWrap = makeEl('span', {class:'tile-rows-wrap'}, [' Rows: ', rowsInput]);
    layoutRow.appendChild(rowsWrap);
    // Focus options
    const focusWrap = makeEl('div', {class:'tile-pip-wrap', style:'display:none;'}, []);
    const focusMode = makeEl('select', {class:'tile-focus-mode'}, []);
    ['1-2','1-3','1-5'].forEach(v => focusMode.appendChild(makeEl('option', {value:v}, [v.replace('-', ' + ')])));
    const focusPos = makeEl('select', {class:'tile-focus-pos'}, []);
    const focusMain = makeEl('select', {class:'tile-focus-main'}, []);
    const fRow1 = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Focus: ']), focusMode ]);
    const fRow2 = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Placement: ']), focusPos ]);
    const fRow3 = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Main: ']), focusMain ]);
    focusWrap.appendChild(fRow1); focusWrap.appendChild(fRow2); focusWrap.appendChild(fRow3);
    layoutRow.appendChild(focusWrap);
    // PIP options
    const pipWrap = makeEl('div', {class:'tile-pip-wrap', style:'display:none;'}, []);
    const pipMain = makeEl('select', {class:'tile-pip-main'}, []);
    const pipPip = makeEl('select', {class:'tile-pip-pip'}, []);
    const pipCorner = makeEl('select', {class:'tile-pip-corner'}, []);
    ['top-left','top-right','bottom-left','bottom-right'].forEach(c => pipCorner.appendChild(makeEl('option', {value:c}, [c])));
    const pipSize = makeEl('input', {type:'number', min:'10', max:'50', class:'tile-pip-size', value: gLayout.pip_size || 25}, []);
    const rowMain = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Main: ']), pipMain ]);
    const rowPip = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['PIP: ']), pipPip ]);
    const rowCorner = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Corner: ']), pipCorner ]);
    const rowSize = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Size: ']), pipSize ]);
    pipWrap.appendChild(rowMain);
    pipWrap.appendChild(rowPip);
    pipWrap.appendChild(rowCorner);
    pipWrap.appendChild(rowSize);
    layoutRow.appendChild(pipWrap);
    body.appendChild(layoutRow);

    // Visual layout gallery
    const gallery = makeEl('div', {class:'layout-gallery'}, []);
    function buildGridPreview(rows, cols) {
      const p = makeEl('div', {class:'layout-preview'}, []);
      p.style.display = 'grid';
      p.style.gridTemplateColumns = `repeat(${Math.max(1, cols)}, 1fr)`;
      p.style.gridTemplateRows = `repeat(${Math.max(1, rows)}, 1fr)`;
      const n = Math.max(rows*cols, 4);
      for (let i=0;i<n;i++) p.appendChild(makeEl('div', {class:'cell'}, []));
      return p;
    }
    function buildFocusPreview(mode, pos) {
      // produce a small grid preview based on mode/pos
      if (mode === '1-2') {
        const p = makeEl('div', {class:'layout-preview'}, []);
        p.style.display = 'grid'; p.style.gridTemplateColumns='repeat(2,1fr)'; p.style.gridTemplateRows='repeat(2,1fr)';
        const order = (pos==='right') ? ['a','main','b','main'] : ['main','a','main','b'];
        order.forEach(()=>p.appendChild(makeEl('div',{class:'cell'},[])));
        // tint main cells
        Array.from(p.children).forEach((c,i)=>{ if (order[i]==='main') c.style.background='#262626'; });
        return p;
      }
      if (mode === '1-3') {
        const p = makeEl('div', {class:'layout-preview'}, []);
        p.style.display='grid'; p.style.gridTemplateColumns='repeat(3,1fr)'; p.style.gridTemplateRows='repeat(2,1fr)';
        const top = (pos==='top');
        const order = top ? ['m','m','m','a','b','c'] : ['a','b','c','m','m','m'];
        order.forEach(()=>p.appendChild(makeEl('div',{class:'cell'},[])));
        Array.from(p.children).forEach((c,i)=>{ if (order[i]==='m') c.style.background='#262626'; });
        return p;
      }
      // 1-5 default
      const p = makeEl('div', {class:'layout-preview'}, []);
      p.style.display='grid'; p.style.gridTemplateColumns='repeat(3,1fr)'; p.style.gridTemplateRows='repeat(3,1fr)';
      let mat;
      switch(pos){
        case 'top-left': mat=[[1,1,0],[1,1,0],[0,0,0]]; break;
        case 'top-right': mat=[[0,1,1],[0,1,1],[0,0,0]]; break;
        case 'bottom-left': mat=[[0,0,0],[1,1,0],[1,1,0]]; break;
        default: mat=[[0,0,0],[0,1,1],[0,1,1]]; // bottom-right
      }
      for (let r=0;r<3;r++) for (let c=0;c<3;c++) {
        const cell = makeEl('div',{class:'cell'},[]);
        if (mat[r][c]===1) cell.style.background='#262626';
        p.appendChild(cell);
      }
      return p;
    }
    function buildPipPreview() {
      const p = makeEl('div', {class:'layout-preview'}, []);
      const main = makeEl('div', {class:'cell'}, []); main.style.height = '100%'; main.style.width='100%';
      main.style.background = '#1d1d1d';
      const pip = makeEl('div', {class:'cell'}, []);
      pip.style.position='absolute'; pip.style.width='35%'; pip.style.height='35%'; pip.style.right='6%'; pip.style.bottom='6%'; pip.style.background='#262626';
      p.appendChild(main); p.appendChild(pip);
      return p;
    }
    function addOption(kind, label, onPick, builder) {
      const opt = makeEl('div', {class:'layout-option', 'data-kind': kind}, []);
      const preview = builder ? builder() : makeEl('div', {class:'layout-preview'}, []);
      opt.appendChild(preview);
      opt.appendChild(makeEl('span', {class:'caption'}, [label]));
      opt.addEventListener('click', () => { onPick(); setActive(kind); });
      gallery.appendChild(opt);
      return opt;
    }
    function setActive(kind) {
      gallery.querySelectorAll('.layout-option').forEach(o => o.classList.toggle('active', o.dataset.kind===kind));
    }
    const gridOpt = addOption('grid', 'Grid', () => { layoutSelect.value='grid'; updateLayoutVisibility(); }, () => buildGridPreview(parseInt(rowsInput.value||'2',10), parseInt(colsInput.value||'2',10)));
    const focusOpt = addOption('focus', 'Focus', () => { layoutSelect.value='focus'; updateLayoutVisibility(); }, () => buildFocusPreview(focusMode.value||'1-5', focusPos.value||'bottom-right'));
    const pipOpt = addOption('pip', 'PiP', () => { layoutSelect.value='pip'; updateLayoutVisibility(); }, () => buildPipPreview());
    body.appendChild(gallery);
    function syncActiveFromInputs() {
      const v = layoutSelect.value;
      if (v==='grid') setActive('grid'); else setActive(v);
      // update grid preview on change
      const oldPrev = gridOpt.querySelector('.layout-preview');
      const newPrev = buildGridPreview(parseInt(rowsInput.value||'2',10), parseInt(colsInput.value||'2',10));
      gridOpt.replaceChild(newPrev, oldPrev);
      // update focus preview on change
      const oldF = focusOpt.querySelector('.layout-preview');
      const newF = buildFocusPreview(focusMode.value||'1-5', focusPos.value||'bottom-right');
      focusOpt.replaceChild(newF, oldF);
      refreshChips();
    }
    layoutSelect.addEventListener('change', syncActiveFromInputs);
    colsInput.addEventListener('change', syncActiveFromInputs);
    rowsInput.addEventListener('change', syncActiveFromInputs);
    focusMode.addEventListener('change', () => { updateLayoutVisibility(); syncActiveFromInputs(); refreshFocusPosOptions(); });
    focusPos.addEventListener('change', syncActiveFromInputs);

    function refreshFocusPosOptions() {
      // update placement options according to mode
      const mode = focusMode.value;
      focusPos.innerHTML = '';
      let opts = [];
      if (mode === '1-2') opts = ['left','right'];
      else if (mode === '1-3') opts = ['top','bottom'];
      else opts = ['top-left','top-right','bottom-left','bottom-right'];
      opts.forEach(v => focusPos.appendChild(makeEl('option',{value:v},[v.replace('-', ' ')])));
      // select from gLayout or defaults
      const desired = gLayout.focus_pos || opts[opts.length-1];
      Array.from(focusPos.options).forEach(o => o.selected = (o.value===desired));
    }
    // Bulk row (Add all / Remove all) above the combo
    const bulkRow = makeEl('div', {class:'tile-row tile-bulk-row'}, []);
    const addAllBtn = makeEl('button', {class:'tile-addall-btn', type:'button'}, ['Add all']);
    const removeAllBtn = makeEl('button', {class:'tile-removeall-btn', type:'button'}, ['Remove all']);
    bulkRow.appendChild(addAllBtn);
    bulkRow.appendChild(removeAllBtn);
    body.appendChild(bulkRow);
    // Add row with combined search/select + Add
    const addRow = makeEl('div', {class:'tile-row tile-add-row'}, []);
    const dlId = `dl-${Math.random().toString(36).slice(2)}`;
    const combo = makeEl('input', {type:'text', class:'tile-combo', placeholder:'Search or selectâ€¦', list: dlId}, []);
    const datalist = makeEl('datalist', {id: dlId}, []);
    const addBtn = makeEl('button', {class:'tile-add-btn', type:'button'}, ['Add']);
    addRow.appendChild(combo);
    addRow.appendChild(addBtn);
    body.appendChild(addRow);
    body.appendChild(datalist);
    // Chips container for current members
    const chips = makeEl('div', {class:'member-chips'}, []);
    body.appendChild(chips);
    // helpers to refresh UI
    function labelOf(id) { return (streamsMeta[id]?.label || id) + ''; }
    function candidates(query) {
      const q = (query||'').toLowerCase();
      return Object.keys(streamsMeta)
        .filter(id => !members.has(id))
        .filter(id => labelOf(id).toLowerCase().includes(q))
        .sort((a,b) => labelOf(a).localeCompare(labelOf(b)));
    }
    function refreshTitleCount() {
      const count = members.size;
      title.textContent = (tile.querySelector('.tile-name')?.value?.trim() || name || 'New Group') + ` (${count})`;
    }
    function refreshPipSelects() {
      const mem = order.slice();
      let mainSel = gLayout.pip_main && members.has(gLayout.pip_main) ? gLayout.pip_main : (mem[0] || '');
      let pipSel = gLayout.pip_pip && members.has(gLayout.pip_pip) ? gLayout.pip_pip : (mem.find(x=>x!==mainSel) || '');
      // ensure different
      if (pipSel === mainSel) pipSel = mem.find(x=>x!==mainSel) || '';
      // fill main
      pipMain.innerHTML = '';
      mem.forEach(id => {
        const o = makeEl('option', {value:id}, [labelOf(id)]);
        if (id === mainSel) o.selected = true;
        // prevent selecting pip in main as well
        if (id === pipSel) o.disabled = true;
        pipMain.appendChild(o);
      });
      // fill pip (disable main selection)
      pipPip.innerHTML = '';
      mem.forEach(id => {
        const o = makeEl('option', {value:id}, [labelOf(id)]);
        if (id === pipSel) o.selected = true;
        if (id === mainSel) o.disabled = true;
        pipPip.appendChild(o);
      });
      // corner and size
      Array.from(pipCorner.options).forEach(opt => opt.selected = (opt.value === (gLayout.pip_corner || 'bottom-right')));
      pipSize.value = gLayout.pip_size || 25;
    }
    function refreshFocusMainOptions() {
      const mem = Array.from(members);
      focusMain.innerHTML = '';
      mem.forEach(id => {
        const o = makeEl('option', {value:id}, [labelOf(id)]);
        focusMain.appendChild(o);
      });
      const desired = gLayout.focus_main && members.has(gLayout.focus_main) ? gLayout.focus_main : (mem[0] || '');
      Array.from(focusMain.options).forEach(o => o.selected = (o.value===desired));
    }
    function updateLayoutVisibility() {
      const v = layoutSelect.value;
      colsWrap.style.display = (v==='grid') ? '' : 'none';
      rowsWrap.style.display = (v==='grid') ? '' : 'none';
      focusWrap.style.display = (v==='focus') ? '' : 'none';
      pipWrap.style.display = (v==='pip') ? '' : 'none';
      if (v==='pip') refreshPipSelects();
      refreshChips();
    }
    function refreshDatalist() {
      datalist.innerHTML = '';
      candidates(combo.value).forEach(id => {
        datalist.appendChild(makeEl('option', {value: labelOf(id)}, []));
      });
    }
    function capacityForLayout() {
      const v = layoutSelect.value;
      if (v==='grid') {
        const r = parseInt(rowsInput.value||'');
        const c = parseInt(colsInput.value||'');
        if (Number.isFinite(r) && Number.isFinite(c) && r>0 && c>0) return r*c;
        return Infinity;
      }
      if (v==='focus') {
        const m = (focusMode.value||'1-5');
        if (m==='1-2') return 3; if (m==='1-3') return 4; return 6;
      }
      if (v==='pip') return 2;
      return Infinity;
    }
    let draggingId = null;
    function refreshChips() {
      chips.innerHTML = '';
      const list = makeEl('ul', {class:'member-list'}, []);
      const cap = capacityForLayout();
      order.forEach((id, idx) => {
        const li = makeEl('li', {class:'member-item' + (idx >= cap ? ' overflow' : '')}, []);
        li.setAttribute('draggable', 'true');
        li.dataset.id = id;
        const nameSpan = makeEl('span', {class:'member-name'}, [labelOf(id)]);
        const rm = makeEl('button', {class:'member-remove', title:'Remove'}, ['Remove']);
        rm.addEventListener('click', () => {
          members.delete(id);
          const i = order.indexOf(id); if (i>=0) order.splice(i,1);
          refreshDatalist();
          refreshChips();
          refreshPipSelects();
          refreshFocusMainOptions();
        });
        li.addEventListener('dragstart', (e) => {
          draggingId = id;
          try { e.dataTransfer.setData('text/plain', id); } catch {}
          e.dataTransfer.effectAllowed = 'move';
        });
        li.addEventListener('dragover', (e) => {
          e.preventDefault();
          const rect = li.getBoundingClientRect();
          const before = (e.clientY - rect.top) < rect.height/2;
          li.classList.toggle('drag-over-top', before);
          li.classList.toggle('drag-over-bottom', !before);
        });
        li.addEventListener('dragleave', () => {
          li.classList.remove('drag-over-top','drag-over-bottom');
        });
        li.addEventListener('drop', (e) => {
          e.preventDefault();
          li.classList.remove('drag-over-top','drag-over-bottom');
          const fromId = draggingId; draggingId = null;
          if (!fromId || fromId === id) return;
          const fromIdx = order.indexOf(fromId);
          const targetIdx = order.indexOf(id);
          if (fromIdx < 0 || targetIdx < 0) return;
          const rect = li.getBoundingClientRect();
          const before = (e.clientY - rect.top) < rect.height/2;
          // Remove from old spot
          order.splice(fromIdx, 1);
          // Recompute target index after removal
          let insertAt = order.indexOf(id);
          insertAt = before ? insertAt : insertAt + 1;
          order.splice(insertAt, 0, fromId);
          refreshChips();
          refreshPipSelects();
          refreshFocusMainOptions();
        });
        li.addEventListener('dragend', () => {
          const els = list.querySelectorAll('.drag-over-top,.drag-over-bottom');
          els.forEach(el => el.classList.remove('drag-over-top','drag-over-bottom'));
          draggingId = null;
        });
        li.appendChild(nameSpan);
        li.appendChild(rm);
        list.appendChild(li);
      });
      chips.appendChild(list);
      refreshTitleCount();
    }
    // init layout controls
    layoutSelect.value = gLayout.layout || 'grid';
    // initialize focus controls from gLayout
    Array.from(focusMode.options).forEach(o => o.selected = (o.value === (gLayout.focus_mode || '1-5')));
    refreshFocusPosOptions();
    refreshFocusMainOptions();
    updateLayoutVisibility();
    refreshDatalist();
    refreshChips();
    combo.addEventListener('input', refreshDatalist);
    combo.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addBtn.click(); } });
    function resolveSingleSelection() {
      const q = combo.value.trim();
      if (!q) return null;
      // try exact label match first
      const byLabel = candidates('').find(id => labelOf(id).toLowerCase() === q.toLowerCase());
      if (byLabel && !members.has(byLabel)) return byLabel;
      // fallback: if only one candidate matches substring, use it
      const cands = candidates(q);
      if (cands.length === 1) return cands[0];
      // also allow exact id match
      if (!members.has(q) && streamsMeta[q]) return q;
      return null;
    }
    addBtn.addEventListener('click', () => {
      const id = resolveSingleSelection();
      if (!id) return;
      members.add(id); order.push(id);
      combo.value = '';
      refreshDatalist();
      refreshChips();
      refreshFocusMainOptions();
      updateLayoutVisibility();
    });
    addAllBtn.addEventListener('click', () => {
      const q = combo.value;
      candidates(q).forEach(id => { members.add(id); order.push(id); });
      combo.value = '';
      refreshDatalist();
      refreshChips();
      refreshFocusMainOptions();
      updateLayoutVisibility();
    });
    removeAllBtn.addEventListener('click', () => {
      members.clear(); order.splice(0, order.length);
      combo.value = '';
      refreshDatalist();
      refreshChips();
      refreshFocusMainOptions();
      updateLayoutVisibility();
    });
    layoutSelect.addEventListener('change', updateLayoutVisibility);
    pipMain.addEventListener('change', () => { gLayout.pip_main = pipMain.value; if (gLayout.pip_main === gLayout.pip_pip) { gLayout.pip_pip = Array.from(members).find(x=>x!==gLayout.pip_main) || ''; } refreshPipSelects(); });
    pipPip.addEventListener('change', () => { gLayout.pip_pip = pipPip.value; if (gLayout.pip_main === gLayout.pip_pip) { gLayout.pip_main = Array.from(members).find(x=>x!==gLayout.pip_pip) || ''; } refreshPipSelects(); });
    const btns = makeEl('div', {class:'tile-buttons'}, []);
    const save = makeEl('button', {class:'tile-save'}, ['Save']);
    const cancel = makeEl('button', {class:'tile-cancel'}, ['Cancel']);
    btns.appendChild(save);
    btns.appendChild(cancel);
    body.appendChild(btns);
    tile.appendChild(body);

    // interactions
    edit.addEventListener('click', () => {
      body.hidden = !body.hidden;
      tile.classList.toggle('expanded', !body.hidden);
      markOpen(name, !body.hidden);
    });
    if (del) {
      del.addEventListener('click', async () => {
        if (!confirm(`Delete group ${name}?`)) return;
        await fetch(`/groups/${encodeURIComponent(name)}`, {method:'DELETE'});
        markOpen(name, false);
        tile.classList.remove('expanded');
        loadGroupsUI();
      });
    }
    save.addEventListener('click', async () => {
      const nameVal = (tile.querySelector('.tile-name').value || '').trim();
      if (!nameVal) { alert('Enter a group name'); return; }
      // preemptive duplicate check (case-insensitive), allow same-name when editing
      const wanted = nameVal.toLowerCase();
      if (wanted === 'default') { showNotification("'default' is a reserved group name"); return; }
      const exists = Object.keys(gmCurrentGroups || {}).some(g => g.toLowerCase() === wanted && g !== (name || ''));
      if (exists) { showNotification('A group with this name already exists'); return; }
      const ids = order.slice();
      // Build layout payload
      const layoutVal = layoutSelect.value;
      const payloadLayout = { layout: layoutVal };
      if (layoutVal==='grid') { payloadLayout.cols = parseInt(colsInput.value||'2',10); payloadLayout.rows = parseInt(rowsInput.value||'2',10); }
      if (layoutVal==='focus') { payloadLayout.focus_mode = focusMode.value; payloadLayout.focus_pos = focusPos.value; payloadLayout.focus_main = focusMain.value || null; }
      if (layoutVal==='pip') {
        payloadLayout.pip_main = pipMain.value || null;
        payloadLayout.pip_pip = pipPip.value || null;
        payloadLayout.pip_corner = pipCorner.value || 'bottom-right';
        payloadLayout.pip_size = parseInt(pipSize.value||'25',10);
      }
      const res = await fetch('/groups', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: nameVal, streams: ids, layout: payloadLayout})});
      if (res.ok) {
        showNotification('Saved group');
        // If renamed, delete the old group name
        if (name && nameVal !== name) {
          try { await fetch(`/groups/${encodeURIComponent(name)}`, {method:'DELETE'}); } catch (e) {}
        }
        // Collapse after save (and handle rename)
        if (name && nameVal !== name) markOpen(name, false);
        markOpen(nameVal, false);
        tile.classList.remove('expanded');
        loadGroupsUI();
      } else {
        let msg = 'Failed to save group';
        try { const j = await res.json(); if (j && j.error) msg = j.error; } catch (e) {}
        alert(msg);
      }
    });
    cancel.addEventListener('click', () => { body.hidden = true; tile.classList.remove('expanded'); });
    // Keep count/title in sync with name edits
    const nameInputEl = nameRow.querySelector('.tile-name');
    if (nameInputEl) nameInputEl.addEventListener('input', () => { refreshTitleCount(); });
    return tile;
  }

  // initial load
  document.addEventListener('DOMContentLoaded', loadGroupsUI);

  

  // Add a new stream by posting to /streams
  addStreamBtn.addEventListener('click', () => {
    fetch('/streams', {method:'POST'})
      .then(res => res.json())
      .then(data => {
        if (data.stream_id) {
          location.reload();
        }
      });
  });

  // Card menu interactions: close on outside click and handle remove
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.card-menu')) {
      document.querySelectorAll('.card-menu .menu-dropdown').forEach(dd => dd.hidden = true);
    }
    if (e.target.classList.contains('menu-remove')) {
      const id = e.target.dataset.stream;
      if (confirm('Delete ' + id + '?')) {
        fetch('/streams/' + encodeURIComponent(id), {method:'DELETE'})
          .then(res => res.json())
          .then(data => {
            if (data.status === 'deleted') {
              location.reload();
            }
          });
      }
    }
  });

  // Socket.IO listener for layout updates if needed in future
  socket.on('streams_changed', (data) => {
    // This could be used to update the UI without reload.
    console.log('Streams changed:', data);
  });

  socket.on('ai_job_update', (data) => {
    const streamId = data && data.stream_id;
    if (!streamId) return;
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    if (data.job) {
      aiActiveJobs.set(streamId, data.job);
      const status = (data.job.status || '').toLowerCase();
      if (['completed', 'error', 'timeout'].includes(status)) {
        aiActiveJobs.delete(streamId);
      }
    }
    if (data.state) {
      if (Array.isArray(data.state.images)) {
        renderAiResults(card, data.state.images);
      }
      renderAiStatus(card, data.state, data.job || aiActiveJobs.get(streamId) || null);
    } else if (data.job) {
      renderAiStatus(card, {}, data.job);
    }
  });

  socket.on('refresh', (data) => {
    const streamId = data && data.stream_id;
    const conf = data && data.config;
    if (!streamId || !conf) return;
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    if (conf.selected_image !== undefined) {
      const display = card.querySelector('.selected-image-display');
      if (display) display.textContent = conf.selected_image || 'None';
      const resultsEl = card.querySelector('.ai-results');
      if (resultsEl) {
        highlightAiSelection(resultsEl, conf.selected_image || '');
      }
    }
    if (conf.ai_state) {
      if (Array.isArray(conf.ai_state.images)) {
        renderAiResults(card, conf.ai_state.images);
      }
      renderAiStatus(card, conf.ai_state, aiActiveJobs.get(streamId) || null);
    }
  });

  // Notepad behaviour
  const notepad = document.getElementById('notepad');
  const toggleNotepadBtn = document.getElementById('toggle-notepad');
  const notepadText = document.getElementById('notepad-text');
  const saveNotesBtn = document.getElementById('save-notes');
  // Load notes from server
  fetch('/notes')
    .then(r => r.json())
    .then(({text}) => { notepadText.value = text || ''; })
    .catch(() => {});
  toggleNotepadBtn.addEventListener('click', () => {
    notepad.classList.toggle('collapsed');
  });
  saveNotesBtn.addEventListener('click', () => {
    fetch('/notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: notepadText.value })
    })
    .then(r => r.json())
    .then(() => showNotification('Notes saved on server'))
    .catch(() => showNotification('Failed to save notes'));
  });

  // The following section reuses much of the original dashboard logic to
  // handle folder/mode selection, duration changes, image selection and
  // reload.  It has been lightly adapted to support dynamically added
  // streams.  The logic is encapsulated in functions that operate on
  // elements with a ``data-stream`` attribute.

  const aiModelCache = { models: null, promise: null };
  const aiActiveJobs = new Map();

  async function fetchAiModels() {
    if (aiModelCache.models) {
      return aiModelCache.models;
    }
    if (!aiModelCache.promise) {
      aiModelCache.promise = fetch('/ai/models')
        .then(res => {
          if (!res.ok) {
            throw new Error(HTTP );
          }
          return res.json();
        })
        .then(data => Array.isArray(data.models) ? data.models : [])
        .catch(err => {
          console.error('Failed to fetch Stable Horde models', err);
          return [];
        })
        .finally(() => {
          aiModelCache.promise = null;
        });
      aiModelCache.promise.then(models => {
        aiModelCache.models = models;
      });
    }
    return aiModelCache.promise;
  }

  function highlightAiSelection(resultsEl, selectedPath) {
    if (!resultsEl) return;
    const target = selectedPath || '';
    resultsEl.dataset.selected = target;
    resultsEl.querySelectorAll('.ai-generated-item').forEach(item => {
      if (!item.dataset.path) return;
      if (item.dataset.path === target) {
        item.classList.add('is-selected');
      } else {
        item.classList.remove('is-selected');
      }
    });
  }

  function renderAiResults(card, images) {
    const resultsEl = card.querySelector('.ai-results');
    const grid = card.querySelector('.ai-generated-grid');
    const empty = card.querySelector('.ai-generated-empty');
    if (!resultsEl || !grid || !empty) return;
    grid.innerHTML = '';
    const list = Array.isArray(images) ? images : [];
    if (!list.length) {
      empty.style.display = '';
      highlightAiSelection(resultsEl, resultsEl.dataset.selected || '');
      return;
    }
    empty.style.display = 'none';
    list.forEach(img => {
      if (!img || !img.path) return;
      const item = document.createElement('div');
      item.className = 'ai-generated-item';
      item.dataset.path = img.path;
      item.dataset.persisted = img.persisted ? 'true' : 'false';
      const imageEl = document.createElement('img');
      imageEl.src = `/stream/image/${img.path}`;
      imageEl.alt = (`Generated image ${img.seed || ''}`).trim();
      item.appendChild(imageEl);
      const meta = document.createElement('div');
      meta.className = 'ai-generated-meta';
      if (img.model) {
        const modelTag = document.createElement('span');
        modelTag.className = 'ai-model-tag';
        modelTag.textContent = img.model;
        meta.appendChild(modelTag);
      }
      if (img.seed) {
        const seedTag = document.createElement('span');
        seedTag.className = 'ai-seed-tag';
        seedTag.textContent = `#${img.seed}`;
        meta.appendChild(seedTag);
      }
      item.appendChild(meta);
      grid.appendChild(item);
    });
    highlightAiSelection(resultsEl, resultsEl.dataset.selected || '');
  }

  function renderAiStatus(card, state, job) {
    const statusEl = card.querySelector('.ai-status');
    if (!statusEl) return;
    const info = state || {};
    const jobInfo = job || {};
    const status = (jobInfo.status || info.status || 'idle').toLowerCase();
    let label = status.charAt(0).toUpperCase() + status.slice(1);
    const queuePos = jobInfo.queue_position ?? info.queue_position;
    if (queuePos !== undefined && queuePos !== null) {
      label += ` (queue ${queuePos})`;
    }
    const note = jobInfo.message || info.message;
    if (note && status === 'error') {
      label += ` - ${note}`;
    }
    statusEl.dataset.status = status;
    statusEl.textContent = label;
    card.querySelectorAll('.ai-generate-btn').forEach(btn => {
      btn.disabled = ['queued', 'accepted', 'running'].includes(status);
    });
  }

  function gatherPostProcessing(card) {
    const selected = [];
    card.querySelectorAll('.ai-post-proc').forEach(chk => {
      if (chk.checked && chk.value) {
        selected.push(chk.value);
      }
    });
    return selected;
  }

  function gatherLoras(card) {
    const rows = card.querySelectorAll('.ai-lora-row');
    const result = [];
    rows.forEach(row => {
      const nameInput = row.querySelector('.ai-lora-name');
      const name = nameInput ? nameInput.value.trim() : '';
      if (!name) return;
      const entry = { name };
      const modelInput = row.querySelector('.ai-lora-model');
      if (modelInput && modelInput.value.trim() !== '') {
        const parsed = parseFloat(modelInput.value);
        if (!Number.isNaN(parsed)) entry.model = parsed;
      }
      const clipInput = row.querySelector('.ai-lora-clip');
      if (clipInput && clipInput.value.trim() !== '') {
        const parsed = parseFloat(clipInput.value);
        if (!Number.isNaN(parsed)) entry.clip = parsed;
      }
      const triggerInput = row.querySelector('.ai-lora-trigger');
      if (triggerInput) {
        const trig = triggerInput.value.trim();
        if (trig) entry.inject_trigger = trig;
      }
      const versionChk = row.querySelector('.ai-lora-is-version');
      if (versionChk && versionChk.checked) {
        entry.is_version = true;
      }
      result.push(entry);
    });
    return result;
  }

  function collectAiPayload(card) {
    const payload = {};
    const promptInput = card.querySelector('.ai-prompt-input');
    const negativeInput = card.querySelector('.ai-negative-input');
    const modelSelect = card.querySelector('.ai-model-select');
    const samplerSelect = card.querySelector('.ai-sampler-select');
    const widthInput = card.querySelector('.ai-width-input');
    const heightInput = card.querySelector('.ai-height-input');
    const stepsInput = card.querySelector('.ai-steps-input');
    const cfgInput = card.querySelector('.ai-cfg-input');
    const samplesInput = card.querySelector('.ai-samples-input');
    const seedInput = card.querySelector('.ai-seed-input');
    const saveOutput = card.querySelector('.ai-save-output');
    const nsfw = card.querySelector('.ai-nsfw');
    const censor = card.querySelector('.ai-censor');
    payload.prompt = promptInput ? promptInput.value : '';
    payload.negative_prompt = negativeInput ? negativeInput.value : '';
    payload.model = modelSelect ? modelSelect.value : '';
    payload.sampler = samplerSelect ? samplerSelect.value : '';
    payload.width = widthInput ? parseInt(widthInput.value, 10) : undefined;
    payload.height = heightInput ? parseInt(heightInput.value, 10) : undefined;
    payload.steps = stepsInput ? parseInt(stepsInput.value, 10) : undefined;
    payload.cfg_scale = cfgInput ? parseFloat(cfgInput.value) : undefined;
    payload.samples = samplesInput ? parseInt(samplesInput.value, 10) : undefined;
    payload.seed = seedInput ? seedInput.value : '';
    payload.save_output = saveOutput ? saveOutput.checked : undefined;
    payload.nsfw = nsfw ? nsfw.checked : undefined;
    payload.censor_nsfw = censor ? censor.checked : undefined;
    payload.post_processing = gatherPostProcessing(card);
    payload.loras = gatherLoras(card);
    const boolPairs = [
      ['.ai-hires-fix', 'hires_fix'],
      ['.ai-karras', 'karras'],
      ['.ai-tiling', 'tiling'],
      ['.ai-transparent', 'transparent'],
      ['.ai-trusted-workers', 'trusted_workers'],
      ['.ai-validated-backends', 'validated_backends'],
      ['.ai-slow-workers', 'slow_workers'],
      ['.ai-extra-slow-workers', 'extra_slow_workers'],
      ['.ai-disable-batching', 'disable_batching'],
      ['.ai-allow-downgrade', 'allow_downgrade'],
    ];
    boolPairs.forEach(([selector, key]) => {
      const el = card.querySelector(selector);
      if (el) payload[key] = el.checked;
    });
    const styleInput = card.querySelector('.ai-style-input');
    payload.style = styleInput ? styleInput.value.trim() : '';
    const clipSkipInput = card.querySelector('.ai-clip-skip');
    if (clipSkipInput && clipSkipInput.value.trim() !== '') {
      const parsedClip = parseInt(clipSkipInput.value, 10);
      payload.clip_skip = Number.isNaN(parsedClip) ? null : parsedClip;
    } else {
      payload.clip_skip = null;
    }
    const facefixerInput = card.querySelector('.ai-facefixer');
    if (facefixerInput && facefixerInput.value.trim() !== '') {
      const parsed = parseFloat(facefixerInput.value);
      payload.facefixer_strength = Number.isNaN(parsed) ? null : parsed;
    } else {
      payload.facefixer_strength = null;
    }
    const denoiseInput = card.querySelector('.ai-denoise');
    if (denoiseInput && denoiseInput.value.trim() !== '') {
      const parsed = parseFloat(denoiseInput.value);
      payload.denoising_strength = Number.isNaN(parsed) ? null : parsed;
    } else {
      payload.denoising_strength = null;
    }
    const hiresDenoiseInput = card.querySelector('.ai-hires-denoise');
    if (hiresDenoiseInput && hiresDenoiseInput.value.trim() !== '') {
      const parsed = parseFloat(hiresDenoiseInput.value);
      payload.hires_fix_denoising_strength = Number.isNaN(parsed) ? null : parsed;
    } else {
      payload.hires_fix_denoising_strength = null;
    }
    const aiSection = card.querySelector('.ai-generator');
    if (aiSection && aiSection.dataset && 'timeout' in aiSection.dataset) {
      const stored = aiSection.dataset.timeout;
      if (stored) {
        const parsedTimeout = parseFloat(stored);
        payload.timeout = Number.isFinite(parsedTimeout) ? parsedTimeout : null;
      } else {
        payload.timeout = null;
      }
    }
    return payload;
  }

  function setupAiControls(card, streamId) {
    const aiSection = card.querySelector('.ai-generator');
    if (!aiSection || aiSection.dataset.ready === 'true') {
      return;
    }
    aiSection.dataset.ready = 'true';
    aiSection.setAttribute('aria-hidden', 'true');
    const summaryRoot = card.querySelector('.ai-summary');
    const modalBackdrop = card.querySelector('.ai-modal-backdrop');
    const openSettingsBtn = card.querySelector('.ai-open-settings');
    const closeSettingsButtons = aiSection.querySelectorAll('.ai-close-settings, .ai-close-settings-secondary');
    if (modalBackdrop) modalBackdrop.hidden = true;

    function updateSummary() {
      if (!summaryRoot) return;
      const data = collectAiPayload(card);
      const aiGen = card.querySelector('.ai-generator');
      const width = Number(data.width);
      const height = Number(data.height);
      const stepsVal = Number(data.steps);
      const cfgVal = Number(data.cfg_scale);
      const samplesVal = Number(data.samples);
      const summaryValues = {
        model: data.model && data.model.trim() ? data.model : 'Auto',
        sampler: data.sampler ? data.sampler : 'k_euler',
        size: `${Number.isFinite(width) ? width : 512}x${Number.isFinite(height) ? height : 512}`,
        steps: Number.isFinite(stepsVal) ? stepsVal : 30,
        cfg: Number.isFinite(cfgVal) ? cfgVal : 7.5,
        samples: Number.isFinite(samplesVal) ? samplesVal : 1,
        loras: (data.loras || []).length,
        post: (data.post_processing || []).length,
        save: data.save_output ? 'Yes' : 'Temp',
      };
      let timeoutValue = null;
      if (data.timeout !== undefined && data.timeout !== null && data.timeout !== '') {
        const parsed = parseFloat(data.timeout);
        if (Number.isFinite(parsed)) timeoutValue = parsed;
      } else if (aiGen && aiGen.dataset.timeout !== undefined) {
        const stored = aiGen.dataset.timeout;
        if (stored) {
          const parsed = parseFloat(stored);
          if (Number.isFinite(parsed)) timeoutValue = parsed;
        }
      }
      if (aiGen) {
        if (Number.isFinite(timeoutValue)) {
          aiGen.dataset.timeout = String(timeoutValue);
        } else {
          aiGen.dataset.timeout = '';
        }
      }
      const timeoutLabel = Number.isFinite(timeoutValue) && timeoutValue > 0 ? timeoutValue : 'No limit';
      const mapping = {
        '.ai-summary-model': summaryValues.model,
        '.ai-summary-sampler': summaryValues.sampler,
        '.ai-summary-size': summaryValues.size,
        '.ai-summary-steps': summaryValues.steps,
        '.ai-summary-cfg': summaryValues.cfg,
        '.ai-summary-samples': summaryValues.samples,
        '.ai-summary-loras': summaryValues.loras,
        '.ai-summary-post': summaryValues.post,
        '.ai-summary-save': summaryValues.save,
        '.ai-summary-timeout': timeoutLabel,
      };
      Object.entries(mapping).forEach(([selector, value]) => {
        const el = summaryRoot.querySelector(selector);
        if (el) el.textContent = value;
      });
    }

    aiSummaryUpdaters.set(card, updateSummary);
    updateSummary();

    if (openSettingsBtn) {
      openSettingsBtn.addEventListener('click', () => {
        updateSummary();
        openAiSettings(card);
      });
    }
    if (closeSettingsButtons.length) {
      closeSettingsButtons.forEach(btn => btn.addEventListener('click', () => closeAiSettings(card)));
    }
    if (modalBackdrop) {
      modalBackdrop.addEventListener('click', () => closeAiSettings(card));
    }

    const modeSelect = card.querySelector('.mode-select');
    const promptInput = card.querySelector('.ai-prompt-input');
    if (promptInput) {
      promptInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { prompt: e.target.value } });
      });
    }
    const negativeInput = card.querySelector('.ai-negative-input');
    if (negativeInput) {
      negativeInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { negative_prompt: e.target.value } });
      });
    }
    const samplerSelect = card.querySelector('.ai-sampler-select');
    if (samplerSelect) {
      samplerSelect.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { sampler: e.target.value } });
        updateSummary();
      });
    }
    const seedInput = card.querySelector('.ai-seed-input');
    if (seedInput) {
      seedInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { seed: e.target.value } });
      });
    }
    const modelSelect = card.querySelector('.ai-model-select');
    if (modelSelect) {
      modelSelect.addEventListener('focus', () => {
        fetchAiModels().then(models => {
          if (!models || !modelSelect) return;
          const values = new Set(Array.from(modelSelect.options).map(opt => opt.value));
          models.forEach(model => {
            const name = model && model.name ? model.name : '';
            if (!name || values.has(name)) return;
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            modelSelect.appendChild(opt);
            values.add(name);
          });
        });
      });
      modelSelect.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { model: e.target.value } });
        updateSummary();
      });
    }
    const loraSection = card.querySelector('.ai-lora-section');
    const loraList = loraSection ? loraSection.querySelector('.ai-lora-list') : null;
    const loraSearchInput = loraSection ? loraSection.querySelector('.ai-lora-search-input') : null;
    const loraSearchBtn = loraSection ? loraSection.querySelector('.ai-lora-search-btn') : null;
    const loraResultsWrap = loraSection ? loraSection.querySelector('.ai-lora-results') : null;
    const loraResultsHeader = loraResultsWrap ? loraResultsWrap.querySelector('.ai-lora-results-header') : null;
    const loraResultsList = loraResultsWrap ? loraResultsWrap.querySelector('.ai-lora-results-list') : null;


    function bindNumeric(selector, key) {
      const input = card.querySelector(selector);
      if (!input) return;
      input.addEventListener('change', e => {
        const val = parseFloat(e.target.value);
        if (!Number.isFinite(val)) return;
        saveSettings(streamId, { ai_settings: { [key]: val } });
        updateSummary();
      });
    }

    function bindCheckboxSetting(selector, key) {
      const input = card.querySelector(selector);
      if (!input) return;
      input.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { [key]: e.target.checked } });
        updateSummary();
      });
    }

    function bindOptionalNumber(selector, key, parser) {
      const input = card.querySelector(selector);
      if (!input) return;
      input.addEventListener('change', e => {
        const raw = (e.target.value || '').trim();
        if (!raw) {
          saveSettings(streamId, { ai_settings: { [key]: null } });
          updateSummary();
          return;
        }
        const parsed = parser(raw);
        if (Number.isNaN(parsed)) return;
        saveSettings(streamId, { ai_settings: { [key]: parsed } });
        updateSummary();
      });
    }

    function updateLoraAddState() {
      if (!loraSection) return;
      const addBtn = loraSection.querySelector('.ai-add-lora');
      if (!addBtn) return;
      const max = parseInt(loraSection.dataset.max || '0', 10) || 0;
      const current = loraSection.querySelectorAll('.ai-lora-row').length;
      addBtn.disabled = max > 0 && current >= max;
    }

    function appendEmptyLoraRow() {
      if (!loraSection || !loraList) return null;
      const max = parseInt(loraSection.dataset.max || '0', 10) || 0;
      const current = loraList.querySelectorAll('.ai-lora-row').length;
      if (max > 0 && current >= max) {
        showNotification(`Maximum of ${max} LoRAs reached`);
        return null;
      }
      const row = document.createElement('div');
      row.className = 'ai-lora-row';
      row.innerHTML = `
        <input type="text" class="ai-lora-name" placeholder="Name or CivitAI ID">
        <input type="number" class="ai-lora-model" placeholder="Model" step="0.05" min="-5" max="5">
        <input type="number" class="ai-lora-clip" placeholder="Clip" step="0.05" min="-5" max="5">
        <input type="text" class="ai-lora-trigger" placeholder="Trigger (optional)">
        <label class="ai-lora-flag"><input type="checkbox" class="ai-lora-is-version"> Version ID</label>
        <button type="button" class="ai-lora-remove">Remove</button>
      `;
      loraList.appendChild(row);
      bindLoraRow(row);
      updateLoraAddState();
      return row;
    }

    function renderLoraResults(results, query) {
      if (!loraResultsWrap || !loraResultsList) return;
      loraResultsWrap.hidden = false;
      loraResultsList.innerHTML = '';
      if (loraResultsHeader) {
        if (results.length) {
          loraResultsHeader.textContent = query ? `Results for "${query}"` : 'LoRA results';
        } else {
          loraResultsHeader.textContent = query ? `No LoRAs found for "${query}"` : 'No LoRAs found';
        }
      }
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'ai-lora-result-empty';
        empty.textContent = 'Try a different search term.';
        loraResultsList.appendChild(empty);
        return;
      }
      results.forEach(result => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'ai-lora-result';
        const title = document.createElement('div');
        title.className = 'ai-lora-result-title';
        const modelName = result.modelName || 'Unnamed LoRA';
        const versionName = result.versionName || `Version ${result.versionId}`;
        title.textContent = `${modelName} - ${versionName}`;
        button.appendChild(title);
        if (Array.isArray(result.triggerWords) && result.triggerWords.length) {
          const triggers = document.createElement('div');
          triggers.className = 'ai-lora-result-triggers';
          triggers.textContent = `Triggers: ${result.triggerWords.slice(0, 3).join(', ')}`;
          button.appendChild(triggers);
        }
        button.addEventListener('click', () => {
          const row = appendEmptyLoraRow();
          if (!row) return;
          const nameInput = row.querySelector('.ai-lora-name');
          if (nameInput) {
            nameInput.value = (result.versionId || '').toString() || modelName;
          }
          const triggerInput = row.querySelector('.ai-lora-trigger');
          if (triggerInput && Array.isArray(result.triggerWords) && result.triggerWords.length) {
            triggerInput.value = result.triggerWords.slice(0, 2).join(', ');
          }
          const isVersionChk = row.querySelector('.ai-lora-is-version');
          if (isVersionChk && result.versionId) {
            isVersionChk.checked = true;
          }
          syncLoras();
          showNotification('LoRA added from search');
        });
        loraResultsList.appendChild(button);
      });
    }

    async function performLoraSearch(query) {
      if (!loraResultsWrap) return;
      const term = (query || '').trim();
      if (!term) {
        showNotification('Enter a search term for LoRAs');
        return;
      }
      loraResultsWrap.hidden = false;
      if (loraResultsHeader) loraResultsHeader.textContent = 'Searching...';
      if (loraResultsList) loraResultsList.innerHTML = '';
      try {
        const res = await fetch(`/ai/loras?q=${encodeURIComponent(term)}`);
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.error) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        renderLoraResults(data.results || [], term);
      } catch (err) {
        if (loraResultsHeader) loraResultsHeader.textContent = 'Search failed';
        if (loraResultsList) {
          const error = document.createElement('div');
          error.className = 'ai-lora-result-error';
          error.textContent = err && err.message ? err.message : 'Unable to load LoRAs';
          loraResultsList.appendChild(error);
        }
      }
    }

    function syncLoras() {
      if (!loraSection) return;
      const loras = gatherLoras(card);
      saveSettings(streamId, { ai_settings: { loras } });
      updateLoraAddState();
      updateSummary();
    }

    function bindLoraRow(row) {
      if (!row) return;
      const inputs = row.querySelectorAll('input');
      inputs.forEach(input => {
        const handler = () => syncLoras();
        input.addEventListener('change', handler);
        if (input.type === 'text') {
          input.addEventListener('blur', handler);
        }
      });
      const removeBtn = row.querySelector('.ai-lora-remove');
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          row.remove();
          syncLoras();
        });
      }
    }
    bindNumeric('.ai-width-input', 'width');
    bindNumeric('.ai-height-input', 'height');
    bindNumeric('.ai-steps-input', 'steps');
    bindNumeric('.ai-cfg-input', 'cfg_scale');
    bindNumeric('.ai-samples-input', 'samples');
    [
      ['.ai-hires-fix', 'hires_fix'],
      ['.ai-karras', 'karras'],
      ['.ai-tiling', 'tiling'],
      ['.ai-transparent', 'transparent'],
      ['.ai-trusted-workers', 'trusted_workers'],
      ['.ai-validated-backends', 'validated_backends'],
      ['.ai-slow-workers', 'slow_workers'],
      ['.ai-extra-slow-workers', 'extra_slow_workers'],
      ['.ai-disable-batching', 'disable_batching'],
      ['.ai-allow-downgrade', 'allow_downgrade'],
    ].forEach(([selector, key]) => bindCheckboxSetting(selector, key));
    bindOptionalNumber('.ai-clip-skip', 'clip_skip', raw => parseInt(raw, 10));
    bindOptionalNumber('.ai-facefixer', 'facefixer_strength', raw => parseFloat(raw));
    bindOptionalNumber('.ai-denoise', 'denoising_strength', raw => parseFloat(raw));
    bindOptionalNumber('.ai-hires-denoise', 'hires_fix_denoising_strength', raw => parseFloat(raw));
    const saveOutput = card.querySelector('.ai-save-output');
    if (saveOutput) {
      saveOutput.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { save_output: e.target.checked } });
        updateSummary();
      });
    }
    const nsfw = card.querySelector('.ai-nsfw');
    if (nsfw) {
      nsfw.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { nsfw: e.target.checked } });
      });
    }
    const censor = card.querySelector('.ai-censor');
    if (censor) {
      censor.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { censor_nsfw: e.target.checked } });
      });
    }
    const styleInput = card.querySelector('.ai-style-input');
    if (styleInput) {
      styleInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { style: e.target.value.trim() } });
      });
    }
    const postProcChecks = card.querySelectorAll('.ai-post-proc');
    if (postProcChecks.length) {
      postProcChecks.forEach(chk => {
        chk.addEventListener('change', () => {
          saveSettings(streamId, { ai_settings: { post_processing: gatherPostProcessing(card) } });
          updateSummary();
        });
      });
    }
    if (loraSection) {
      const addLoraBtn = loraSection.querySelector('.ai-add-lora');
      if (addLoraBtn) {
        addLoraBtn.addEventListener('click', () => {
          appendEmptyLoraRow();
          updateSummary();
        });
      }
      if (loraSearchBtn) {
        loraSearchBtn.addEventListener('click', () => {
          performLoraSearch(loraSearchInput ? loraSearchInput.value : '');
        });
      }
      if (loraSearchInput) {
        loraSearchInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            performLoraSearch(loraSearchInput.value);
          }
        });
      }
      if (loraList) {
        loraList.querySelectorAll('.ai-lora-row').forEach(row => bindLoraRow(row));
      }
      updateLoraAddState();
    }
    const generateButtons = card.querySelectorAll('.ai-generate-btn');
    const setGenerateDisabled = disabled => {
      generateButtons.forEach(btn => { btn.disabled = !!disabled; });
    };
    if (generateButtons.length) {
      const handleGenerate = async () => {
        const payload = collectAiPayload(card);
        if (!payload.prompt || !payload.prompt.trim()) {
          showNotification('Prompt is required for AI generation');
          if (promptInput) promptInput.focus();
          return;
        }
        updateSummary();
        setGenerateDisabled(true);
        renderAiStatus(card, { status: 'queued' }, { status: 'queued' });
        try {
          const res = await fetch(`/ai/generate/${encodeURIComponent(streamId)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || data.error) {
            const note = data.error || `Request failed (${res.status})`;
            showNotification(note);
            renderAiStatus(card, { status: 'error', message: note }, { status: 'error', message: note });
            setGenerateDisabled(false);
            return;
          }
          if (data.job) {
            aiActiveJobs.set(streamId, data.job);
          }
          if (data.state) {
            renderAiStatus(card, data.state, data.job || null);
          }
          showNotification('AI generation queued');
        } catch (err) {
          console.error('AI generate failed', err);
          showNotification('AI generation failed to start');
          renderAiStatus(card, { status: 'error', message: 'Request failed' }, { status: 'error', message: 'Request failed' });
          setGenerateDisabled(false);
        }
      };
      generateButtons.forEach(btn => btn.addEventListener('click', handleGenerate));
    }

    const resultsEl = card.querySelector('.ai-results');
    if (resultsEl) {
      resultsEl.addEventListener('click', e => {
        const target = e.target.closest('.ai-generated-item');
        if (!target || !target.dataset.path) return;
        const path = target.dataset.path;
        highlightAiSelection(resultsEl, path);
        saveSettings(streamId, { selected_image: path });
        const display = card.querySelector('.selected-image-display');
        if (display) display.textContent = path || 'None';
      });
    }
    if (modeSelect) {
      if (modeSelect.value === 'ai' && modelSelect) {
        modelSelect.dispatchEvent(new Event('focus'));
      }
      modeSelect.addEventListener('change', e => {
        if (e.target.value === 'ai' && modelSelect) {
          modelSelect.dispatchEvent(new Event('focus'));
        }
      });
    }
    renderAiStatus(card, { status: card.querySelector('.ai-status')?.dataset.status || 'idle' }, aiActiveJobs.get(streamId) || null);
    highlightAiSelection(resultsEl, resultsEl ? resultsEl.dataset.selected || '' : '');
  }

  function saveSettings(streamId, payload) {
    fetch(`/settings/${encodeURIComponent(streamId)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
      if (data.status === 'success') {
        showNotification(`Updated settings for ${streamId}`);
        const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
        if (card) {
          if (data.new_config && data.new_config.selected_image !== undefined) {
            const selectedPath = data.new_config.selected_image || "";
            const disp = card.querySelector('.selected-image-display');
            if (disp) disp.textContent = selectedPath || "None";
            const aiResults = card.querySelector('.ai-results');
            if (aiResults) {
              highlightAiSelection(aiResults, selectedPath);
            }
          }
          const aiSettings = data.new_config && data.new_config.ai_settings;
          if (aiSettings) {
            const aiSection = card.querySelector('.ai-generator');
            if (aiSection) {
              const timeoutValue = aiSettings.timeout;
              if (timeoutValue !== undefined && timeoutValue !== null) {
                const numericTimeout = Number(timeoutValue);
                if (Number.isFinite(numericTimeout) && numericTimeout > 0) {
                  aiSection.dataset.timeout = String(numericTimeout);
                } else {
                  aiSection.dataset.timeout = '';
                }
              }
            }
          }
          const updater = aiSummaryUpdaters.get(card);
          if (updater) updater();
        }
      } else {
        console.error(data.error || 'Unknown error updating settings.');
        showNotification(data.error || 'Error updating settings');
      }
    })
    .catch(err => console.error('Error saving settings:', err));
  }

  function toggleVisibilityForMode(card, mode, streamUrl) {
    const durationDiv = card.querySelector('.duration-container');
    const shuffleChk = card.querySelector('.shuffle-chk');
    const urlDiv = card.querySelector('.stream-url-container');
    const imagePicker = card.querySelector('.image-picker');
    const ytSettingsDiv = card.querySelector('.yt-settings');
    const selectedRow = card.querySelector('.selected-image-row');
    const folderRow = card.querySelector('.folder-row');
    if (durationDiv) durationDiv.style.display = (mode === 'random') ? '' : 'none';
    if (shuffleChk) shuffleChk.closest('label').style.display = (mode === 'random') ? '' : 'none';
    if (urlDiv) urlDiv.style.display = (mode === 'livestream') ? '' : 'none';
    if (imagePicker) imagePicker.style.display = (mode === 'specific') ? '' : 'none';
    const aiSection = card.querySelector('.ai-generator');
    const aiSummary = card.querySelector('.ai-summary');
    if (mode === 'ai') {
      if (aiSummary) aiSummary.style.display = '';
      if (aiSection && !card.classList.contains('ai-settings-open')) aiSection.setAttribute('aria-hidden', 'true');
    } else {
      if (aiSummary) aiSummary.style.display = 'none';
      if (aiSection) aiSection.setAttribute('aria-hidden', 'true');
      closeAiSettings(card);
    }
    const summaryUpdater = aiSummaryUpdaters.get(card);
    if (summaryUpdater) summaryUpdater();
    if (selectedRow) selectedRow.style.display = (mode === 'specific' || mode === 'ai') ? '' : 'none';
    if (folderRow) folderRow.style.display = (mode === 'livestream' || mode === 'ai') ? 'none' : '';
    // Only show YT options if URL looks like YouTube
    const type = detectUrlType(streamUrl);
    if (ytSettingsDiv) ytSettingsDiv.style.display = (mode === 'livestream' && type === 'YouTube') ? '' : 'none';
  }

  function loadImagesFor(streamId, folder) {
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    const imageGrid = card.querySelector('.image-picker .image-grid');
    if (!imageGrid) return;
    const selectedDisplay = card.querySelector('.selected-image-display');
    const currentSelected = selectedDisplay ? selectedDisplay.textContent.trim() : null;
    imageGrid.innerHTML = 'Loading...';
    fetch(`/images?folder=${encodeURIComponent(folder)}`)
      .then(res => res.json())
      .then(imgs => {
        imageGrid.innerHTML = '';
        imgs.forEach(path => {
          const imgEl = document.createElement('img');
          imgEl.src = `/stream/image/${path}`;
          imgEl.title = path;
          imgEl.classList.add('picker-thumbnail');
          if (currentSelected === path) {
            imgEl.classList.add('selected-thumb');
          }
          imgEl.addEventListener('click', () => {
            saveSettings(streamId, { selected_image: path });
          });
          imageGrid.appendChild(imgEl);
        });
        if (!imgs.length) {
          imageGrid.innerHTML = '(No images found in this folder)';
        }
      })
      .catch(err => {
        console.error('Error fetching images for folder:', err);
        imageGrid.innerHTML = 'Error loading images.';
      });
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.stream-card').forEach(card => {
      const streamId = card.dataset.stream;
      setupAiControls(card, streamId);
      // Card menu toggle per card
      const menuBtn = card.querySelector('.menu-button');
      const menuDd = card.querySelector('.card-menu .menu-dropdown');
      if (menuBtn && menuDd) {
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const isOpen = !menuDd.hidden;
          document.querySelectorAll('.card-menu .menu-dropdown').forEach(dd => dd.hidden = true);
          menuDd.hidden = isOpen;
          menuBtn.setAttribute('aria-expanded', String(!isOpen));
        });
      }
      // Folder change
      const folderSelect = card.querySelector('.folder-select');
      if (folderSelect) {
        // Ensure tooltip shows full folder name on hover
        folderSelect.addEventListener('change', e => {
          const folder = e.target.value;
          e.target.title = folder;
          saveSettings(streamId, { folder, selected_image: null });
        });
      }
      // Mode change
      const modeSelect = card.querySelector('.mode-select');
      const urlInput = card.querySelector('.stream-url-input');
      if (modeSelect) {
        modeSelect.addEventListener('change', e => {
          const mode = e.target.value;
          const payload = { mode };
          if (mode === 'random') {
            const durInput = card.querySelector('.duration-input');
            if (durInput) payload.duration = durInput.value;
          }
          if (mode === 'livestream') {
            if (urlInput) payload.stream_url = urlInput.value;
            const ccChk = card.querySelector('.yt-cc-chk');
            const muteChk = card.querySelector('.yt-mute-chk');
            const qualitySelect = card.querySelector('.yt-quality-select');
            if (ccChk) payload.yt_cc = ccChk.checked;
            if (muteChk) payload.yt_mute = muteChk.checked;
            if (qualitySelect) payload.yt_quality = qualitySelect.value;
            // If URL isn't YouTube, force AUTO for compatibility
            const t = detectUrlType(urlInput ? urlInput.value : '');
            if (t !== 'YouTube' && qualitySelect) {
              qualitySelect.value = 'auto';
              payload.yt_quality = 'auto';
            }
          }
          saveSettings(streamId, payload);
          toggleVisibilityForMode(card, mode, urlInput ? urlInput.value : '');
        });
      }
      // Duration change
      const durInput = card.querySelector('.duration-input');
      if (durInput) {
        durInput.addEventListener('change', e => {
          saveSettings(streamId, { duration: e.target.value });
        });
      }
      // Shuffle toggle
      const shuffleChk = card.querySelector('.shuffle-chk');
      if (shuffleChk) {
        shuffleChk.addEventListener('change', e => {
          saveSettings(streamId, { shuffle: e.target.checked });
        });
      }
      // URL helpers: type badge + background embed test + save
      function setUrlBadge(url) {
        const badge = card.querySelector('.url-type-badge');
        if (!badge) return;
        const t = detectUrlType(url);
        badge.textContent = t || '';
        badge.dataset.type = (t || '').toLowerCase();
        badge.style.visibility = t ? 'visible' : 'hidden';
      }
      let testAbort = null;
      let testTimer = null;
      async function runEmbedTest(url) {
        const statusEl = card.querySelector('.embed-status-badge');
        if (!statusEl || !url) { if (statusEl) statusEl.textContent=''; return; }
        // Debounce rapid typing
        if (testTimer) clearTimeout(testTimer);
        statusEl.textContent = 'Testingâ€¦';
        statusEl.dataset.state = 'testing';
        testTimer = setTimeout(async () => {
          if (testAbort) { try { testAbort.abort(); } catch {} }
          const ctrl = new AbortController();
          testAbort = ctrl;
          try {
            const res = await fetch('/test_embed', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url }),
              signal: ctrl.signal
            });
            const data = await res.json();
            const state = (data.status || 'error').toLowerCase();
            statusEl.dataset.state = state;
            statusEl.textContent = (data.note || data.status || '').toUpperCase();
          } catch (e) {
            statusEl.dataset.state = 'error';
            statusEl.textContent = 'ERROR';
          }
        }, 700);
      }
      if (urlInput) {
        setUrlBadge(urlInput.value || '');
        runEmbedTest(urlInput.value || '');
        urlInput.addEventListener('input', e => {
          setUrlBadge(e.target.value);
          toggleVisibilityForMode(card, modeSelect.value, e.target.value);
          runEmbedTest(e.target.value);
        });
        urlInput.addEventListener('change', e => {
          saveSettings(streamId, { stream_url: e.target.value });
          toggleVisibilityForMode(card, modeSelect.value, e.target.value);
          // If not YouTube, force quality AUTO
          const qualitySelect = card.querySelector('.yt-quality-select');
          const t = detectUrlType(e.target.value);
          if (t !== 'YouTube' && qualitySelect) {
            qualitySelect.value = 'auto';
            saveSettings(streamId, { yt_quality: 'auto' });
          }
        });
      }
      // YT settings changes
      const ccChk = card.querySelector('.yt-cc-chk');
      const muteChk = card.querySelector('.yt-mute-chk');
      const qualitySelect = card.querySelector('.yt-quality-select');
      const renameBtn = card.querySelector('.menu-rename');
      if (ccChk) {
        ccChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_cc: e.target.checked });
        });
      }
      if (muteChk) {
        muteChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_mute: e.target.checked });
        });
      }
      if (qualitySelect) {
        qualitySelect.addEventListener('change', e => {
          saveSettings(streamId, { yt_quality: e.target.value });
        });
      }
      
      function slugify(s){
        return (s||'').toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,'');
      }
      if (renameBtn) {
        renameBtn.addEventListener('click', () => {
          const a = card.querySelector('.card-header h2 a.stream-link');
          const current = a ? a.textContent.trim() : streamId;
          const next = prompt('Rename stream', current);
          if (next === null) return; // cancelled
          // preemptive duplicate check
          const currentSlug = slugify(current || streamId);
          const nextSlug = slugify(next || '');
          if (!nextSlug) { showNotification('Name cannot be empty'); return; }
          if (takenSlugs[nextSlug] && takenSlugs[nextSlug] !== streamId) {
            showNotification('Another stream already uses this name');
            return;
          }
          // Update map to new slug
          if (takenSlugs[currentSlug] === streamId) { delete takenSlugs[currentSlug]; }
          takenSlugs[nextSlug] = streamId;
          saveSettings(streamId, { label: next });
          if (a) {
            a.textContent = next || streamId;
            const slug = slugify(next || streamId);
            a.href = '/stream/' + encodeURIComponent(slug);
          }
          const dd = card.querySelector('.card-menu .menu-dropdown');
          if (dd) dd.hidden = true;
        });
      }
      // Reload images button
      const reloadBtn = card.querySelector('.reload-images-btn');
      if (reloadBtn) {
        reloadBtn.addEventListener('click', () => {
          const folder = folderSelect ? folderSelect.value : 'all';
          loadImagesFor(streamId, folder);
        });
      }

      toggleVisibilityForMode(card, modeSelect ? modeSelect.value : '', urlInput ? urlInput.value : '');
    });
  });
</script>
</body>
</html>
