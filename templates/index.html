<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EchoMosaic Dashboard</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<header class="top-bar">
  <h1>EchoMosaic</h1>
  <nav>
    <a href="{{ url_for('app_settings') }}">Settings</a>
  </nav>
</header>
<div class="container">

  <!-- Group Manager Card -->
  <div class="stream-card" id="group-manager">
    <div class="card-header">
      <h2>Groups</h2>
    </div>
    <div class="group-section">
      <div id="group-tiles" class="group-tiles"></div>
    </div>
  </div>

  <div class="controls">
    <button id="add-stream">Add Stream</button>
    <button id="open-mosaic">View Streams</button>
  </div>

  <div id="dashboard-grid" class="dashboard-grid">
    {# Generate a card for each stream dynamically #}
    {% for stream_id, conf in stream_settings.items() %}
    <div class="stream-card" data-stream="{{ stream_id }}">
      <div class="card-header">
        <div class="title-row">
          <h2><a class="stream-link" href="{{ url_for('render_stream', name=(conf.label if conf.label else stream_id)|slugify) }}" target="_blank">{{ conf.label if conf.label else stream_id|capitalize }}</a></h2>
          <button class="rename-stream" data-stream="{{ stream_id }}" title="Rename stream">Rename</button>
        </div>
        <button class="remove-stream" data-stream="{{ stream_id }}" aria-label="Remove stream {{ stream_id }}">Remove</button>
      </div>

      <div class="form-grid">
        <!-- Folder Selection -->
        <div class="form-row">
          <label for="folder-{{ stream_id }}">Folder</label>
          <select id="folder-{{ stream_id }}" class="folder-select" data-stream="{{ stream_id }}" title="{{ conf.folder }}">
            {% for f in subfolders %}
              <option value="{{ f }}" title="{{ f }}" {% if conf.folder == f %} selected {% endif %}>{{ f }}</option>
            {% endfor %}
          </select>
        </div>

        <!-- Mode Selection -->
        <div class="form-row">
          <label for="mode-{{ stream_id }}">Mode</label>
          <select id="mode-{{ stream_id }}" class="mode-select" data-stream="{{ stream_id }}">
            <option value="random" {% if conf.mode == 'random' %} selected {% endif %}>Random</option>
            <option value="specific" {% if conf.mode == 'specific' %} selected {% endif %}>Specific</option>
            <option value="livestream" {% if conf.mode == 'livestream' %} selected {% endif %}>Livestream</option>
          </select>
        </div>

        

        <!-- Duration -->
        <div class="form-row duration-container" {% if conf.mode != 'random' %} style="display:none;" {% endif %}>
          <label for="duration-{{ stream_id }}">Duration (sec)</label>
          <input id="duration-{{ stream_id }}" type="number" class="duration-input" data-stream="{{ stream_id }}" value="{{ conf.duration }}" min="1">
        </div>

        <!-- Stream URL -->
        <div class="form-row stream-url-container" {% if conf.mode != 'livestream' %} style="display:none;" {% endif %}>
          <label for="stream-url-{{ stream_id }}">Stream URL</label>
          <input id="stream-url-{{ stream_id }}" type="text" class="stream-url-input" data-stream="{{ stream_id }}" value="{{ conf.stream_url if conf.stream_url else '' }}" placeholder="https://...">
        </div>

        <!-- YT Settings -->
        <div class="form-row yt-settings" data-stream="{{ stream_id }}" style="display:none;">
          <div class="inline-controls">
            <label><input type="checkbox" class="yt-cc-chk" data-stream="{{ stream_id }}" {% if conf.yt_cc %} checked {% endif %}> CC</label>
            <label><input type="checkbox" class="yt-mute-chk" data-stream="{{ stream_id }}" {% if conf.yt_mute %} checked {% endif %}> Mute</label>
            <label for="yt-quality-{{ stream_id }}">Quality</label>
            <input type="text" id="yt-quality-{{ stream_id }}" class="yt-quality-input" data-stream="{{ stream_id }}" value="{{ conf.yt_quality }}" placeholder="auto/hd720/etc">
          </div>
        </div>
      </div>

      <!-- Specific Image Picker -->
      <div class="image-picker" data-stream="{{ stream_id }}" {% if conf.mode != 'specific' %} style="display:none;" {% endif %}>
        <div class="image-picker-header">
          <label>Pick an Image (Folder: {{ conf.folder }})</label>
          <button type="button" class="reload-images-btn" data-stream="{{ stream_id }}">Reload</button>
        </div>
        <div class="image-grid"></div>
      </div>

      <p class="selected-image-row">
        <strong>Selected Image:</strong>
        <span class="selected-image-display">{{ conf.selected_image if conf.selected_image else "None" }}</span>
      </p>
    </div>
    {% endfor %}
  </div>
</div>

<!-- Notification -->
<div id="notification" class="notification">Settings updated!</div>

<!-- Floating Notes Pad -->
<div id="notepad" class="notepad collapsed">
  <div class="notepad-header">
    <span>Notes</span>
    <button id="toggle-notepad">Toggle</button>
  </div>
  <textarea id="notepad-text"></textarea>
  <button id="save-notes">Save</button>
</div>

<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
  const socket = io();
  const notification = document.getElementById('notification');
  const addStreamBtn = document.getElementById('add-stream');
  const openMosaicBtn = document.getElementById('open-mosaic');
  
  // Group Manager elements
  const groupTiles = document.getElementById('group-tiles');

  function showNotification(msg) {
    notification.textContent = msg;
    notification.classList.add('show');
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }

  // No layout settings for global /stream; it adapts dynamically

  if (openMosaicBtn) {
    openMosaicBtn.addEventListener('click', () => {
      window.open('/stream', '_blank');
    });
  }

  // Group manager logic
  function makeEl(tag, attrs = {}, children = []) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v]) => { if (k==='class') e.className=v; else if (k==='style') e.style.cssText=v; else e.setAttribute(k,v); });
    children.forEach(c => e.appendChild(typeof c==='string' ? document.createTextNode(c) : c));
    return e;
  }
  // Persist expanded/collapsed tile state
  function getOpenSet() {
    try { return new Set(JSON.parse(localStorage.getItem('gmOpen') || '[]')); } catch { return new Set(); }
  }
  function setOpenSet(s) { try { localStorage.setItem('gmOpen', JSON.stringify(Array.from(s))); } catch {} }
  function markOpen(name, open) {
    if (!name) return; // only persist named groups
    const s = getOpenSet();
    if (open) s.add(name); else s.delete(name);
    setOpenSet(s);
  }
  let gmOpenSet = new Set();
  let gmCurrentGroups = {};
  function loadOpenSet() {
    try { gmOpenSet = new Set(JSON.parse(localStorage.getItem('gmOpen') || '[]')); } catch (e) { gmOpenSet = new Set(); }
  }
  function persistOpenSet() {
    try { localStorage.setItem('gmOpen', JSON.stringify(Array.from(gmOpenSet))); } catch (e) {}
  }
  function markOpen(name, open) {
    if (!name) return;
    if (open) gmOpenSet.add(name); else gmOpenSet.delete(name);
    persistOpenSet();
  }
  function isOpen(name) { return name && gmOpenSet.has(name); }

  async function loadGroupsUI() {
    try {
      loadOpenSet();
      const [streamsMeta, groupsData] = await Promise.all([
        fetch('/streams_meta').then(r=>r.json()),
        fetch('/groups').then(r=>r.json())
      ]);
      const groups = groupsData || {};
      gmCurrentGroups = groups;
      // Build tiles
      if (groupTiles) {
        groupTiles.innerHTML = '';
        // Add tile
        const addTile = makeEl('div', {class:'group-tile add'}, [
          makeEl('div', {class:'tile-header'}, ['+ New Group'])
        ]);
        addTile.addEventListener('click', () => {
          const tile = createGroupTile(streamsMeta, groups, null);
          groupTiles.prepend(tile);
          // open editor immediately
          const body = tile.querySelector('.tile-body');
          if (body) body.hidden = false;
          tile.classList.add('expanded');
          const nameInput = tile.querySelector('.tile-name');
          if (nameInput) nameInput.focus();
        });
        groupTiles.appendChild(addTile);

        // Existing group tiles
        Object.keys(groups).forEach(name => {
          groupTiles.appendChild(createGroupTile(streamsMeta, groups, name));
        });
      }
    } catch (e) { console.error('Failed to load groups UI', e); }
  }
  function selectedIds(container) {
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(c=>c.value);
  }
  function createGroupTile(streamsMeta, groups, name) {
    const gdata = name ? (groups[name]||[]) : [];
    const members = new Set(Array.isArray(gdata) ? gdata : (gdata?.streams || []));
    const gLayout = Array.isArray(gdata) ? {} : (gdata?.layout || {});
    const isNew = !name;
    const tile = makeEl('div', {class:'group-tile'}, []);
    const header = makeEl('div', {class:'tile-header'}, []);
    const title = makeEl('span', {class:'tile-title'}, [name || 'New Group']);
    const actions = makeEl('div', {class:'tile-actions'}, []);
    const open = name ? makeEl('a', {href:`/stream/group/${encodeURIComponent(name)}`, target:'_blank'}, ['Open']) : null;
    const edit = makeEl('button', {class:'tile-edit'}, ['Edit']);
    const del = name ? makeEl('button', {class:'tile-del'}, ['Delete']) : null;
    if (open) actions.appendChild(open);
    actions.appendChild(edit);
    if (del) actions.appendChild(del);
    header.appendChild(title);
    header.appendChild(actions);
    tile.appendChild(header);
    const body = makeEl('div', {class:'tile-body', hidden: !isOpen(name)}, []);
    if (isOpen(name)) tile.classList.add('expanded');
    const nameRow = makeEl('div', {class:'tile-row'}, [
      makeEl('label', {}, ['Name: ', makeEl('input', {type:'text', class:'tile-name', value: name || ''}, [])])
    ]);
    body.appendChild(nameRow);
    // Layout selection
    const layoutRow = makeEl('div', {class:'tile-row'}, []);
    const layoutSelect = makeEl('select', {class:'tile-layout'}, []);
    ['grid','horizontal','vertical','focus','pip'].forEach(opt => {
      const o = makeEl('option', {value:opt}, [opt.charAt(0).toUpperCase()+opt.slice(1)]);
      layoutSelect.appendChild(o);
    });
    layoutRow.appendChild(makeEl('label', {}, ['Layout: ', layoutSelect]));
    const colsInput = makeEl('input', {type:'number', min:'1', max:'6', class:'tile-cols', value: gLayout.cols || 2}, []);
    const colsWrap = makeEl('span', {class:'tile-cols-wrap'}, [' Columns: ', colsInput]);
    layoutRow.appendChild(colsWrap);
    // PIP options
    const pipWrap = makeEl('span', {class:'tile-pip-wrap', style:'display:none;'}, []);
    const pipMain = makeEl('select', {class:'tile-pip-main'}, []);
    const pipPip = makeEl('select', {class:'tile-pip-pip'}, []);
    const pipCorner = makeEl('select', {class:'tile-pip-corner'}, []);
    ['top-left','top-right','bottom-left','bottom-right'].forEach(c => pipCorner.appendChild(makeEl('option', {value:c}, [c])));
    const pipSize = makeEl('input', {type:'number', min:'10', max:'50', class:'tile-pip-size', value: gLayout.pip_size || 25}, []);
    pipWrap.appendChild(document.createTextNode(' Main: ')); pipWrap.appendChild(pipMain);
    pipWrap.appendChild(document.createTextNode(' Corner: ')); pipWrap.appendChild(pipCorner);
    pipWrap.appendChild(document.createTextNode(' PIP: ')); pipWrap.appendChild(pipPip);
    pipWrap.appendChild(document.createTextNode(' Size%: ')); pipWrap.appendChild(pipSize);
    layoutRow.appendChild(pipWrap);
    body.appendChild(layoutRow);
    // Bulk row (Add all / Remove all) above the combo
    const bulkRow = makeEl('div', {class:'tile-row tile-bulk-row'}, []);
    const addAllBtn = makeEl('button', {class:'tile-addall-btn', type:'button'}, ['Add all']);
    const removeAllBtn = makeEl('button', {class:'tile-removeall-btn', type:'button'}, ['Remove all']);
    bulkRow.appendChild(addAllBtn);
    bulkRow.appendChild(removeAllBtn);
    body.appendChild(bulkRow);
    // Add row with combined search/select + Add
    const addRow = makeEl('div', {class:'tile-row tile-add-row'}, []);
    const dlId = `dl-${Math.random().toString(36).slice(2)}`;
    const combo = makeEl('input', {type:'text', class:'tile-combo', placeholder:'Search or selectâ€¦', list: dlId}, []);
    const datalist = makeEl('datalist', {id: dlId}, []);
    const addBtn = makeEl('button', {class:'tile-add-btn', type:'button'}, ['Add']);
    addRow.appendChild(combo);
    addRow.appendChild(addBtn);
    body.appendChild(addRow);
    body.appendChild(datalist);
    // Chips container for current members
    const chips = makeEl('div', {class:'member-chips'}, []);
    body.appendChild(chips);
    // helpers to refresh UI
    function labelOf(id) { return (streamsMeta[id]?.label || id) + ''; }
    function candidates(query) {
      const q = (query||'').toLowerCase();
      return Object.keys(streamsMeta)
        .filter(id => !members.has(id))
        .filter(id => labelOf(id).toLowerCase().includes(q))
        .sort((a,b) => labelOf(a).localeCompare(labelOf(b)));
    }
    function refreshTitleCount() {
      const count = members.size;
      title.textContent = (tile.querySelector('.tile-name')?.value?.trim() || name || 'New Group') + ` (${count})`;
    }
    function refreshPipSelects() {
      function fill(sel, selected) {
        sel.innerHTML='';
        Array.from(members).forEach(id => {
          const o = makeEl('option', {value:id}, [labelOf(id)]);
          if (selected && selected===id) o.selected = true;
          sel.appendChild(o);
        });
      }
      fill(pipMain, gLayout.pip_main && members.has(gLayout.pip_main) ? gLayout.pip_main : Array.from(members)[0]);
      fill(pipPip, gLayout.pip_pip && members.has(gLayout.pip_pip) ? gLayout.pip_pip : Array.from(members)[1]);
      // corner
      Array.from(pipCorner.options).forEach(opt => opt.selected = (opt.value === (gLayout.pip_corner || 'bottom-right')));
      pipSize.value = gLayout.pip_size || 25;
    }
    function updateLayoutVisibility() {
      const v = layoutSelect.value;
      colsWrap.style.display = (v==='grid') ? '' : 'none';
      pipWrap.style.display = (v==='pip') ? '' : 'none';
      if (v==='pip') refreshPipSelects();
    }
    function refreshDatalist() {
      datalist.innerHTML = '';
      candidates(combo.value).forEach(id => {
        datalist.appendChild(makeEl('option', {value: labelOf(id)}, []));
      });
    }
    function refreshChips() {
      chips.innerHTML = '';
      const list = makeEl('ul', {class:'member-list'}, []);
      const sorted = Array.from(members).sort((a,b) => labelOf(a).localeCompare(labelOf(b)));
      sorted.forEach(id => {
        const li = makeEl('li', {class:'member-item'}, []);
        const nameSpan = makeEl('span', {class:'member-name'}, [labelOf(id)]);
        const rm = makeEl('button', {class:'member-remove', title:'Remove'}, ['Remove']);
        rm.addEventListener('click', () => {
          members.delete(id);
          refreshDatalist();
          refreshChips();
        });
        li.appendChild(nameSpan);
        li.appendChild(rm);
        list.appendChild(li);
      });
      chips.appendChild(list);
      refreshTitleCount();
    }
    // init layout controls
    layoutSelect.value = gLayout.layout || 'grid';
    updateLayoutVisibility();
    refreshDatalist();
    refreshChips();
    combo.addEventListener('input', refreshDatalist);
    combo.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addBtn.click(); } });
    function resolveSingleSelection() {
      const q = combo.value.trim();
      if (!q) return null;
      // try exact label match first
      const byLabel = candidates('').find(id => labelOf(id).toLowerCase() === q.toLowerCase());
      if (byLabel && !members.has(byLabel)) return byLabel;
      // fallback: if only one candidate matches substring, use it
      const cands = candidates(q);
      if (cands.length === 1) return cands[0];
      // also allow exact id match
      if (!members.has(q) && streamsMeta[q]) return q;
      return null;
    }
    addBtn.addEventListener('click', () => {
      const id = resolveSingleSelection();
      if (!id) return;
      members.add(id);
      combo.value = '';
      refreshDatalist();
      refreshChips();
      updateLayoutVisibility();
    });
    addAllBtn.addEventListener('click', () => {
      const q = combo.value;
      candidates(q).forEach(id => members.add(id));
      combo.value = '';
      refreshDatalist();
      refreshChips();
      updateLayoutVisibility();
    });
    removeAllBtn.addEventListener('click', () => {
      members.clear();
      combo.value = '';
      refreshDatalist();
      refreshChips();
      updateLayoutVisibility();
    });
    layoutSelect.addEventListener('change', updateLayoutVisibility);
    const btns = makeEl('div', {class:'tile-buttons'}, []);
    const save = makeEl('button', {class:'tile-save'}, ['Save']);
    const cancel = makeEl('button', {class:'tile-cancel'}, ['Cancel']);
    btns.appendChild(save);
    btns.appendChild(cancel);
    body.appendChild(btns);
    tile.appendChild(body);

    // interactions
    edit.addEventListener('click', () => {
      body.hidden = !body.hidden;
      tile.classList.toggle('expanded', !body.hidden);
      markOpen(name, !body.hidden);
    });
    if (del) {
      del.addEventListener('click', async () => {
        if (!confirm(`Delete group ${name}?`)) return;
        await fetch(`/groups/${encodeURIComponent(name)}`, {method:'DELETE'});
        markOpen(name, false);
        tile.classList.remove('expanded');
        loadGroupsUI();
      });
    }
    save.addEventListener('click', async () => {
      const nameVal = (tile.querySelector('.tile-name').value || '').trim();
      if (!nameVal) { alert('Enter a group name'); return; }
      const ids = Array.from(members);
      // Build layout payload
      const layoutVal = layoutSelect.value;
      const payloadLayout = { layout: layoutVal };
      if (layoutVal==='grid') payloadLayout.cols = parseInt(colsInput.value||'2',10);
      if (layoutVal==='pip') {
        payloadLayout.pip_main = pipMain.value || null;
        payloadLayout.pip_pip = pipPip.value || null;
        payloadLayout.pip_corner = pipCorner.value || 'bottom-right';
        payloadLayout.pip_size = parseInt(pipSize.value||'25',10);
      }
      const res = await fetch('/groups', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: nameVal, streams: ids, layout: payloadLayout})});
      if (res.ok) {
        showNotification('Saved group');
        // Collapse after save (and handle rename)
        if (name && nameVal !== name) markOpen(name, false);
        markOpen(nameVal, false);
        tile.classList.remove('expanded');
        loadGroupsUI();
      } else {
        alert('Failed to save group');
      }
    });
    cancel.addEventListener('click', () => { body.hidden = true; tile.classList.remove('expanded'); });
    // Keep count/title in sync with name edits
    const nameInputEl = nameRow.querySelector('.tile-name');
    if (nameInputEl) nameInputEl.addEventListener('input', () => { refreshTitleCount(); });
    return tile;
  }

  // initial load
  document.addEventListener('DOMContentLoaded', loadGroupsUI);

  

  // Add a new stream by posting to /streams
  addStreamBtn.addEventListener('click', () => {
    fetch('/streams', {method:'POST'})
      .then(res => res.json())
      .then(data => {
        if (data.stream_id) {
          location.reload();
        }
      });
  });

  // Remove a stream
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('remove-stream')) {
      const id = e.target.dataset.stream;
      if (confirm('Delete ' + id + '?')) {
        fetch('/streams/' + encodeURIComponent(id), {method:'DELETE'})
          .then(res => res.json())
          .then(data => {
            if (data.status === 'deleted') {
              location.reload();
            }
          });
      }
    }
  });

  // Socket.IO listener for layout updates if needed in future
  socket.on('streams_changed', (data) => {
    // This could be used to update the UI without reload.
    console.log('Streams changed:', data);
  });

  // Notepad behaviour
  const notepad = document.getElementById('notepad');
  const toggleNotepadBtn = document.getElementById('toggle-notepad');
  const notepadText = document.getElementById('notepad-text');
  const saveNotesBtn = document.getElementById('save-notes');
  // Load notes from server
  fetch('/notes')
    .then(r => r.json())
    .then(({text}) => { notepadText.value = text || ''; })
    .catch(() => {});
  toggleNotepadBtn.addEventListener('click', () => {
    notepad.classList.toggle('collapsed');
  });
  saveNotesBtn.addEventListener('click', () => {
    fetch('/notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: notepadText.value })
    })
    .then(r => r.json())
    .then(() => showNotification('Notes saved on server'))
    .catch(() => showNotification('Failed to save notes'));
  });

  // The following section reuses much of the original dashboard logic to
  // handle folder/mode selection, duration changes, image selection and
  // reload.  It has been lightly adapted to support dynamically added
  // streams.  The logic is encapsulated in functions that operate on
  // elements with a ``data-stream`` attribute.

  function saveSettings(streamId, payload) {
    fetch(`/settings/${encodeURIComponent(streamId)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
      if (data.status === 'success') {
        showNotification(`Updated settings for ${streamId}`);
        const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
        if (card && data.new_config.selected_image !== undefined) {
          const disp = card.querySelector('.selected-image-display');
          disp.textContent = data.new_config.selected_image || 'None';
        }
      } else {
        console.error(data.error || 'Unknown error updating settings.');
      }
    })
    .catch(err => console.error('Error saving settings:', err));
  }

  function toggleVisibilityForMode(card, mode, streamUrl) {
    const durationDiv = card.querySelector('.duration-container');
    const urlDiv = card.querySelector('.stream-url-container');
    const imagePicker = card.querySelector('.image-picker');
    const ytSettingsDiv = card.querySelector('.yt-settings');
    if (durationDiv) durationDiv.style.display = (mode === 'random') ? '' : 'none';
    if (urlDiv) urlDiv.style.display = (mode === 'livestream') ? '' : 'none';
    if (imagePicker) imagePicker.style.display = (mode === 'specific') ? '' : 'none';
    if (ytSettingsDiv) {
      if (mode === 'livestream' && (streamUrl.includes('youtube.com') || streamUrl.includes('youtu.be'))) {
        ytSettingsDiv.style.display = '';
      } else {
        ytSettingsDiv.style.display = 'none';
      }
    }
  }

  function loadImagesFor(streamId, folder) {
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    const imageGrid = card.querySelector('.image-picker .image-grid');
    if (!imageGrid) return;
    const selectedDisplay = card.querySelector('.selected-image-display');
    const currentSelected = selectedDisplay ? selectedDisplay.textContent.trim() : null;
    imageGrid.innerHTML = 'Loading...';
    fetch(`/images?folder=${encodeURIComponent(folder)}`)
      .then(res => res.json())
      .then(imgs => {
        imageGrid.innerHTML = '';
        imgs.forEach(path => {
          const imgEl = document.createElement('img');
          imgEl.src = `/stream/image/${path}`;
          imgEl.title = path;
          imgEl.classList.add('picker-thumbnail');
          if (currentSelected === path) {
            imgEl.classList.add('selected-thumb');
          }
          imgEl.addEventListener('click', () => {
            saveSettings(streamId, { selected_image: path });
          });
          imageGrid.appendChild(imgEl);
        });
        if (!imgs.length) {
          imageGrid.innerHTML = '(No images found in this folder)';
        }
      })
      .catch(err => {
        console.error('Error fetching images for folder:', err);
        imageGrid.innerHTML = 'Error loading images.';
      });
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.stream-card').forEach(card => {
      const streamId = card.dataset.stream;
      // Folder change
      const folderSelect = card.querySelector('.folder-select');
      if (folderSelect) {
        // Ensure tooltip shows full folder name on hover
        folderSelect.addEventListener('change', e => {
          const folder = e.target.value;
          e.target.title = folder;
          saveSettings(streamId, { folder, selected_image: null });
        });
      }
      // Mode change
      const modeSelect = card.querySelector('.mode-select');
      const urlInput = card.querySelector('.stream-url-input');
      if (modeSelect) {
        modeSelect.addEventListener('change', e => {
          const mode = e.target.value;
          const payload = { mode };
          if (mode === 'random') {
            const durInput = card.querySelector('.duration-input');
            if (durInput) payload.duration = durInput.value;
          }
          if (mode === 'livestream') {
            if (urlInput) payload.stream_url = urlInput.value;
            const ccChk = card.querySelector('.yt-cc-chk');
            const muteChk = card.querySelector('.yt-mute-chk');
            const qualityInput = card.querySelector('.yt-quality-input');
            if (ccChk) payload.yt_cc = ccChk.checked;
            if (muteChk) payload.yt_mute = muteChk.checked;
            if (qualityInput) payload.yt_quality = qualityInput.value;
          }
          saveSettings(streamId, payload);
          toggleVisibilityForMode(card, mode, urlInput ? urlInput.value : '');
        });
      }
      // Duration change
      const durInput = card.querySelector('.duration-input');
      if (durInput) {
        durInput.addEventListener('change', e => {
          saveSettings(streamId, { duration: e.target.value });
        });
      }
      // URL change
      if (urlInput) {
        urlInput.addEventListener('change', e => {
          saveSettings(streamId, { stream_url: e.target.value });
          toggleVisibilityForMode(card, modeSelect.value, e.target.value);
        });
      }
      // YT settings changes
      const ccChk = card.querySelector('.yt-cc-chk');
      const muteChk = card.querySelector('.yt-mute-chk');
      const qualityInput = card.querySelector('.yt-quality-input');
      const renameBtn = card.querySelector('.rename-stream');
      if (ccChk) {
        ccChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_cc: e.target.checked });
        });
      }
      if (muteChk) {
        muteChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_mute: e.target.checked });
        });
      }
      if (qualityInput) {
        qualityInput.addEventListener('change', e => {
          saveSettings(streamId, { yt_quality: e.target.value });
        });
      }
      
      function slugify(s){
        return (s||'').toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,'');
      }
      if (renameBtn) {
        renameBtn.addEventListener('click', () => {
          const a = card.querySelector('.card-header h2 a.stream-link');
          const current = a ? a.textContent.trim() : streamId;
          const next = prompt('Rename stream', current);
          if (next === null) return; // cancelled
          saveSettings(streamId, { label: next });
          if (a) {
            a.textContent = next || streamId;
            const slug = slugify(next || streamId);
            a.href = '/stream/' + encodeURIComponent(slug);
          }
        });
      }
      // Reload images button
      const reloadBtn = card.querySelector('.reload-images-btn');
      if (reloadBtn) {
        reloadBtn.addEventListener('click', () => {
          const folder = folderSelect ? folderSelect.value : 'all';
          loadImagesFor(streamId, folder);
        });
      }

      toggleVisibilityForMode(card, modeSelect ? modeSelect.value : '', urlInput ? urlInput.value : '');
    });
  });
</script>
</body>
</html>
