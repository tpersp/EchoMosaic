<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>EchoMosaic Dashboard</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
<header class="top-bar">
  <h1>EchoMosaic</h1>
  <nav>
    <a href="{{ url_for('app_settings') }}">Settings</a>
    <button id="theme-toggle" class="icon-btn" type="button" aria-label="Toggle theme" title="Toggle theme" style="margin-left:.5rem;"></button>
  </nav>
</header>
<div class="container">

  <datalist id="global-tag-options">
    {% for tag in global_tags %}
    <option value="{{ tag }}"></option>
    {% endfor %}
  </datalist>

  <!-- Group Manager Card -->
  <div class="stream-card" id="group-manager">
    <div class="card-header">
      <h2>Groups</h2>
    </div>
    <div class="group-section">
      <div id="group-tiles" class="group-tiles"></div>
    </div>
  </div>

  <div class="controls">
    <button id="add-stream">Add Stream</button>
    <button id="open-mosaic">View Streams</button>
    <label for="mosaic-layout-select" style="margin-left: .5rem;">Layout</label>
    <select id="mosaic-layout-select">
      <option value="grid" {% if mosaic_settings.layout == 'grid' %}selected{% endif %}>Grid</option>
      <option value="horizontal" {% if mosaic_settings.layout == 'horizontal' %}selected{% endif %}>Horizontal</option>
      <option value="vertical" {% if mosaic_settings.layout == 'vertical' %}selected{% endif %}>Vertical</option>
      <option value="focus" {% if mosaic_settings.layout == 'focus' %}selected{% endif %}>Focus</option>
      <option value="pip" {% if mosaic_settings.layout == 'pip' %}selected{% endif %}>PiP</option>
    </select>
    <label for="mosaic-cols-input" id="mosaic-cols-label" style="display: {% if mosaic_settings.layout == 'grid' %}inline{% else %}none{% endif %};">Cols</label>
    <input id="mosaic-cols-input" type="number" min="1" max="6" value="{{ mosaic_settings.cols }}" style="width: 4.5rem; display: {% if mosaic_settings.layout == 'grid' %}inline-block{% else %}none{% endif %};" />
  </div>

  <div class="filter-bar" id="filter-bar">
    <div class="filter-group">
      <label for="tag-filter-input">Filter Tags</label>
      <div class="tag-filter-input">
        <div class="tag-chip-list" id="tag-filter-chips">
          <input type="text" id="tag-filter-input" placeholder="Add tag filter" list="global-tag-options" autocomplete="off" />
        </div>
      </div>
    </div>
    <div class="filter-group">
      <label for="sort-select">Sort</label>
      <select id="sort-select">
        <option value="default" selected>Default</option>
        <option value="group">Group by Tag</option>
      </select>
    </div>
  </div>

  <div class="stream-card" id="tag-manager">
    <div class="card-header">
      <h2>Tags</h2>
    </div>
    <div class="tag-manager-body">
      <div id="tag-manager-list" class="tag-manager-list"></div>
      <div class="tag-manager-actions">
        <input type="text" id="new-tag-input" placeholder="Create tag" list="global-tag-options" autocomplete="off" />
        <button type="button" id="create-tag-btn">Add</button>
      </div>
      <p class="tag-manager-hint">Tags are shared across all streams. Remove tags here when no cards use them.</p>
    </div>
  </div>

  <div id="dashboard-grid" class="dashboard-grid">
    {# Generate a card for each stream dynamically #}
    {% for stream_id, conf in stream_settings.items() %}
    <div class="stream-card" data-stream="{{ stream_id }}" data-hide-nsfw="{{ "true" if conf.hide_nsfw|default(False) else "false" }}" data-tags='{{ (conf.tags|default([]))|tojson }}' data-selected-path="{{ conf.selected_image or '' }}" data-selected-kind="{{ conf.selected_media_kind or '' }}" data-video-mode="{{ conf.video_playback_mode|default('duration') }}" data-video-volume="{{ conf.video_volume|default(1.0) }}" data-media-mode="{{ conf.media_mode|default('image') }}">
      <div class="card-header">
        <div class="title-row">
          <h2><a class="stream-link" href="{{ url_for('render_stream', name=(conf.label if conf.label else stream_id)|slugify) }}" target="_blank">{{ conf.label if conf.label else stream_id|capitalize }}</a></h2>
        </div>
        <div class="card-menu" data-stream="{{ stream_id }}">
          <button class="menu-button" aria-haspopup="true" aria-expanded="false" title="More"><span class="burger"></span></button>
          <div class="menu-dropdown" hidden>
            <button class="menu-rename" data-stream="{{ stream_id }}">Rename</button>
            <button class="menu-remove" data-stream="{{ stream_id }}">Remove</button>
          </div>
        </div>
      </div>

      <div class="form-grid">
        <!-- Mode Selection (moved to top) -->
        {% set media_mode = conf.media_mode|default('image') %}
        {% set mode_value = conf.mode|default('random') %}
        <div class="form-row mode-row">
          <label for="mode-category-{{ stream_id }}">Mode</label>
          <div class="mode-selectors">
            <select id="mode-category-{{ stream_id }}" class="mode-category-select" data-stream="{{ stream_id }}">
              <option value="image" {% if media_mode == 'image' %}selected{% endif %}>Image / GIF</option>
              <option value="video" {% if media_mode == 'video' %}selected{% endif %}>Video</option>
              <option value="livestream" {% if media_mode == 'livestream' %}selected{% endif %}>URL / Embed</option>
              <option value="ai" {% if media_mode == 'ai' %}selected{% endif %}>AI Images</option>
            </select>
            <div class="mode-variant-wrapper">
              <select id="mode-option-{{ stream_id }}" class="mode-select" data-stream="{{ stream_id }}">
                <option value="random" data-category="image" {% if media_mode == 'image' and mode_value == 'random' %}selected{% endif %}>Random</option>
                <option value="specific" data-category="image" {% if media_mode == 'image' and mode_value == 'specific' %}selected{% endif %}>Specific</option>
                <option value="random" data-category="video" {% if media_mode == 'video' and mode_value == 'random' %}selected{% endif %}>Random (Video)</option>
                <option value="specific" data-category="video" {% if media_mode == 'video' and mode_value == 'specific' %}selected{% endif %}>Specific (Video)</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Folder Selection -->
        <div class="form-row folder-row" {% if media_mode in ['livestream', 'ai'] %} style="display:none;" {% endif %}>
          <label for="folder-{{ stream_id }}">Folder</label>
          {% set current_folder = conf.folder if conf.folder else 'all' %}
          {% set hide_nsfw = conf.hide_nsfw|default(False) %}
          <select id="folder-{{ stream_id }}" class="folder-select" data-stream="{{ stream_id }}" data-current-folder="{{ current_folder }}" title="{{ current_folder }}">
            {% if hide_nsfw and current_folder and 'nsfw' in current_folder|lower %}
              <option value="__filtered__" data-filtered="true" title="{{ current_folder }}" selected>Filtered ({{ current_folder }})</option>
            {% endif %}
            {% for entry in folder_inventory %}
              {% set name = entry.name %}
              {% if not (hide_nsfw and 'nsfw' in name|lower) %}
                <option value="{{ name }}" title="{{ name }}" data-has-images="{{ 'true' if entry.has_images else 'false' }}" data-has-videos="{{ 'true' if entry.has_videos else 'false' }}"{% if current_folder == name %} selected{% endif %}>{{ name }}</option>
              {% endif %}
            {% endfor %}
          </select>
        </div>
        <div class="form-row nsfw-row" {% if media_mode == 'livestream' %} style="display:none;" {% endif %}>
          <label for="hide-nsfw-{{ stream_id }}">Hide NSFW</label>
          <label class="toggle inline" title="Hide folders and files containing 'nsfw'">
            <input id="hide-nsfw-{{ stream_id }}" type="checkbox" class="hide-nsfw-toggle" data-stream="{{ stream_id }}" {% if hide_nsfw %}checked{% endif %}>
            <span class="toggle-switch" aria-hidden="true"></span>
          </label>
        </div>
        <div class="form-row tag-row">
          <label for="tags-{{ stream_id }}">Tags</label>
          <div class="tag-editor" data-stream="{{ stream_id }}">
            <div class="tag-chip-list">
              {% for tag in conf.tags|default([]) %}
              <span class="tag-chip" data-tag="{{ tag }}"><span class="tag-label">{{ tag }}</span><button type="button" class="tag-remove" aria-label="Remove {{ tag }}">&times;</button></span>
              {% endfor %}
              <input type="text" id="tags-{{ stream_id }}" class="tag-entry" placeholder="Add tag" list="global-tag-options" autocomplete="off" />
            </div>
          </div>
        </div>
        <!-- Image Quality Selection -->
        <div class="form-row image-quality-row" {% if media_mode in ['livestream', 'video'] %} style="display:none;" {% endif %}>
          <label for="image-quality-{{ stream_id }}">Image Quality</label>
          {% set image_q = (conf.image_quality or 'auto')|lower %}
          <select id="image-quality-{{ stream_id }}" class="image-quality-select" data-stream="{{ stream_id }}">
            <option value="auto" {% if image_q == 'auto' %} selected {% endif %}>Auto (fit display)</option>
            <option value="thumb" {% if image_q == 'thumb' %} selected {% endif %}>Thumb (320px)</option>
            <option value="medium" {% if image_q == 'medium' %} selected {% endif %}>Medium (1024px)</option>
            <option value="full" {% if image_q == 'full' %} selected {% endif %}>Full resolution</option>
          </select>
        </div>

        <!-- Background Blur Controls -->
        {% set blur_enabled = conf.background_blur_enabled|default(False) %}
        {% set blur_amount = conf.background_blur_amount|default(50) %}
        <div class="form-row background-row" {% if media_mode in ['livestream', 'video'] %}style="display:none;"{% endif %}>
          <label for="background-toggle-{{ stream_id }}">Backdrop</label>
          <div class="background-controls">
            <label class="toggle inline">
              <input id="background-toggle-{{ stream_id }}" type="checkbox" class="background-toggle" data-stream="{{ stream_id }}" {% if blur_enabled %}checked{% endif %}>
              <span class="toggle-switch" aria-hidden="true"></span>
              <span class="toggle-label">Blur current media</span>
            </label>
            <div class="background-blur-slider-wrap{% if not blur_enabled %} is-disabled{% endif %}">
              <input type="range" min="0" max="100" class="background-blur-slider" data-stream="{{ stream_id }}" value="{{ blur_amount }}" {% if not blur_enabled %}disabled{% endif %}>
              <span class="background-blur-value">{{ blur_amount }}%</span>
            </div>
          </div>
        </div>

        {% set video_mode = conf.video_playback_mode|default('duration') %}
        <div class="form-row video-mode-row" {% if media_mode != 'video' or mode_value != 'random' %}style="display:none;"{% endif %}>
          <label for="video-mode-{{ stream_id }}">Video Playback</label>
          <select id="video-mode-{{ stream_id }}" class="video-mode-select" data-stream="{{ stream_id }}">
            <option value="duration" {% if video_mode == 'duration' %}selected{% endif %}>Play for duration setting</option>
            <option value="until_end" {% if video_mode == 'until_end' %}selected{% endif %}>Play until video ends</option>
          </select>
        </div>
        {% set video_volume_pct = (conf.video_volume|default(1.0) * 100)|round(0, 'floor') %}
        <div class="form-row playback-controls-row" {% if media_mode != 'video' %}style="display:none;"{% endif %}>
          <label>Playback Controls</label>
          <div class="playback-controls" data-stream="{{ stream_id }}">
            <button type="button" class="playback-btn playback-prev" data-stream="{{ stream_id }}" data-action="skip_prev" title="Previous">&#9664;</button>
            <button type="button" class="playback-btn playback-play" data-stream="{{ stream_id }}" data-action="play" title="Play">&#9654;</button>
            <button type="button" class="playback-btn playback-pause" data-stream="{{ stream_id }}" data-action="pause" title="Pause">&#10074;&#10074;</button>
            <button type="button" class="playback-btn playback-next" data-stream="{{ stream_id }}" data-action="skip_next" title="Next">&#9654;&#9654;</button>
            <label class="volume-control">
              <span>Volume</span>
              <input type="range" min="0" max="100" value="{{ video_volume_pct }}" class="video-volume-slider" data-stream="{{ stream_id }}">
            </label>
          </div>
        </div>



        <!-- Duration + Shuffle (for Random mode) -->
        <div class="form-row duration-container" {% if mode_value != 'random' %} style="display:none;" {% endif %}>
          <label for="duration-{{ stream_id }}">Duration (sec)</label>
          <div class="inline-controls">
            <input id="duration-{{ stream_id }}" type="number" class="duration-input" data-stream="{{ stream_id }}" value="{{ conf.duration }}" min="1" style="max-width: 110px;">
            <label class="toggle inline" title="Randomize order each time"><input type="checkbox" class="shuffle-chk" data-stream="{{ stream_id }}" {% if conf.shuffle %} checked {% endif %}><span class="toggle-switch"></span><span class="toggle-label">Shuffle</span></label>
          </div>
        </div>

        <!-- Stream URL -->
        <div class="form-row stream-url-container" {% if media_mode != 'livestream' %} style="display:none;" {% endif %}>
          <label for="stream-url-{{ stream_id }}">URL</label>
          <div>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap: wrap;">
              <input id="stream-url-{{ stream_id }}" type="text" class="stream-url-input" data-stream="{{ stream_id }}" value="{{ conf.stream_url if conf.stream_url else '' }}" placeholder="https://example.com/">
              <span class="url-type-badge" aria-live="polite"></span>
              <span class="embed-status-badge" aria-live="polite"></span>
            </div>
          </div>
        </div>

        <!-- YT Settings -->
        <div class="form-row yt-settings" data-stream="{{ stream_id }}" style="display:none;">
          <details>
            <summary>YouTube Options</summary>
            <div class="inline-controls" style="margin-top: .4rem;">
              <label class="toggle inline" title="Closed Captions"><input type="checkbox" class="yt-cc-chk" data-stream="{{ stream_id }}" {% if conf.yt_cc %} checked {% endif %}><span class="toggle-switch"></span><span class="toggle-label">CC</span></label>
              <label class="toggle inline" title="Start muted"><input type="checkbox" class="yt-mute-chk" data-stream="{{ stream_id }}" {% if conf.yt_mute %} checked {% endif %}><span class="toggle-switch"></span><span class="toggle-label">Mute</span></label>
              <label for="yt-quality-{{ stream_id }}">Quality</label>
              {% set q = (conf.yt_quality or 'auto') %}
              <select id="yt-quality-{{ stream_id }}" class="yt-quality-select" data-stream="{{ stream_id }}">
                {% for opt in ['auto','1080p','720p','480','360p','240p','144p'] %}
                  <option value="{{ opt }}" {% if q|lower == opt|lower %} selected {% endif %}>{{ opt|upper }}</option>
                {% endfor %}
              </select>
            </div>
          </details>
        </div>
        {% set ai = conf.ai_settings or {} %}
        {% set ai_state = conf.ai_state or {} %}
        {% set auto_mode = (ai.auto_generate_mode or 'off')|lower %}
        {% set auto_interval_value = ai.auto_generate_interval_value|default(10) %}
        {% set auto_interval_str = '{:g}'.format((auto_interval_value|float)) %}
        {% set auto_interval_unit = (ai.auto_generate_interval_unit or 'minutes')|lower %}
        {% set auto_clock_time = ai.auto_generate_clock_time or '' %}
        {% if auto_mode == 'timer' %}
          {% set auto_unit_label = 'min' if auto_interval_unit == 'minutes' else 'hr' %}
          {% set auto_label = 'Timer (' ~ auto_interval_str ~ ' ' ~ auto_unit_label ~ ')' %}
        {% elif auto_mode == 'clock' %}
          {% set auto_label = 'Clock (' ~ (auto_clock_time if auto_clock_time else '--:--') ~ ')' %}
        {% else %}
          {% set auto_label = 'Off' %}
        {% endif %}
        <div class="ai-summary" data-stream="{{ stream_id }}" {% if conf.mode != 'ai' %} style="display:none;" {% endif %}>
          <div class="ai-summary-grid">
            <div class="ai-summary-item"><span class="ai-summary-label">Model</span><span class="ai-summary-value ai-summary-model">{{ ai.model or 'Auto' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Sampler</span><span class="ai-summary-value ai-summary-sampler">{{ ai.sampler or 'k_euler' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Size</span><span class="ai-summary-value ai-summary-size">{{ ai.width or 512 }}x{{ ai.height or 512 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Steps</span><span class="ai-summary-value ai-summary-steps">{{ ai.steps or 30 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">CFG</span><span class="ai-summary-value ai-summary-cfg">{{ ai.cfg_scale or 7.5 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Images</span><span class="ai-summary-value ai-summary-samples">{{ ai.samples or 1 }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">LoRAs</span><span class="ai-summary-value ai-summary-loras">{{ (ai.loras or [])|length }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Post</span><span class="ai-summary-value ai-summary-post">{{ (ai.post_processing or [])|length }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Save</span><span class="ai-summary-value ai-summary-save">{{ 'Yes' if ai.save_output else 'Temp' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Timeout</span><span class="ai-summary-value ai-summary-timeout">{{ ai.timeout if ai.timeout and ai.timeout > 0 else 'No limit' }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Auto</span><span class="ai-summary-value ai-summary-auto">{{ auto_label }}</span></div>
            <div class="ai-summary-item"><span class="ai-summary-label">Next</span><span class="ai-summary-value ai-summary-next">{{ ai_state.next_auto_trigger or '&mdash;' }}</span></div>
          </div>
          <div class="ai-summary-actions">
            <button type="button" class="ai-open-settings" data-stream="{{ stream_id }}">Settings</button>
            <button type="button" class="ai-generate-btn" data-stream="{{ stream_id }}">Queue Images</button>
            <button type="button" class="ai-cancel-btn" data-stream="{{ stream_id }}" hidden>Cancel</button>
            <span class="ai-status" data-stream="{{ stream_id }}" data-status="{{ ai_state.status or 'idle' }}">{{ ai_state.status|default('idle')|capitalize }}</span>
          </div>
        </div>
        <div class="ai-modal-backdrop" data-stream="{{ stream_id }}" hidden></div>
        <div class="ai-generator" data-stream="{{ stream_id }}" data-timeout="{{ ai.timeout if ai.timeout else '' }}" tabindex="-1" role="dialog" aria-modal="true" aria-hidden="true">
          <div class="ai-modal-header">
            <h3>AI Image Settings</h3>
            <button type="button" class="ai-close-settings" aria-label="Close">&times;</button>
          </div>
          <div class="ai-preset-controls" data-stream="{{ stream_id }}">
            <label for="ai-preset-select-{{ stream_id }}">Preset</label>
            <select id="ai-preset-select-{{ stream_id }}" class="ai-preset-select" data-stream="{{ stream_id }}" disabled>
              <option value="" selected>No presets saved</option>
            </select>
            <button type="button" class="ai-preset-save" data-stream="{{ stream_id }}">Save Preset</button>
            <button type="button" class="ai-preset-manage" data-stream="{{ stream_id }}">Manage</button>
          </div>
          {% set sampler_options = ['k_euler','k_euler_a','k_dpmpp_2m','k_dpmpp_2m_sde','k_dpmpp_sde','k_lms','k_heun','k_dpm_2','k_dpm_2_a','k_dpm_fast','k_dpm_adaptive','ddim','plms'] %}
          <label for="ai-prompt-{{ stream_id }}">Prompt</label>
          <textarea id="ai-prompt-{{ stream_id }}" class="ai-prompt-input" data-stream="{{ stream_id }}" rows="3" placeholder="Describe the image you want">{{ ai.prompt or '' }}</textarea>
          <label for="ai-negative-{{ stream_id }}">Negative Prompt</label>
          <textarea id="ai-negative-{{ stream_id }}" class="ai-negative-input" data-stream="{{ stream_id }}" rows="2" placeholder="Things to avoid (optional)">{{ ai.negative_prompt or '' }}</textarea>
          <div class="ai-option-grid">
            <div class="ai-option">
              <label for="ai-model-{{ stream_id }}">Model</label>
              <select id="ai-model-{{ stream_id }}" class="ai-model-select" data-stream="{{ stream_id }}">
                {% if ai.model %}
                <option value="{{ ai.model }}" selected>{{ ai.model }}</option>
                {% else %}
                <option value="" selected>Auto-select</option>
                {% endif %}
              </select>
            </div>
            <div class="ai-option">
              <label for="ai-sampler-{{ stream_id }}">Sampler</label>
              {% set current_sampler = ai.sampler or 'k_euler' %}
              {% set sampler_state = namespace(found=false) %}
              <select id="ai-sampler-{{ stream_id }}" class="ai-sampler-select" data-stream="{{ stream_id }}">
                {% for opt in sampler_options %}
                  {% set selected = (current_sampler|lower == opt|lower) %}
                  {% if selected %}{% set sampler_state.found = True %}{% endif %}
                  <option value="{{ opt }}" {% if selected %}selected{% endif %}>{{ opt }}</option>
                {% endfor %}
                {% if current_sampler and not sampler_state.found %}
                  <option value="{{ current_sampler }}" selected>{{ current_sampler }}</option>
                {% endif %}
              </select>
            </div>
            <div class="ai-option">
              <label for="ai-width-{{ stream_id }}">Width</label>
              <input id="ai-width-{{ stream_id }}" type="number" class="ai-width-input" data-stream="{{ stream_id }}" min="64" max="2048" step="64" value="{{ ai.width or 512 }}">
            </div>
            <div class="ai-option">
              <label for="ai-height-{{ stream_id }}">Height</label>
              <input id="ai-height-{{ stream_id }}" type="number" class="ai-height-input" data-stream="{{ stream_id }}" min="64" max="2048" step="64" value="{{ ai.height or 512 }}">
            </div>
            <div class="ai-option">
              <label for="ai-steps-{{ stream_id }}">Steps</label>
              <input id="ai-steps-{{ stream_id }}" type="number" class="ai-steps-input" data-stream="{{ stream_id }}" min="1" max="100" value="{{ ai.steps or 30 }}">
            </div>
            <div class="ai-option">
              <label for="ai-cfg-{{ stream_id }}">CFG</label>
              <input id="ai-cfg-{{ stream_id }}" type="number" class="ai-cfg-input" data-stream="{{ stream_id }}" step="0.5" min="1" max="20" value="{{ ai.cfg_scale or 7.5 }}">
            </div>
            <div class="ai-option">
              <label for="ai-samples-{{ stream_id }}">Images</label>
              <input id="ai-samples-{{ stream_id }}" type="number" class="ai-samples-input" data-stream="{{ stream_id }}" min="1" max="4" value="{{ ai.samples or 1 }}">
            </div>
            <div class="ai-option">
              <label for="ai-seed-{{ stream_id }}">Seed</label>
              <input id="ai-seed-{{ stream_id }}" type="text" class="ai-seed-input" data-stream="{{ stream_id }}" value="{{ ai.seed or 'random' }}" placeholder="random">
            </div>
          </div>
          <details class="ai-advanced-options" data-stream="{{ stream_id }}">
            <summary>Advanced Options</summary>
            <div class="ai-advanced-grid">
              <div class="ai-advanced-group">
                <label class="toggle compact"><input type="checkbox" class="ai-hires-fix" data-stream="{{ stream_id }}" {% if ai.hires_fix %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Hires Fix</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-karras" data-stream="{{ stream_id }}" {% if ai.karras %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Karras Noise</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-tiling" data-stream="{{ stream_id }}" {% if ai.tiling %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Tiling</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-transparent" data-stream="{{ stream_id }}" {% if ai.transparent %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Transparent BG</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-trusted-workers" data-stream="{{ stream_id }}" {% if ai.trusted_workers %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Trusted Workers</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-validated-backends" data-stream="{{ stream_id }}" {% if ai.validated_backends %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Validated Backends</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-slow-workers" data-stream="{{ stream_id }}" {% if ai.slow_workers %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Allow Slow Workers</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-extra-slow-workers" data-stream="{{ stream_id }}" {% if ai.extra_slow_workers %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Allow Extra Slow</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-disable-batching" data-stream="{{ stream_id }}" {% if ai.disable_batching %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Disable Batching</span></label>
                <label class="toggle compact"><input type="checkbox" class="ai-allow-downgrade" data-stream="{{ stream_id }}" {% if ai.allow_downgrade %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Allow Downgrade</span></label>
              </div>
              <div class="ai-advanced-group">
                <label for="ai-style-{{ stream_id }}">Style Preset</label>
                <input id="ai-style-{{ stream_id }}" type="text" class="ai-style-input" data-stream="{{ stream_id }}" placeholder="Style ID or name" value="{{ ai.style or '' }}">
                <label for="ai-clip-skip-{{ stream_id }}">Clip Skip</label>
                <input id="ai-clip-skip-{{ stream_id }}" type="number" class="ai-clip-skip" data-stream="{{ stream_id }}" min="{{ clip_skip_range[0] }}" max="{{ clip_skip_range[1] }}" step="1" value="{{ ai.clip_skip if ai.clip_skip is not none else '' }}">
                <label for="ai-facefixer-{{ stream_id }}">Face Fix Strength</label>
                <input id="ai-facefixer-{{ stream_id }}" type="number" class="ai-facefixer" data-stream="{{ stream_id }}" min="{{ strength_range[0] }}" max="{{ strength_range[1] }}" step="0.05" value="{{ ai.facefixer_strength if ai.facefixer_strength is not none else '' }}">
                <label for="ai-denoise-{{ stream_id }}">Denoising</label>
                <input id="ai-denoise-{{ stream_id }}" type="number" class="ai-denoise" data-stream="{{ stream_id }}" min="{{ denoise_range[0] }}" max="{{ denoise_range[1] }}" step="0.01" value="{{ ai.denoising_strength if ai.denoising_strength is not none else '' }}">
                <label for="ai-hires-denoise-{{ stream_id }}">Hires Denoise</label>
                <input id="ai-hires-denoise-{{ stream_id }}" type="number" class="ai-hires-denoise" data-stream="{{ stream_id }}" min="{{ denoise_range[0] }}" max="{{ denoise_range[1] }}" step="0.01" value="{{ ai.hires_fix_denoising_strength if ai.hires_fix_denoising_strength is not none else '' }}">
              </div>
            </div>
            <div class="ai-post-processing">
              <div class="section-title">Post Processing</div>
              <div class="post-processing-options">
                {% set selected_post = ai.post_processing or [] %}
                {% for proc in post_processors %}
                  <label class="toggle compact"><input type="checkbox" class="ai-post-proc" data-stream="{{ stream_id }}" value="{{ proc }}" {% if proc in selected_post %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">{{ proc }}</span></label>
                {% endfor %}
              </div>
            </div>
            <div class="ai-lora-section" data-max="{{ max_loras }}">
              <div class="lora-header">
                <span>LoRAs</span>
                <button type="button" class="ai-add-lora" data-stream="{{ stream_id }}">Add</button>
              </div>
              <div class="ai-lora-search">
                <input type="text" class="ai-lora-search-input" placeholder="Search LoRAs on CivitAI (e.g. 'anime style')">
                <button type="button" class="ai-lora-search-btn" data-stream="{{ stream_id }}">Search</button>
                <a href="https://civitai.com/models?types=LORA&sort=Highest%20Rated" class="ai-lora-browse" target="_blank" rel="noopener">Browse</a>
              </div>
              <div class="ai-lora-results" hidden>
                <div class="ai-lora-results-header"></div>
                <div class="ai-lora-results-list"></div>
              </div>
              <div class="ai-lora-list">
                {% for lora in ai.loras or [] %}
                <div class="ai-lora-row">
                  <input type="text" class="ai-lora-name" placeholder="Name or CivitAI ID" value="{{ lora.name }}">
                  <input type="number" class="ai-lora-model" placeholder="Model" step="0.05" min="-5" max="5" value="{{ lora.model if lora.model is not none else '' }}">
                  <input type="number" class="ai-lora-clip" placeholder="Clip" step="0.05" min="-5" max="5" value="{{ lora.clip if lora.clip is not none else '' }}">
                  <input type="text" class="ai-lora-trigger" placeholder="Trigger (optional)" value="{{ lora.inject_trigger or '' }}">
                  <label class="toggle compact ai-lora-flag"><input type="checkbox" class="ai-lora-is-version" {% if lora.is_version %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Version ID</span></label>
                  <button type="button" class="ai-lora-remove">Remove</button>
                </div>
                {% endfor %}
              </div>
              <p class="hint">Up to {{ max_loras }} entries. Strength 1.0 is neutral.</p>
            </div>
          </details>
          <div class="ai-auto-settings" data-stream="{{ stream_id }}">
            <div class="section-title">Auto Generate</div>
            <div class="ai-auto-row">
              <label for="ai-auto-mode-{{ stream_id }}">Mode</label>
              <select id="ai-auto-mode-{{ stream_id }}" class="ai-auto-mode" data-stream="{{ stream_id }}">
                <option value="off" {% if auto_mode == 'off' %}selected{% endif %}>Off</option>
                <option value="timer" {% if auto_mode == 'timer' %}selected{% endif %}>Timer</option>
                <option value="clock" {% if auto_mode == 'clock' %}selected{% endif %}>Clock</option>
              </select>
            </div>
            <div class="ai-auto-row ai-auto-timer-row" {% if auto_mode != 'timer' %}hidden{% endif %}>
              <label for="ai-auto-interval-{{ stream_id }}">Every</label>
              <div class="ai-auto-interval-controls">
                <input id="ai-auto-interval-{{ stream_id }}" type="number" class="ai-auto-interval" data-stream="{{ stream_id }}" min="0.1" step="0.1" value="{{ auto_interval_str }}">
                <select class="ai-auto-interval-unit" data-stream="{{ stream_id }}">
                  <option value="minutes" {% if auto_interval_unit == 'minutes' %}selected{% endif %}>Minutes</option>
                  <option value="hours" {% if auto_interval_unit == 'hours' %}selected{% endif %}>Hours</option>
                </select>
              </div>
            </div>
            <div class="ai-auto-row ai-auto-clock-row" {% if auto_mode != 'clock' %}hidden{% endif %}>
              <label for="ai-auto-clock-{{ stream_id }}">At</label>
              <input id="ai-auto-clock-{{ stream_id }}" type="time" class="ai-auto-clock" data-stream="{{ stream_id }}" value="{{ auto_clock_time }}">
            </div>
            <div class="ai-auto-status">
              <span class="ai-auto-status-label">Next run:</span>
              <span class="ai-auto-next">{{ ai_state.next_auto_trigger or '&mdash;' }}</span>
              <span class="ai-auto-error" {% if not ai_state.last_auto_error %}hidden{% endif %}>{{ ai_state.last_auto_error or '' }}</span>
            </div>
          </div>
          <div class="ai-flags">
            <label class="toggle inline"><input type="checkbox" class="ai-save-output" data-stream="{{ stream_id }}" {% if ai.save_output %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Save to library</span></label>
            <label class="toggle inline"><input type="checkbox" class="ai-nsfw" data-stream="{{ stream_id }}" {% if ai.nsfw %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Allow NSFW</span></label>
            <label class="toggle inline"><input type="checkbox" class="ai-censor" data-stream="{{ stream_id }}" {% if ai.censor_nsfw %}checked{% endif %}><span class="toggle-switch"></span><span class="toggle-label">Censor NSFW</span></label>
          </div>
          <div class="ai-modal-actions">
            <button type="button" class="ai-generate-btn" data-stream="{{ stream_id }}">Queue Images</button>
            <button type="button" class="ai-cancel-btn" data-stream="{{ stream_id }}" hidden>Cancel</button>
            <button type="button" class="ai-close-settings-secondary">Close</button>
          </div>
          <div class="ai-results" data-stream="{{ stream_id }}" data-selected="{{ conf.selected_image or '' }}">
            <div class="ai-generated-grid">
              {% for img in ai_state.images or [] %}
              <div class="ai-generated-item" data-path="{{ img.path }}" data-persisted="{{ 'true' if img.persisted else 'false' }}">
                <img src="/stream/image/{{ img.path }}" alt="Generated image {{ loop.index }}">
                <div class="ai-generated-meta">
                  {% if img.model %}<span class="ai-model-tag">{{ img.model }}</span>{% endif %}
                  {% if img.seed %}<span class="ai-seed-tag">#{{ img.seed }}</span>{% endif %}
                </div>
              </div>
              {% endfor %}
            </div>
            <div class="ai-generated-empty" {% if ai_state.images %}style="display:none;"{% endif %}>No generated images yet.</div>
          </div>
        </div>
      </div>
      <!-- Specific Image Picker -->
      <div class="image-picker" data-stream="{{ stream_id }}" {% if mode_value != 'specific' %} style="display:none;" {% endif %}>
        <div class="image-picker-header">
          <label>Pick Media (Folder: {{ conf.folder }})</label>
          <button type="button" class="reload-images-btn" data-stream="{{ stream_id }}">Reload</button>
        </div>
        <div class="image-grid"></div>
      </div>

      <p class="selected-image-row" {% if mode_value not in ['specific', 'ai'] %} style="display:none;" {% endif %}>
        <strong>Selected Media:</strong>
        <span class="selected-image-display">{{ conf.selected_image if conf.selected_image else "None" }}{% if conf.selected_media_kind == 'video' and conf.selected_image %} (video){% endif %}</span>
      </p>
    </div>
    {% endfor %}
  </div>
</div>

<!-- Notification -->
<div id="notification" class="notification">Settings updated!</div>

<!-- Floating Notes Pad -->
<div id="notepad" class="notepad collapsed">
  <div class="notepad-header">
    <span>Notes</span>
    <button id="toggle-notepad">Toggle</button>
  </div>
  <textarea id="notepad-text"></textarea>
  <button id="save-notes">Save</button>
</div>

  <div id="ai-preset-manager-backdrop" class="ai-preset-manager-backdrop" hidden></div>
  <div id="ai-preset-manager" class="ai-preset-manager" role="dialog" aria-modal="true" aria-labelledby="ai-preset-manager-title" hidden>
    <div class="ai-preset-manager-content">
      <div class="ai-preset-manager-header">
        <h3 id="ai-preset-manager-title">Preset Manager</h3>
        <button type="button" class="ai-preset-manager-close" aria-label="Close">&times;</button>
      </div>
      <div class="ai-preset-manager-body">
        <p class="ai-preset-empty" hidden>No presets saved.</p>
        <ul class="ai-preset-list"></ul>
      </div>
    </div>
  </div>
<script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
<script>
  // Theme toggle (sun/moon)
  (function(){
    const root = document.documentElement;
    const btn = document.getElementById('theme-toggle');
    function apply(theme){
      const t = (theme === 'light') ? 'light' : 'dark';
      root.setAttribute('data-theme', t);
      if (btn) btn.textContent = t === 'light' ? '\u2600' : '\u263D';
    }
    const saved = localStorage.getItem('theme') || 'dark';
    apply(saved);
    if (btn) btn.addEventListener('click', () => {
      const cur = root.getAttribute('data-theme') === 'light' ? 'light' : 'dark';
      const next = cur === 'light' ? 'dark' : 'light';
      apply(next);
      try { localStorage.setItem('theme', next); } catch(e){}
    });
  })();

  const socket = io();
  let openAiCard = null;
  const aiSummaryUpdaters = new WeakMap();

  function openAiSettings(card) {
    if (!card) return;
    const updater = aiSummaryUpdaters.get(card);
    if (updater) updater();
    const aiSection = card.querySelector('.ai-generator');
    if (!aiSection) return;
    const backdrop = card.querySelector('.ai-modal-backdrop');
    if (openAiCard && openAiCard !== card) {
      closeAiSettings(openAiCard);
    }
    card.classList.add('ai-settings-open');
    if (backdrop) backdrop.hidden = false;
    aiSection.setAttribute('aria-hidden', 'false');
    if (typeof aiSection.focus === 'function') {
      try {
        aiSection.focus({ preventScroll: true });
      } catch (err) {
        aiSection.focus();
      }
    }
    openAiCard = card;
    document.body.classList.add('ai-modal-active');
  }

  function closeAiSettings(card) {
    if (!card) return;
    const aiSection = card.querySelector('.ai-generator');
    const backdrop = card.querySelector('.ai-modal-backdrop');
    card.classList.remove('ai-settings-open');
    if (backdrop) backdrop.hidden = true;
    if (aiSection) {
      aiSection.setAttribute('aria-hidden', 'true');
    }
    if (openAiCard === card) {
      openAiCard = null;
    }
    if (!openAiCard) {
      document.body.classList.remove('ai-modal-active');
    }
  }

  document.addEventListener('keydown', e => {
    if (e.key !== 'Escape') return;
    if (presetManagerModal && !presetManagerModal.hidden) {
      e.preventDefault();
      closePresetManager();
      return;
    }
    if (openAiCard) {
      e.preventDefault();
      closeAiSettings(openAiCard);
    }
  });

  const notification = document.getElementById('notification');
  const addStreamBtn = document.getElementById('add-stream');
  const openMosaicBtn = document.getElementById('open-mosaic');
  const mosaicLayoutSel = document.getElementById('mosaic-layout-select');
  const mosaicColsInput = document.getElementById('mosaic-cols-input');
  
  // Group Manager elements
  const groupTiles = document.getElementById('group-tiles');

  const dashboardGrid = document.getElementById('dashboard-grid');
  const tagFilterChips = document.getElementById('tag-filter-chips');
  const tagFilterInput = document.getElementById('tag-filter-input');
  const sortSelect = document.getElementById('sort-select');
  const tagManagerList = document.getElementById('tag-manager-list');
  const newTagInput = document.getElementById('new-tag-input');
  const createTagBtn = document.getElementById('create-tag-btn');
  const tagDatalist = document.getElementById('global-tag-options');

  // Build a set of taken stream name slugs for client-side validation
  const takenSlugs = {};
  {% for sid, conf in stream_settings.items() %}
  takenSlugs['{{ (conf.label if conf.label else sid)|slugify }}'] = '{{ sid }}';
  {% endfor %}

  const initialGlobalTags = {{ global_tags|tojson }};
  const globalTagState = {
    list: Array.isArray(initialGlobalTags) ? initialGlobalTags.slice() : [],
    map: new Map()
  };
  globalTagState.list.forEach(tag => {
    if (typeof tag === 'string') {
      globalTagState.map.set(tag.toLowerCase(), tag);
    }
  });
  const cardTagsMap = new Map();
  const activeTagFilters = [];
  let currentSortMode = 'default';

  function showNotification(msg) {
    notification.textContent = msg;
    notification.classList.add('show');
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }

  // No layout settings for global /stream; it adapts dynamically

  if (openMosaicBtn) {
    openMosaicBtn.addEventListener('click', () => {
      window.open('/stream', '_blank');
    });
  }

  // Mosaic controls
  function updateMosaicControlsVisibility() {
    if (!mosaicLayoutSel || !mosaicColsInput) return;
    const layout = mosaicLayoutSel.value;
    const colsLabel = document.getElementById('mosaic-cols-label');
    const showCols = layout === 'grid';
    mosaicColsInput.style.display = showCols ? 'inline-block' : 'none';
    if (colsLabel) colsLabel.style.display = showCols ? 'inline' : 'none';
  }
  function saveMosaic() {
    if (!mosaicLayoutSel) return;
    const payload = { layout: mosaicLayoutSel.value };
    if (payload.layout === 'grid' && mosaicColsInput) {
      payload.cols = parseInt(mosaicColsInput.value || '2', 10);
    }
    fetch('/mosaic-settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
      .then(r => r.json())
      .then(() => showNotification('Mosaic updated'))
      .catch(() => showNotification('Failed to update mosaic'));
  }
  if (mosaicLayoutSel) {
    mosaicLayoutSel.addEventListener('change', () => { updateMosaicControlsVisibility(); saveMosaic(); });
  }
  if (mosaicColsInput) {
    mosaicColsInput.addEventListener('change', saveMosaic);
  }
  updateMosaicControlsVisibility();

  function normalizeTagInput(value) {
    if (typeof value !== 'string') {
      return '';
    }
    const cleaned = value.replace(/s+/g, ' ').trim();
    if (!cleaned) {
      return '';
    }
    return cleaned.length > 48 ? cleaned.slice(0, 48).trim() : cleaned;
  }

  function tagsEqual(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every((tag, idx) => (tag || '').toLowerCase() === (b[idx] || '').toLowerCase());
  }

  function getCardTags(card) {
    if (!card) {
      return [];
    }
    const raw = card.dataset.tags;
    if (!raw) {
      return [];
    }
    try {
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed.filter(t => typeof t === 'string') : [];
    } catch (err) {
      return [];
    }
  }

  function setCardTags(card, tags) {
    if (!card) {
      return [];
    }
    const cleaned = Array.isArray(tags) ? tags.filter(t => typeof t === 'string') : [];
    card.dataset.tags = JSON.stringify(cleaned);
    cardTagsMap.set(card, cleaned.slice());
    const chipList = card.querySelector('.tag-chip-list');
    if (chipList) {
      const input = chipList.querySelector('.tag-entry');
      chipList.querySelectorAll('.tag-chip').forEach(chip => chip.remove());
      const frag = document.createDocumentFragment();
      cleaned.forEach(tag => {
        const canonical = globalTagState.map.get(tag.toLowerCase()) || tag;
        const chip = document.createElement('span');
        chip.className = 'tag-chip';
        chip.dataset.tag = canonical;
        const label = document.createElement('span');
        label.className = 'tag-label';
        label.textContent = canonical;
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'tag-remove';
        removeBtn.setAttribute('aria-label', `Remove ${canonical}`);
        removeBtn.innerHTML = '&times;';
        removeBtn.addEventListener('click', () => {
          const current = getCardTags(card);
          const next = current.filter(existing => existing.toLowerCase() !== canonical.toLowerCase());
          if (!tagsEqual(current, next)) {
            requestTagUpdate(card, next);
          }
        });
        chip.appendChild(label);
        chip.appendChild(removeBtn);
        frag.appendChild(chip);
      });
      if (input) {
        chipList.insertBefore(frag, input);
      } else {
        chipList.appendChild(frag);
      }
    }
    return cleaned;
  }

  function requestTagUpdate(card, nextTags) {
    if (!card) {
      return;
    }

  // Group manager logic
  function makeEl(tag, attrs = {}, children = []) {
    const e = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v]) => { if (k==='class') e.className=v; else if (k==='style') e.style.cssText=v; else e.setAttribute(k,v); });
    children.forEach(c => e.appendChild(typeof c==='string' ? document.createTextNode(c) : c));
    return e;
  }

  // Simple client-side URL type detection so users know what will embed
  function detectUrlType(url) {
    if (!url) return '';
    const u = (url||'').toLowerCase();
    if (u.includes('youtube.com') || u.includes('youtu.be/')) return 'YouTube';
    if (u.includes('twitch.tv/')) return 'Twitch';
    if (u.endsWith('.m3u8') || u.endsWith('.mpd')) return 'HLS';
    if (u.startsWith('http://') || u.startsWith('https://')) return 'Website';
    return '';
  }
  // Persist expanded/collapsed tile state
  function getOpenSet() {
    try { return new Set(JSON.parse(localStorage.getItem('gmOpen') || '[]')); } catch { return new Set(); }
  }
  function setOpenSet(s) { try { localStorage.setItem('gmOpen', JSON.stringify(Array.from(s))); } catch {} }
  function markOpen(name, open) {
    if (!name) return; // only persist named groups
    const s = getOpenSet();
    if (open) s.add(name); else s.delete(name);
    setOpenSet(s);
  }
  let gmOpenSet = new Set();
  let gmCurrentGroups = {};
  function loadOpenSet() {
    try { gmOpenSet = new Set(JSON.parse(localStorage.getItem('gmOpen') || '[]')); } catch (e) { gmOpenSet = new Set(); }
  }
  function persistOpenSet() {
    try { localStorage.setItem('gmOpen', JSON.stringify(Array.from(gmOpenSet))); } catch (e) {}
  }
  function markOpen(name, open) {
    if (!name) return;
    if (open) gmOpenSet.add(name); else gmOpenSet.delete(name);
    persistOpenSet();
  }
  function isOpen(name) { return name && gmOpenSet.has(name); }

  async function loadGroupsUI() {
    try {
      loadOpenSet();
      const [streamsMeta, groupsData] = await Promise.all([
        fetch('/streams_meta').then(r=>r.json()),
        fetch('/groups').then(r=>r.json())
      ]);
      const groups = groupsData || {};
      gmCurrentGroups = groups;
      // Build tiles
      if (groupTiles) {
        groupTiles.innerHTML = '';
        // Add tile
        const addTile = makeEl('div', {class:'group-tile add'}, [
          makeEl('div', {class:'tile-header'}, ['+ New Group'])
        ]);
        addTile.addEventListener('click', () => {
          const tile = createGroupTile(streamsMeta, groups, null);
          groupTiles.prepend(tile);
          // open editor immediately
          const body = tile.querySelector('.tile-body');
          if (body) body.hidden = false;
          tile.classList.add('expanded');
          const nameInput = tile.querySelector('.tile-name');
          if (nameInput) nameInput.focus();
        });
        groupTiles.appendChild(addTile);

        // Existing group tiles
        Object.keys(groups).forEach(name => {
          groupTiles.appendChild(createGroupTile(streamsMeta, groups, name));
        });
      }
    } catch (e) { console.error('Failed to load groups UI', e); }
  }
  function selectedIds(container) {
    return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map(c=>c.value);
  }
  function createGroupTile(streamsMeta, groups, name) {
    const gdata = name ? (groups[name]||[]) : [];
    const initial = Array.isArray(gdata) ? gdata.slice() : ((gdata?.streams || []).slice());
    const order = Array.isArray(initial) ? initial.slice() : [];
    const members = new Set(order);
    const gLayout = Array.isArray(gdata) ? {} : (gdata?.layout || {});
    const isNew = !name;
    const tile = makeEl('div', {class:'group-tile'}, []);
    const header = makeEl('div', {class:'tile-header'}, []);
    const title = makeEl('span', {class:'tile-title'}, [name || 'New Group']);
    const actions = makeEl('div', {class:'tile-actions'}, []);
    const open = name ? makeEl('a', {href:`/stream/group/${encodeURIComponent(name)}`, target:'_blank'}, ['Open']) : null;
    const edit = makeEl('button', {class:'tile-edit'}, ['Edit']);
    const del = name ? makeEl('button', {class:'tile-del'}, ['Delete']) : null;
    if (open) actions.appendChild(open);
    actions.appendChild(edit);
    if (del) actions.appendChild(del);
    header.appendChild(title);
    header.appendChild(actions);
    tile.appendChild(header);
    const body = makeEl('div', {class:'tile-body', hidden: !isOpen(name)}, []);
    if (isOpen(name)) tile.classList.add('expanded');
    const nameRow = makeEl('div', {class:'tile-row'}, [
      makeEl('label', {}, ['Name: ', makeEl('input', {type:'text', class:'tile-name', value: name || ''}, [])])
    ]);
    body.appendChild(nameRow);
    // Layout selection + visual gallery
    const layoutRow = makeEl('div', {class:'tile-row'}, []);
    const layoutSelect = makeEl('select', {class:'tile-layout'}, []);
    ['grid','focus','pip'].forEach(opt => {
      const o = makeEl('option', {value:opt}, [opt.charAt(0).toUpperCase()+opt.slice(1)]);
      layoutSelect.appendChild(o);
    });
    layoutRow.appendChild(makeEl('label', {}, ['Layout: ', layoutSelect]));
    const colsInput = makeEl('input', {type:'number', min:'1', max:'8', class:'tile-cols', value: gLayout.cols || 2}, []);
    const colsWrap = makeEl('span', {class:'tile-cols-wrap'}, [' Cols: ', colsInput]);
    layoutRow.appendChild(colsWrap);
    const rowsInput = makeEl('input', {type:'number', min:'1', max:'8', class:'tile-rows', value: gLayout.rows || 2}, []);
    const rowsWrap = makeEl('span', {class:'tile-rows-wrap'}, [' Rows: ', rowsInput]);
    layoutRow.appendChild(rowsWrap);
    // Focus options
    const focusWrap = makeEl('div', {class:'tile-pip-wrap', style:'display:none;'}, []);
    const focusMode = makeEl('select', {class:'tile-focus-mode'}, []);
    ['1-2','1-3','1-5'].forEach(v => focusMode.appendChild(makeEl('option', {value:v}, [v.replace('-', ' + ')])));
    const focusPos = makeEl('select', {class:'tile-focus-pos'}, []);
    const focusMain = makeEl('select', {class:'tile-focus-main'}, []);
    const fRow1 = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Focus: ']), focusMode ]);
    const fRow2 = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Placement: ']), focusPos ]);
    const fRow3 = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Main: ']), focusMain ]);
    focusWrap.appendChild(fRow1); focusWrap.appendChild(fRow2); focusWrap.appendChild(fRow3);
    layoutRow.appendChild(focusWrap);
    // PIP options
    const pipWrap = makeEl('div', {class:'tile-pip-wrap', style:'display:none;'}, []);
    const pipMain = makeEl('select', {class:'tile-pip-main'}, []);
    const pipPip = makeEl('select', {class:'tile-pip-pip'}, []);
    const pipCorner = makeEl('select', {class:'tile-pip-corner'}, []);
    ['top-left','top-right','bottom-left','bottom-right'].forEach(c => pipCorner.appendChild(makeEl('option', {value:c}, [c])));
    const pipSize = makeEl('input', {type:'number', min:'10', max:'50', class:'tile-pip-size', value: gLayout.pip_size || 25}, []);
    const rowMain = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Main: ']), pipMain ]);
    const rowPip = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['PIP: ']), pipPip ]);
    const rowCorner = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Corner: ']), pipCorner ]);
    const rowSize = makeEl('div', {class:'pip-row'}, [ makeEl('label', {}, ['Size: ']), pipSize ]);
    pipWrap.appendChild(rowMain);
    pipWrap.appendChild(rowPip);
    pipWrap.appendChild(rowCorner);
    pipWrap.appendChild(rowSize);
    layoutRow.appendChild(pipWrap);
    body.appendChild(layoutRow);

    // Visual layout gallery
    const gallery = makeEl('div', {class:'layout-gallery'}, []);
    function buildGridPreview(rows, cols) {
      const p = makeEl('div', {class:'layout-preview'}, []);
      p.style.display = 'grid';
      p.style.gridTemplateColumns = `repeat(${Math.max(1, cols)}, 1fr)`;
      p.style.gridTemplateRows = `repeat(${Math.max(1, rows)}, 1fr)`;
      const n = Math.max(rows*cols, 4);
      for (let i=0;i<n;i++) p.appendChild(makeEl('div', {class:'cell'}, []));
      return p;
    }
    function buildFocusPreview(mode, pos) {
      // produce a small grid preview based on mode/pos
      if (mode === '1-2') {
        const p = makeEl('div', {class:'layout-preview'}, []);
        p.style.display = 'grid'; p.style.gridTemplateColumns='repeat(2,1fr)'; p.style.gridTemplateRows='repeat(2,1fr)';
        const order = (pos==='right') ? ['a','main','b','main'] : ['main','a','main','b'];
        order.forEach(()=>p.appendChild(makeEl('div',{class:'cell'},[])));
        // tint main cells
        Array.from(p.children).forEach((c,i)=>{ if (order[i]==='main') c.style.background='#262626'; });
        return p;
      }
      if (mode === '1-3') {
        const p = makeEl('div', {class:'layout-preview'}, []);
        p.style.display='grid'; p.style.gridTemplateColumns='repeat(3,1fr)'; p.style.gridTemplateRows='repeat(2,1fr)';
        const top = (pos==='top');
        const order = top ? ['m','m','m','a','b','c'] : ['a','b','c','m','m','m'];
        order.forEach(()=>p.appendChild(makeEl('div',{class:'cell'},[])));
        Array.from(p.children).forEach((c,i)=>{ if (order[i]==='m') c.style.background='#262626'; });
        return p;
      }
      // 1-5 default
      const p = makeEl('div', {class:'layout-preview'}, []);
      p.style.display='grid'; p.style.gridTemplateColumns='repeat(3,1fr)'; p.style.gridTemplateRows='repeat(3,1fr)';
      let mat;
      switch(pos){
        case 'top-left': mat=[[1,1,0],[1,1,0],[0,0,0]]; break;
        case 'top-right': mat=[[0,1,1],[0,1,1],[0,0,0]]; break;
        case 'bottom-left': mat=[[0,0,0],[1,1,0],[1,1,0]]; break;
        default: mat=[[0,0,0],[0,1,1],[0,1,1]]; // bottom-right
      }
      for (let r=0;r<3;r++) for (let c=0;c<3;c++) {
        const cell = makeEl('div',{class:'cell'},[]);
        if (mat[r][c]===1) cell.style.background='#262626';
        p.appendChild(cell);
      }
      return p;
    }
    function buildPipPreview() {
      const p = makeEl('div', {class:'layout-preview'}, []);
      const main = makeEl('div', {class:'cell'}, []); main.style.height = '100%'; main.style.width='100%';
      main.style.background = '#1d1d1d';
      const pip = makeEl('div', {class:'cell'}, []);
      pip.style.position='absolute'; pip.style.width='35%'; pip.style.height='35%'; pip.style.right='6%'; pip.style.bottom='6%'; pip.style.background='#262626';
      p.appendChild(main); p.appendChild(pip);
      return p;
    }
    function addOption(kind, label, onPick, builder) {
      const opt = makeEl('div', {class:'layout-option', 'data-kind': kind}, []);
      const preview = builder ? builder() : makeEl('div', {class:'layout-preview'}, []);
      opt.appendChild(preview);
      opt.appendChild(makeEl('span', {class:'caption'}, [label]));
      opt.addEventListener('click', () => { onPick(); setActive(kind); });
      gallery.appendChild(opt);
      return opt;
    }
    function setActive(kind) {
      gallery.querySelectorAll('.layout-option').forEach(o => o.classList.toggle('active', o.dataset.kind===kind));
    }
    const gridOpt = addOption('grid', 'Grid', () => { layoutSelect.value='grid'; updateLayoutVisibility(); }, () => buildGridPreview(parseInt(rowsInput.value||'2',10), parseInt(colsInput.value||'2',10)));
    const focusOpt = addOption('focus', 'Focus', () => { layoutSelect.value='focus'; updateLayoutVisibility(); }, () => buildFocusPreview(focusMode.value||'1-5', focusPos.value||'bottom-right'));
    const pipOpt = addOption('pip', 'PiP', () => { layoutSelect.value='pip'; updateLayoutVisibility(); }, () => buildPipPreview());
    body.appendChild(gallery);
    function syncActiveFromInputs() {
      const v = layoutSelect.value;
      if (v==='grid') setActive('grid'); else setActive(v);
      // update grid preview on change
      const oldPrev = gridOpt.querySelector('.layout-preview');
      const newPrev = buildGridPreview(parseInt(rowsInput.value||'2',10), parseInt(colsInput.value||'2',10));
      gridOpt.replaceChild(newPrev, oldPrev);
      // update focus preview on change
      const oldF = focusOpt.querySelector('.layout-preview');
      const newF = buildFocusPreview(focusMode.value||'1-5', focusPos.value||'bottom-right');
      focusOpt.replaceChild(newF, oldF);
      refreshChips();
    }
    layoutSelect.addEventListener('change', syncActiveFromInputs);
    colsInput.addEventListener('change', syncActiveFromInputs);
    rowsInput.addEventListener('change', syncActiveFromInputs);
    focusMode.addEventListener('change', () => { updateLayoutVisibility(); syncActiveFromInputs(); refreshFocusPosOptions(); });
    focusPos.addEventListener('change', syncActiveFromInputs);

    function refreshFocusPosOptions() {
      // update placement options according to mode
      const mode = focusMode.value;
      focusPos.innerHTML = '';
      let opts = [];
      if (mode === '1-2') opts = ['left','right'];
      else if (mode === '1-3') opts = ['top','bottom'];
      else opts = ['top-left','top-right','bottom-left','bottom-right'];
      opts.forEach(v => focusPos.appendChild(makeEl('option',{value:v},[v.replace('-', ' ')])));
      // select from gLayout or defaults
      const desired = gLayout.focus_pos || opts[opts.length-1];
      Array.from(focusPos.options).forEach(o => o.selected = (o.value===desired));
    }
    // Bulk row (Add all / Remove all) above the combo
    const bulkRow = makeEl('div', {class:'tile-row tile-bulk-row'}, []);
    const addAllBtn = makeEl('button', {class:'tile-addall-btn', type:'button'}, ['Add all']);
    const removeAllBtn = makeEl('button', {class:'tile-removeall-btn', type:'button'}, ['Remove all']);
    bulkRow.appendChild(addAllBtn);
    bulkRow.appendChild(removeAllBtn);
    body.appendChild(bulkRow);
    // Add row with combined search/select + Add
    const addRow = makeEl('div', {class:'tile-row tile-add-row'}, []);
    const dlId = `dl-${Math.random().toString(36).slice(2)}`;
    const combo = makeEl('input', {type:'text', class:'tile-combo', placeholder:'Search or select...', list: dlId}, []);
    const datalist = makeEl('datalist', {id: dlId}, []);
    const addBtn = makeEl('button', {class:'tile-add-btn', type:'button'}, ['Add']);
    addRow.appendChild(combo);
    addRow.appendChild(addBtn);
    body.appendChild(addRow);
    body.appendChild(datalist);
    // Chips container for current members
    const chips = makeEl('div', {class:'member-chips'}, []);
    body.appendChild(chips);
    // helpers to refresh UI
    function labelOf(id) { return (streamsMeta[id]?.label || id) + ''; }
    function candidates(query) {
      const q = (query||'').toLowerCase();
      return Object.keys(streamsMeta)
        .filter(id => !members.has(id))
        .filter(id => labelOf(id).toLowerCase().includes(q))
        .sort((a,b) => labelOf(a).localeCompare(labelOf(b)));
    }
    function refreshTitleCount() {
      const count = members.size;
      title.textContent = (tile.querySelector('.tile-name')?.value?.trim() || name || 'New Group') + ` (${count})`;
    }
    function refreshPipSelects() {
      const mem = order.slice();
      let mainSel = gLayout.pip_main && members.has(gLayout.pip_main) ? gLayout.pip_main : (mem[0] || '');
      let pipSel = gLayout.pip_pip && members.has(gLayout.pip_pip) ? gLayout.pip_pip : (mem.find(x=>x!==mainSel) || '');
      // ensure different
      if (pipSel === mainSel) pipSel = mem.find(x=>x!==mainSel) || '';
      // fill main
      pipMain.innerHTML = '';
      mem.forEach(id => {
        const o = makeEl('option', {value:id}, [labelOf(id)]);
        if (id === mainSel) o.selected = true;
        // prevent selecting pip in main as well
        if (id === pipSel) o.disabled = true;
        pipMain.appendChild(o);
      });
      // fill pip (disable main selection)
      pipPip.innerHTML = '';
      mem.forEach(id => {
        const o = makeEl('option', {value:id}, [labelOf(id)]);
        if (id === pipSel) o.selected = true;
        if (id === mainSel) o.disabled = true;
        pipPip.appendChild(o);
      });
      // corner and size
      Array.from(pipCorner.options).forEach(opt => opt.selected = (opt.value === (gLayout.pip_corner || 'bottom-right')));
      pipSize.value = gLayout.pip_size || 25;
    }
    function refreshFocusMainOptions() {
      const mem = Array.from(members);
      focusMain.innerHTML = '';
      mem.forEach(id => {
        const o = makeEl('option', {value:id}, [labelOf(id)]);
        focusMain.appendChild(o);
      });
      const desired = gLayout.focus_main && members.has(gLayout.focus_main) ? gLayout.focus_main : (mem[0] || '');
      Array.from(focusMain.options).forEach(o => o.selected = (o.value===desired));
    }
    function updateLayoutVisibility() {
      const v = layoutSelect.value;
      colsWrap.style.display = (v==='grid') ? '' : 'none';
      rowsWrap.style.display = (v==='grid') ? '' : 'none';
      focusWrap.style.display = (v==='focus') ? '' : 'none';
      pipWrap.style.display = (v==='pip') ? '' : 'none';
      if (v==='pip') refreshPipSelects();
      refreshChips();
    }
    function refreshDatalist() {
      datalist.innerHTML = '';
      candidates(combo.value).forEach(id => {
        datalist.appendChild(makeEl('option', {value: labelOf(id)}, []));
      });
    }
    function capacityForLayout() {
      const v = layoutSelect.value;
      if (v==='grid') {
        const r = parseInt(rowsInput.value||'');
        const c = parseInt(colsInput.value||'');
        if (Number.isFinite(r) && Number.isFinite(c) && r>0 && c>0) return r*c;
        return Infinity;
      }
      if (v==='focus') {
        const m = (focusMode.value||'1-5');
        if (m==='1-2') return 3; if (m==='1-3') return 4; return 6;
      }
      if (v==='pip') return 2;
      return Infinity;
    }
    let draggingId = null;
    function refreshChips() {
      chips.innerHTML = '';
      const list = makeEl('ul', {class:'member-list'}, []);
      const cap = capacityForLayout();
      order.forEach((id, idx) => {
        const li = makeEl('li', {class:'member-item' + (idx >= cap ? ' overflow' : '')}, []);
        li.setAttribute('draggable', 'true');
        li.dataset.id = id;
        const nameSpan = makeEl('span', {class:'member-name'}, [labelOf(id)]);
        const rm = makeEl('button', {class:'member-remove', title:'Remove'}, ['Remove']);
        rm.addEventListener('click', () => {
          members.delete(id);
          const i = order.indexOf(id); if (i>=0) order.splice(i,1);
          refreshDatalist();
          refreshChips();
          refreshPipSelects();
          refreshFocusMainOptions();
        });
        li.addEventListener('dragstart', (e) => {
          draggingId = id;
          try { e.dataTransfer.setData('text/plain', id); } catch {}
          e.dataTransfer.effectAllowed = 'move';
        });
        li.addEventListener('dragover', (e) => {
          e.preventDefault();
          const rect = li.getBoundingClientRect();
          const before = (e.clientY - rect.top) < rect.height/2;
          li.classList.toggle('drag-over-top', before);
          li.classList.toggle('drag-over-bottom', !before);
        });
        li.addEventListener('dragleave', () => {
          li.classList.remove('drag-over-top','drag-over-bottom');
        });
        li.addEventListener('drop', (e) => {
          e.preventDefault();
          li.classList.remove('drag-over-top','drag-over-bottom');
          const fromId = draggingId; draggingId = null;
          if (!fromId || fromId === id) return;
          const fromIdx = order.indexOf(fromId);
          const targetIdx = order.indexOf(id);
          if (fromIdx < 0 || targetIdx < 0) return;
          const rect = li.getBoundingClientRect();
          const before = (e.clientY - rect.top) < rect.height/2;
          // Remove from old spot
          order.splice(fromIdx, 1);
          // Recompute target index after removal
          let insertAt = order.indexOf(id);
          insertAt = before ? insertAt : insertAt + 1;
          order.splice(insertAt, 0, fromId);
          refreshChips();
          refreshPipSelects();
          refreshFocusMainOptions();
        });
        li.addEventListener('dragend', () => {
          const els = list.querySelectorAll('.drag-over-top,.drag-over-bottom');
          els.forEach(el => el.classList.remove('drag-over-top','drag-over-bottom'));
          draggingId = null;
        });
        li.appendChild(nameSpan);
        li.appendChild(rm);
        list.appendChild(li);
      });
      chips.appendChild(list);
      refreshTitleCount();
    }
    // init layout controls
    layoutSelect.value = gLayout.layout || 'grid';
    // initialize focus controls from gLayout
    Array.from(focusMode.options).forEach(o => o.selected = (o.value === (gLayout.focus_mode || '1-5')));
    refreshFocusPosOptions();
    refreshFocusMainOptions();
    updateLayoutVisibility();
    refreshDatalist();
    refreshChips();
    combo.addEventListener('input', refreshDatalist);
    combo.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addBtn.click(); } });
    function resolveSingleSelection() {
      const q = combo.value.trim();
      if (!q) return null;
      // try exact label match first
      const byLabel = candidates('').find(id => labelOf(id).toLowerCase() === q.toLowerCase());
      if (byLabel && !members.has(byLabel)) return byLabel;
      // fallback: if only one candidate matches substring, use it
      const cands = candidates(q);
      if (cands.length === 1) return cands[0];
      // also allow exact id match
      if (!members.has(q) && streamsMeta[q]) return q;
      return null;
    }
    addBtn.addEventListener('click', () => {
      const id = resolveSingleSelection();
      if (!id) return;
      members.add(id); order.push(id);
      combo.value = '';
      refreshDatalist();
      refreshChips();
      refreshFocusMainOptions();
      updateLayoutVisibility();
    });
    addAllBtn.addEventListener('click', () => {
      const q = combo.value;
      candidates(q).forEach(id => { members.add(id); order.push(id); });
      combo.value = '';
      refreshDatalist();
      refreshChips();
      refreshFocusMainOptions();
      updateLayoutVisibility();
    });
    removeAllBtn.addEventListener('click', () => {
      members.clear(); order.splice(0, order.length);
      combo.value = '';
      refreshDatalist();
      refreshChips();
      refreshFocusMainOptions();
      updateLayoutVisibility();
    });
    layoutSelect.addEventListener('change', updateLayoutVisibility);
    pipMain.addEventListener('change', () => { gLayout.pip_main = pipMain.value; if (gLayout.pip_main === gLayout.pip_pip) { gLayout.pip_pip = Array.from(members).find(x=>x!==gLayout.pip_main) || ''; } refreshPipSelects(); });
    pipPip.addEventListener('change', () => { gLayout.pip_pip = pipPip.value; if (gLayout.pip_main === gLayout.pip_pip) { gLayout.pip_main = Array.from(members).find(x=>x!==gLayout.pip_pip) || ''; } refreshPipSelects(); });
    const btns = makeEl('div', {class:'tile-buttons'}, []);
    const save = makeEl('button', {class:'tile-save'}, ['Save']);
    const cancel = makeEl('button', {class:'tile-cancel'}, ['Cancel']);
    btns.appendChild(save);
    btns.appendChild(cancel);
    body.appendChild(btns);
    tile.appendChild(body);

    // interactions
    edit.addEventListener('click', () => {
      body.hidden = !body.hidden;
      tile.classList.toggle('expanded', !body.hidden);
      markOpen(name, !body.hidden);
    });
    if (del) {
      del.addEventListener('click', async () => {
        if (!confirm(`Delete group ${name}?`)) return;
        await fetch(`/groups/${encodeURIComponent(name)}`, {method:'DELETE'});
        markOpen(name, false);
        tile.classList.remove('expanded');
        loadGroupsUI();
      });
    }
    save.addEventListener('click', async () => {
      const nameVal = (tile.querySelector('.tile-name').value || '').trim();
      if (!nameVal) { alert('Enter a group name'); return; }
      // preemptive duplicate check (case-insensitive), allow same-name when editing
      const wanted = nameVal.toLowerCase();
      if (wanted === 'default') { showNotification("'default' is a reserved group name"); return; }
      const exists = Object.keys(gmCurrentGroups || {}).some(g => g.toLowerCase() === wanted && g !== (name || ''));
      if (exists) { showNotification('A group with this name already exists'); return; }
      const ids = order.slice();
      // Build layout payload
      const layoutVal = layoutSelect.value;
      const payloadLayout = { layout: layoutVal };
      if (layoutVal==='grid') { payloadLayout.cols = parseInt(colsInput.value||'2',10); payloadLayout.rows = parseInt(rowsInput.value||'2',10); }
      if (layoutVal==='focus') { payloadLayout.focus_mode = focusMode.value; payloadLayout.focus_pos = focusPos.value; payloadLayout.focus_main = focusMain.value || null; }
      if (layoutVal==='pip') {
        payloadLayout.pip_main = pipMain.value || null;
        payloadLayout.pip_pip = pipPip.value || null;
        payloadLayout.pip_corner = pipCorner.value || 'bottom-right';
        payloadLayout.pip_size = parseInt(pipSize.value||'25',10);
      }
      const res = await fetch('/groups', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name: nameVal, streams: ids, layout: payloadLayout})});
      if (res.ok) {
        showNotification('Saved group');
        // If renamed, delete the old group name
        if (name && nameVal !== name) {
          try { await fetch(`/groups/${encodeURIComponent(name)}`, {method:'DELETE'}); } catch (e) {}
        }
        // Collapse after save (and handle rename)
        if (name && nameVal !== name) markOpen(name, false);
        markOpen(nameVal, false);
        tile.classList.remove('expanded');
        loadGroupsUI();
      } else {
        let msg = 'Failed to save group';
        try { const j = await res.json(); if (j && j.error) msg = j.error; } catch (e) {}
        alert(msg);
      }
    });
    cancel.addEventListener('click', () => { body.hidden = true; tile.classList.remove('expanded'); });
    // Keep count/title in sync with name edits
    const nameInputEl = nameRow.querySelector('.tile-name');
    if (nameInputEl) nameInputEl.addEventListener('input', () => { refreshTitleCount(); });
    return tile;
  }

  // initial load
  document.addEventListener('DOMContentLoaded', loadGroupsUI);

  

  // Add a new stream by posting to /streams
  addStreamBtn.addEventListener('click', () => {
    fetch('/streams', {method:'POST'})
      .then(res => res.json())
      .then(data => {
        if (data.stream_id) {
          location.reload();
        }
      });
  });

  // Card menu interactions: close on outside click and handle remove
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.card-menu')) {
      document.querySelectorAll('.card-menu .menu-dropdown').forEach(dd => dd.hidden = true);
    }
    if (e.target.classList.contains('menu-remove')) {
      const id = e.target.dataset.stream;
      if (confirm('Delete ' + id + '?')) {
        fetch('/streams/' + encodeURIComponent(id), {method:'DELETE'})
          .then(res => res.json())
          .then(data => {
            if (data.status === 'deleted') {
              location.reload();
            }
          });
      }
    }
  });

  // Socket.IO listener for layout updates if needed in future
  socket.on('streams_changed', (data) => {
    // This could be used to update the UI without reload.
    console.log('Streams changed:', data);
  });

  socket.on('ai_job_update', (data) => {
    const streamId = data && data.stream_id;
    if (!streamId) return;
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    if (data.job) {
      aiActiveJobs.set(streamId, data.job);
      const status = (data.job.status || '').toLowerCase();
      if (['completed', 'error', 'timeout', 'cancelled'].includes(status)) {
        aiActiveJobs.delete(streamId);
      }
    }
    if (data.state) {
      if (Array.isArray(data.state.images)) {
        renderAiResults(card, data.state.images);
      }
      renderAiStatus(card, data.state, data.job || aiActiveJobs.get(streamId) || null);
    } else if (data.job) {
      renderAiStatus(card, {}, data.job);
    }
  });

  socket.on('refresh', (data) => {
    const streamId = data && data.stream_id;
    const conf = data && data.config;
    if (!streamId || !conf) return;
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    if (Array.isArray(conf.tags)) {
      setCardTags(card, conf.tags);
      applyFiltersAndSorting();
      renderTagManager();
    }
    if (Array.isArray(data.tags)) {
      syncGlobalTags(data.tags);
    }
    if (conf.selected_image !== undefined || conf.selected_media_kind !== undefined) {
      const selectedPath = conf.selected_image || '';
      const selectedKind = (conf.selected_media_kind || card.dataset.selectedKind || '').toLowerCase();
      card.dataset.selectedPath = selectedPath;
      card.dataset.selectedKind = selectedKind;
      const display = card.querySelector('.selected-image-display');
      if (display) {
        display.textContent = selectedPath ? (selectedKind === 'video' ? `${selectedPath} (video)` : selectedPath) : 'None';
      }
      const resultsEl = card.querySelector('.ai-results');
      if (resultsEl) {
        highlightAiSelection(resultsEl, selectedPath);
      }
    }
    if (conf.video_playback_mode !== undefined) {
      const nextMode = (conf.video_playback_mode || 'duration').toLowerCase();
      card.dataset.videoMode = nextMode;
      const videoModeSelect = card.querySelector('.video-mode-select');
      if (videoModeSelect) videoModeSelect.value = nextMode;
    }
    if (conf.video_volume !== undefined) {
      const volumeValue = Number(conf.video_volume);
      card.dataset.videoVolume = String(volumeValue);
      card.dataset.videoVolumePersisted = String(volumeValue);
      const volumeSlider = card.querySelector('.video-volume-slider');
      if (volumeSlider) {
        const pct = Math.max(0, Math.min(1, Number.isFinite(volumeValue) ? volumeValue : 1)) * 100;
        volumeSlider.value = String(Math.round(pct));
      }
    }
    if (conf.ai_state) {
      if (Array.isArray(conf.ai_state.images)) {
        renderAiResults(card, conf.ai_state.images);
      }
      renderAiStatus(card, conf.ai_state, aiActiveJobs.get(streamId) || null);
    }
  });

  // Notepad behaviour
  const notepad = document.getElementById('notepad');
  const toggleNotepadBtn = document.getElementById('toggle-notepad');
  const notepadText = document.getElementById('notepad-text');
  const saveNotesBtn = document.getElementById('save-notes');
  // Load notes from server
  fetch('/notes')
    .then(r => r.json())
    .then(({text}) => { notepadText.value = text || ''; })
    .catch(() => {});
  toggleNotepadBtn.addEventListener('click', () => {
    notepad.classList.toggle('collapsed');
  });
  saveNotesBtn.addEventListener('click', () => {
    fetch('/notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: notepadText.value })
    })
    .then(r => r.json())
    .then(() => showNotification('Notes saved on server'))
    .catch(() => showNotification('Failed to save notes'));
  });

  // The following section reuses much of the original dashboard logic to
  // handle folder/mode selection, duration changes, image selection and
  // reload.  It has been lightly adapted to support dynamically added
  // streams.  The logic is encapsulated in functions that operate on
  // elements with a ``data-stream`` attribute.

  const aiModelCache = { models: null, promise: null };
  const aiPresetCache = { items: null, promise: null };
  const aiPresetSelects = new Set();
  let presetManagerModal = null;
  let presetManagerBackdrop = null;
  let presetManagerList = null;
  let presetManagerEmpty = null;
  const aiActiveJobs = new Map();

  function setupPresetManagerElements() {
    if (presetManagerModal) return;
    presetManagerModal = document.getElementById('ai-preset-manager');
    presetManagerBackdrop = document.getElementById('ai-preset-manager-backdrop');
    if (presetManagerModal) {
      presetManagerList = presetManagerModal.querySelector('.ai-preset-list');
      presetManagerEmpty = presetManagerModal.querySelector('.ai-preset-empty');
      const closeBtn = presetManagerModal.querySelector('.ai-preset-manager-close');
      if (closeBtn) closeBtn.addEventListener('click', closePresetManager);
    }
    if (presetManagerBackdrop) {
      presetManagerBackdrop.addEventListener('click', closePresetManager);
    }
  }

  function closePresetManager() {
    if (presetManagerModal) {
      presetManagerModal.hidden = true;
      presetManagerModal.setAttribute('aria-hidden', 'true');
    }
    if (presetManagerBackdrop) presetManagerBackdrop.hidden = true;
    document.body.classList.remove('ai-preset-manager-open');
  }

  function renderPresetManager(presets) {
    setupPresetManagerElements();
    if (!presetManagerModal || !presetManagerList) return;
    presetManagerList.innerHTML = '';
    const items = Array.isArray(presets) ? presets : [];
    if (!items.length) {
      if (presetManagerEmpty) presetManagerEmpty.hidden = false;
      return;
    }
    if (presetManagerEmpty) presetManagerEmpty.hidden = true;
    items.forEach(preset => {
      const li = document.createElement('li');
      li.className = 'ai-preset-item';
      const header = document.createElement('div');
      header.className = 'ai-preset-item-row';
      const nameEl = document.createElement('span');
      nameEl.className = 'ai-preset-item-name';
      nameEl.textContent = preset.name;
      header.appendChild(nameEl);
      const actions = document.createElement('div');
      actions.className = 'ai-preset-item-actions';
      const renameBtn = document.createElement('button');
      renameBtn.type = 'button';
      renameBtn.className = 'ai-preset-rename';
      renameBtn.textContent = 'Rename';
      renameBtn.addEventListener('click', async () => {
        const next = prompt('Rename preset', preset.name);
        if (next === null) return;
        const trimmed = (next || '').trim();
        if (!trimmed || trimmed === preset.name) {
          if (!trimmed) showNotification('Preset name cannot be empty');
          return;
        }
        try {
          await renamePresetRequest(preset.name, trimmed);
          const updated = await fetchAiPresets(true);
          refreshAllPresetSelects(updated);
          renderPresetManager(updated);
          showNotification(`Preset "${trimmed}" saved`);
        } catch (err) {
          showNotification(err && err.message ? err.message : 'Failed to rename preset');
        }
      });
      actions.appendChild(renameBtn);
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.className = 'ai-preset-delete';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', async () => {
        if (!confirm(`Delete preset "${preset.name}"?`)) return;
        try {
          await deletePresetRequest(preset.name);
          const updated = await fetchAiPresets(true);
          refreshAllPresetSelects(updated);
          renderPresetManager(updated);
          showNotification(`Preset "${preset.name}" deleted`);
        } catch (err) {
          showNotification(err && err.message ? err.message : 'Failed to delete preset');
        }
      });
      actions.appendChild(deleteBtn);
      const viewDetails = document.createElement('details');
      viewDetails.className = 'ai-preset-item-details';
      const summary = document.createElement('summary');
      summary.textContent = 'View settings';
      const pre = document.createElement('pre');
      pre.textContent = JSON.stringify(preset.settings || {}, null, 2);
      viewDetails.appendChild(summary);
      viewDetails.appendChild(pre);
      header.appendChild(actions);
      li.appendChild(header);
      li.appendChild(viewDetails);
      presetManagerList.appendChild(li);
    });
  }

  async function openPresetManager() {
    setupPresetManagerElements();
    if (!presetManagerModal) return;
    presetManagerModal.hidden = false;
    presetManagerModal.setAttribute('aria-hidden', 'false');
    if (presetManagerBackdrop) presetManagerBackdrop.hidden = false;
    document.body.classList.add('ai-preset-manager-open');
    try {
      const presets = await fetchAiPresets();
      renderPresetManager(presets);
    } catch (err) {
      renderPresetManager([]);
      showNotification(err && err.message ? err.message : 'Failed to load presets');
    }
  }

  function populatePresetSelect(select, presets) {
    if (!select) return;
    const items = Array.isArray(presets) ? presets : [];
    const previous = select.value;
    select.innerHTML = '';
    if (!items.length) {
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'No presets saved';
      option.disabled = true;
      option.selected = true;
      select.appendChild(option);
      select.disabled = true;
      return;
    }
    select.disabled = false;
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.disabled = true;
    placeholder.textContent = 'Select a preset...';
    select.appendChild(placeholder);
    items.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.name;
      option.textContent = preset.name;
      select.appendChild(option);
    });
    if (items.some(p => p.name === previous)) {
      select.value = previous;
    } else {
      placeholder.selected = true;
    }
  }

  function refreshAllPresetSelects(presets) {
    Array.from(aiPresetSelects).forEach(select => {
      if (!select || !select.isConnected) {
        aiPresetSelects.delete(select);
        return;
      }
      populatePresetSelect(select, presets);
    });
  }

  async function fetchAiPresets(force = false) {
    if (force) {
      aiPresetCache.items = null;
    } else if (aiPresetCache.items) {
      return aiPresetCache.items;
    }
    if (!force && aiPresetCache.promise) {
      return aiPresetCache.promise;
    }
    aiPresetCache.promise = fetch('/ai/presets')
      .then(async res => {
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.error) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        const presets = Array.isArray(data.presets) ? data.presets.slice() : [];
        presets.sort((a, b) => a.name.localeCompare(b.name));
        aiPresetCache.items = presets;
        refreshAllPresetSelects(presets);
        return presets;
      })
      .catch(err => {
        console.error('Failed to load presets', err);
        throw err;
      })
      .finally(() => {
        aiPresetCache.promise = null;
      });
    return aiPresetCache.promise;
  }

  async function savePresetRequest(name, settings, overwrite = false) {
    const trimmed = (name || '').trim();
    if (!trimmed) {
      throw new Error('Preset name is required');
    }
    const res = await fetch('/ai/presets', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: trimmed, settings, overwrite })
    });
    const data = await res.json().catch(() => ({}));
    if (res.status === 409 && data.status === 'exists' && !overwrite) {
      const err = new Error(data.error || 'Preset already exists');
      err.code = 'exists';
      throw err;
    }
    if (!res.ok || data.error) {
      throw new Error(data.error || `Request failed (${res.status})`);
    }
    aiPresetCache.items = null;
    return data.preset;
  }

  async function renamePresetRequest(oldName, newName) {
    const trimmed = (newName || '').trim();
    if (!trimmed) {
      throw new Error('Preset name is required');
    }
    const res = await fetch(`/ai/presets/${encodeURIComponent(oldName)}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: trimmed })
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok || data.error) {
      throw new Error(data.error || `Request failed (${res.status})`);
    }
    aiPresetCache.items = null;
    return data.preset;
  }

  async function deletePresetRequest(name) {
    const res = await fetch(`/ai/presets/${encodeURIComponent(name)}`, {
      method: 'DELETE'
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok || data.error) {
      throw new Error(data.error || `Request failed (${res.status})`);
    }
    aiPresetCache.items = null;
    return data;
  }

  async function fetchAiModels() {
    if (aiModelCache.models) {
      return aiModelCache.models;
    }
    if (!aiModelCache.promise) {
      aiModelCache.promise = fetch('/ai/models')
        .then(async res => {
          if (!res.ok) {
            throw new Error(`Request failed (${res.status})`);
          }
          const data = await res.json().catch(() => ({}));
          return Array.isArray(data.models) ? data.models : [];
        })
        .catch(err => {
          console.error('Failed to fetch Stable Horde models', err);
          return [];
        })
        .finally(() => {
          aiModelCache.promise = null;
        });
      aiModelCache.promise.then(models => {
        aiModelCache.models = models;
      });
    }
    return aiModelCache.promise;
  }

  function highlightAiSelection(resultsEl, selectedPath) {
    if (!resultsEl) return;
    const target = selectedPath || '';
    resultsEl.dataset.selected = target;
    resultsEl.querySelectorAll('.ai-generated-item').forEach(item => {
      if (!item.dataset.path) return;
      if (item.dataset.path === target) {
        item.classList.add('is-selected');
      } else {
        item.classList.remove('is-selected');
      }
    });
  }

  function renderAiResults(card, images) {
    const resultsEl = card.querySelector('.ai-results');
    const grid = card.querySelector('.ai-generated-grid');
    const empty = card.querySelector('.ai-generated-empty');
    if (!resultsEl || !grid || !empty) return;
    grid.innerHTML = '';
    const list = Array.isArray(images) ? images : [];
    if (!list.length) {
      empty.style.display = '';
      highlightAiSelection(resultsEl, resultsEl.dataset.selected || '');
      return;
    }
    empty.style.display = 'none';
    list.forEach(img => {
      if (!img || !img.path) return;
      const item = document.createElement('div');
      item.className = 'ai-generated-item';
      item.dataset.path = img.path;
      item.dataset.persisted = img.persisted ? 'true' : 'false';
      const imageEl = document.createElement('img');
      imageEl.src = `/stream/image/${img.path}`;
      imageEl.alt = (`Generated image ${img.seed || ''}`).trim();
      item.appendChild(imageEl);
      const meta = document.createElement('div');
      meta.className = 'ai-generated-meta';
      if (img.model) {
        const modelTag = document.createElement('span');
        modelTag.className = 'ai-model-tag';
        modelTag.textContent = img.model;
        meta.appendChild(modelTag);
      }
      if (img.seed) {
        const seedTag = document.createElement('span');
        seedTag.className = 'ai-seed-tag';
        seedTag.textContent = `#${img.seed}`;
        meta.appendChild(seedTag);
      }
      item.appendChild(meta);
      grid.appendChild(item);
    });
    highlightAiSelection(resultsEl, resultsEl.dataset.selected || '');
  }

  function formatAutoTime(value) {
    const fallback = 'u2014';
    if (!value) return fallback;
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      const datePart = parsed.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
      const timePart = parsed.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
      return `${datePart} ${timePart}`;
    }
    return value || fallback;
  }

  function updateAutoIndicators(card, state) {
    if (!card) return;
    const info = state || {};
    if (Object.prototype.hasOwnProperty.call(info, 'next_auto_trigger')) {
      const summaryNext = card.querySelector('.ai-summary-next');
      const modalNext = card.querySelector('.ai-auto-next');
      const formatted = formatAutoTime(info.next_auto_trigger);
      if (summaryNext) summaryNext.textContent = formatted;
      if (modalNext) modalNext.textContent = formatted;
    }
    if (Object.prototype.hasOwnProperty.call(info, 'last_auto_error')) {
      const errorEl = card.querySelector('.ai-auto-error');
      if (errorEl) {
        const message = info.last_auto_error;
        if (message) {
          errorEl.textContent = message;
          errorEl.hidden = false;
        } else {
          errorEl.textContent = '';
          errorEl.hidden = true;
        }
      }
    }
  }

  function renderAiStatus(card, state, job) {
    const statusEl = card.querySelector('.ai-status');
    if (!statusEl) return;
    const info = state || {};
    const jobInfo = job || {};
    const status = (jobInfo.status || info.status || 'idle').toLowerCase();
    let label = status.charAt(0).toUpperCase() + status.slice(1);
    const queuePos = jobInfo.queue_position ?? info.queue_position;
    if (queuePos !== undefined && queuePos !== null && queuePos !== '') {
      label += ` (queue ${queuePos})`;
    }
    const note = jobInfo.message || info.message;
    if (note && ['error', 'timeout', 'cancelled'].includes(status)) {
      label += ` - ${note}`;
    } else if (status === 'cancelling') {
      label += note ? ` - ${note}` : '...';
    }
    statusEl.dataset.status = status;
    statusEl.textContent = label;
    const activeStatuses = ['queued', 'accepted', 'running', 'cancelling'];
    card.querySelectorAll('.ai-generate-btn').forEach(btn => {
      btn.disabled = activeStatuses.includes(status);
    });
    const cancelButtons = card.querySelectorAll('.ai-cancel-btn');
    const showCancel = activeStatuses.includes(status);
    cancelButtons.forEach(btn => {
      btn.hidden = !showCancel;
      if (showCancel) {
        btn.disabled = status === 'cancelling';
      } else {
        btn.disabled = false;
      }
    });
    updateAutoIndicators(card, info);
  }

  function gatherPostProcessing(card) {
    const selected = [];
    card.querySelectorAll('.ai-post-proc').forEach(chk => {
      if (chk.checked && chk.value) {
        selected.push(chk.value);
      }
    });
    return selected;
  }

  function gatherLoras(card) {
    const rows = card.querySelectorAll('.ai-lora-row');
    const result = [];
    rows.forEach(row => {
      const nameInput = row.querySelector('.ai-lora-name');
      const name = nameInput ? nameInput.value.trim() : '';
      if (!name) return;
      const entry = { name };
      const modelInput = row.querySelector('.ai-lora-model');
      if (modelInput && modelInput.value.trim() !== '') {
        const parsed = parseFloat(modelInput.value);
        if (!Number.isNaN(parsed)) entry.model = parsed;
      }
      const clipInput = row.querySelector('.ai-lora-clip');
      if (clipInput && clipInput.value.trim() !== '') {
        const parsed = parseFloat(clipInput.value);
        if (!Number.isNaN(parsed)) entry.clip = parsed;
      }
      const triggerInput = row.querySelector('.ai-lora-trigger');
      if (triggerInput) {
        const trig = triggerInput.value.trim();
        if (trig) entry.inject_trigger = trig;
      }
      const versionChk = row.querySelector('.ai-lora-is-version');
      if (versionChk && versionChk.checked) {
        entry.is_version = true;
      }
      result.push(entry);
    });
    return result;
  }

  function collectAiPayload(card) {
    const payload = {};
    const promptInput = card.querySelector('.ai-prompt-input');
    const negativeInput = card.querySelector('.ai-negative-input');
    const modelSelect = card.querySelector('.ai-model-select');
    const samplerSelect = card.querySelector('.ai-sampler-select');
    const widthInput = card.querySelector('.ai-width-input');
    const heightInput = card.querySelector('.ai-height-input');
    const stepsInput = card.querySelector('.ai-steps-input');
    const cfgInput = card.querySelector('.ai-cfg-input');
    const samplesInput = card.querySelector('.ai-samples-input');
    const seedInput = card.querySelector('.ai-seed-input');
    const saveOutput = card.querySelector('.ai-save-output');
    const nsfw = card.querySelector('.ai-nsfw');
    const censor = card.querySelector('.ai-censor');
    payload.prompt = promptInput ? promptInput.value : '';
    payload.negative_prompt = negativeInput ? negativeInput.value : '';
    payload.model = modelSelect ? modelSelect.value : '';
    payload.sampler = samplerSelect ? samplerSelect.value : '';
    payload.width = widthInput ? parseInt(widthInput.value, 10) : undefined;
    payload.height = heightInput ? parseInt(heightInput.value, 10) : undefined;
    payload.steps = stepsInput ? parseInt(stepsInput.value, 10) : undefined;
    payload.cfg_scale = cfgInput ? parseFloat(cfgInput.value) : undefined;
    payload.samples = samplesInput ? parseInt(samplesInput.value, 10) : undefined;
    payload.seed = seedInput ? seedInput.value : '';
    payload.save_output = saveOutput ? saveOutput.checked : undefined;
    payload.nsfw = nsfw ? nsfw.checked : undefined;
    payload.censor_nsfw = censor ? censor.checked : undefined;
    payload.post_processing = gatherPostProcessing(card);
    payload.loras = gatherLoras(card);
    const boolPairs = [
      ['.ai-hires-fix', 'hires_fix'],
      ['.ai-karras', 'karras'],
      ['.ai-tiling', 'tiling'],
      ['.ai-transparent', 'transparent'],
      ['.ai-trusted-workers', 'trusted_workers'],
      ['.ai-validated-backends', 'validated_backends'],
      ['.ai-slow-workers', 'slow_workers'],
      ['.ai-extra-slow-workers', 'extra_slow_workers'],
      ['.ai-disable-batching', 'disable_batching'],
      ['.ai-allow-downgrade', 'allow_downgrade'],
    ];
    boolPairs.forEach(([selector, key]) => {
      const el = card.querySelector(selector);
      if (el) payload[key] = el.checked;
    });
    const styleInput = card.querySelector('.ai-style-input');
    payload.style = styleInput ? styleInput.value.trim() : '';
    const clipSkipInput = card.querySelector('.ai-clip-skip');
    if (clipSkipInput && clipSkipInput.value.trim() !== '') {
      const parsedClip = parseInt(clipSkipInput.value, 10);
      payload.clip_skip = Number.isNaN(parsedClip) ? null : parsedClip;
    } else {
      payload.clip_skip = null;
    }
    const facefixerInput = card.querySelector('.ai-facefixer');
    if (facefixerInput && facefixerInput.value.trim() !== '') {
      const parsed = parseFloat(facefixerInput.value);
      payload.facefixer_strength = Number.isNaN(parsed) ? null : parsed;
    } else {
      payload.facefixer_strength = null;
    }
    const denoiseInput = card.querySelector('.ai-denoise');
    if (denoiseInput && denoiseInput.value.trim() !== '') {
      const parsed = parseFloat(denoiseInput.value);
      payload.denoising_strength = Number.isNaN(parsed) ? null : parsed;
    } else {
      payload.denoising_strength = null;
    }
    const hiresDenoiseInput = card.querySelector('.ai-hires-denoise');
    if (hiresDenoiseInput && hiresDenoiseInput.value.trim() !== '') {
      const parsed = parseFloat(hiresDenoiseInput.value);
      payload.hires_fix_denoising_strength = Number.isNaN(parsed) ? null : parsed;
    } else {
      payload.hires_fix_denoising_strength = null;
    }
    const aiSection = card.querySelector('.ai-generator');
    if (aiSection && aiSection.dataset && 'timeout' in aiSection.dataset) {
      const stored = aiSection.dataset.timeout;
      if (stored) {
        const parsedTimeout = parseFloat(stored);
        payload.timeout = Number.isFinite(parsedTimeout) ? parsedTimeout : null;
      } else {
        payload.timeout = null;
      }
    }
    const autoModeSelect = card.querySelector('.ai-auto-mode');
    if (autoModeSelect) {
      payload.auto_generate_mode = autoModeSelect.value;
    }
    const autoIntervalInput = card.querySelector('.ai-auto-interval');
    if (autoIntervalInput) {
      const parsedInterval = parseFloat(autoIntervalInput.value);
      if (!Number.isNaN(parsedInterval)) {
        payload.auto_generate_interval_value = parsedInterval;
      }
    }
    const autoUnitSelect = card.querySelector('.ai-auto-interval-unit');
    if (autoUnitSelect) {
      payload.auto_generate_interval_unit = autoUnitSelect.value;
    }
    const autoClockInput = card.querySelector('.ai-auto-clock');
    if (autoClockInput) {
      payload.auto_generate_clock_time = autoClockInput.value;
    }
    return payload;
  }

  function setupAiControls(card, streamId) {
    const aiSection = card.querySelector('.ai-generator');
    if (!aiSection || aiSection.dataset.ready === 'true') {
      return;
    }
    aiSection.dataset.ready = 'true';
    aiSection.setAttribute('aria-hidden', 'true');
    const summaryRoot = card.querySelector('.ai-summary');
    const modalBackdrop = card.querySelector('.ai-modal-backdrop');
    const presetSelect = card.querySelector('.ai-preset-select');
    const savePresetBtn = card.querySelector('.ai-preset-save');
    const managePresetBtn = card.querySelector('.ai-preset-manage');
    const openSettingsBtn = card.querySelector('.ai-open-settings');
    const closeSettingsButtons = aiSection.querySelectorAll('.ai-close-settings, .ai-close-settings-secondary');
    const autoModeSelect = card.querySelector('.ai-auto-mode');
    const autoTimerRow = card.querySelector('.ai-auto-timer-row');
    const autoClockRow = card.querySelector('.ai-auto-clock-row');
    const autoIntervalInput = card.querySelector('.ai-auto-interval');
    const autoUnitSelect = card.querySelector('.ai-auto-interval-unit');
    const autoClockInput = card.querySelector('.ai-auto-clock');
    let applyingPreset = false;
    const updateAutoVisibility = () => {
      const modeValue = autoModeSelect ? autoModeSelect.value : 'off';
      if (autoTimerRow) autoTimerRow.hidden = modeValue !== 'timer';
      if (autoClockRow) autoClockRow.hidden = modeValue !== 'clock';
      if (autoIntervalInput) autoIntervalInput.disabled = modeValue !== 'timer';
      if (autoUnitSelect) autoUnitSelect.disabled = modeValue !== 'timer';
      if (autoClockInput) autoClockInput.disabled = modeValue !== 'clock';
    };
    updateAutoVisibility();
    if (modalBackdrop) modalBackdrop.hidden = true;

    function updateSummary() {
      if (!summaryRoot) return;
      const data = collectAiPayload(card);
      const aiGen = card.querySelector('.ai-generator');
      const width = Number(data.width);
      const height = Number(data.height);
      const stepsVal = Number(data.steps);
      const cfgVal = Number(data.cfg_scale);
      const samplesVal = Number(data.samples);
      const summaryValues = {
        model: data.model && data.model.trim() ? data.model : 'Auto',
        sampler: data.sampler ? data.sampler : 'k_euler',
        size: `${Number.isFinite(width) ? width : 512}x${Number.isFinite(height) ? height : 512}`,
        steps: Number.isFinite(stepsVal) ? stepsVal : 30,
        cfg: Number.isFinite(cfgVal) ? cfgVal : 7.5,
        samples: Number.isFinite(samplesVal) ? samplesVal : 1,
        loras: (data.loras || []).length,
        post: (data.post_processing || []).length,
        save: data.save_output ? 'Yes' : 'Temp',
      };
      let timeoutValue = null;
      if (data.timeout !== undefined && data.timeout !== null && data.timeout !== '') {
        const parsed = parseFloat(data.timeout);
        if (Number.isFinite(parsed)) timeoutValue = parsed;
      } else if (aiGen && aiGen.dataset.timeout !== undefined) {
        const stored = aiGen.dataset.timeout;
        if (stored) {
          const parsed = parseFloat(stored);
          if (Number.isFinite(parsed)) timeoutValue = parsed;
        }
      }
      if (aiGen) {
        if (Number.isFinite(timeoutValue)) {
          aiGen.dataset.timeout = String(timeoutValue);
        } else {
          aiGen.dataset.timeout = '';
        }
      }
      const timeoutLabel = Number.isFinite(timeoutValue) && timeoutValue > 0 ? timeoutValue : 'No limit';
      const mapping = {
        '.ai-summary-model': summaryValues.model,
        '.ai-summary-sampler': summaryValues.sampler,
        '.ai-summary-size': summaryValues.size,
        '.ai-summary-steps': summaryValues.steps,
        '.ai-summary-cfg': summaryValues.cfg,
        '.ai-summary-samples': summaryValues.samples,
        '.ai-summary-loras': summaryValues.loras,
        '.ai-summary-post': summaryValues.post,
        '.ai-summary-save': summaryValues.save,
        '.ai-summary-timeout': timeoutLabel,
      };
      Object.entries(mapping).forEach(([selector, value]) => {
        const el = summaryRoot.querySelector(selector);
        if (el) el.textContent = value;
      });
      const autoModeSelect = card.querySelector('.ai-auto-mode');
      let autoLabel = 'Off';
      if (autoModeSelect) {
        const modeValue = autoModeSelect.value;
        if (modeValue === 'timer') {
          const intervalInput = card.querySelector('.ai-auto-interval');
          const unitSelect = card.querySelector('.ai-auto-interval-unit');
          const unitLabel = unitSelect && unitSelect.value === 'hours' ? 'hr' : 'min';
          const intervalValue = intervalInput ? parseFloat(intervalInput.value) : NaN;
          if (!Number.isNaN(intervalValue) && intervalValue > 0) {
            const rounded = Number(intervalValue.toFixed(2));
            const display = Number.isInteger(rounded) ? rounded.toString() : rounded.toString();
            autoLabel = `Timer (${display} ${unitLabel})`;
          } else {
            autoLabel = 'Timer';
          }
        } else if (modeValue === 'clock') {
          const clockInput = card.querySelector('.ai-auto-clock');
          const timeValue = clockInput && clockInput.value ? clockInput.value : '--:--';
          autoLabel = `Clock (${timeValue})`;
        }
      }
      const autoSummary = summaryRoot.querySelector('.ai-summary-auto');
      if (autoSummary) autoSummary.textContent = autoLabel;
    }

    if (autoModeSelect) {
      autoModeSelect.addEventListener('change', e => {
        updateAutoVisibility();
        saveSettings(streamId, { ai_settings: { auto_generate_mode: e.target.value } });
        updateSummary();
      });
    }
    if (autoIntervalInput) {
      const handleIntervalChange = () => {
        const value = parseFloat(autoIntervalInput.value);
        if (Number.isNaN(value) || value <= 0) return;
        saveSettings(streamId, { ai_settings: { auto_generate_interval_value: value } });
        updateSummary();
      };
      autoIntervalInput.addEventListener('change', handleIntervalChange);
      autoIntervalInput.addEventListener('blur', handleIntervalChange);
    }
    if (autoUnitSelect) {
      autoUnitSelect.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { auto_generate_interval_unit: e.target.value } });
        updateSummary();
      });
    }
    if (autoClockInput) {
      const handleClockChange = () => {
        saveSettings(streamId, { ai_settings: { auto_generate_clock_time: autoClockInput.value } });
        updateSummary();
      };
      autoClockInput.addEventListener('change', handleClockChange);
      autoClockInput.addEventListener('blur', handleClockChange);
    }
    aiSummaryUpdaters.set(card, updateSummary);
    updateSummary();

    if (presetSelect) {
      aiPresetSelects.add(presetSelect);
      if (aiPresetCache.items) {
        populatePresetSelect(presetSelect, aiPresetCache.items);
      } else {
        populatePresetSelect(presetSelect, []);
        fetchAiPresets()
          .then(presets => populatePresetSelect(presetSelect, presets))
          .catch(() => populatePresetSelect(presetSelect, []));
      }
      presetSelect.addEventListener('change', e => {
        const selectedName = e.target.value;
        if (!selectedName) return;
        applyPresetByName(selectedName);
      });
    } else {
      fetchAiPresets().catch(() => {});
    }

    if (savePresetBtn) {
      savePresetBtn.addEventListener('click', async () => {
        const payload = collectAiPayload(card);
        const suggested = presetSelect && presetSelect.value ? presetSelect.value : '';
        const input = prompt('Save preset as', suggested);
        if (input === null) return;
        const trimmed = (input || '').trim();
        if (!trimmed) {
          showNotification('Preset name cannot be empty');
          return;
        }
        try {
          await savePresetRequest(trimmed, payload);
        } catch (err) {
          if (err && err.code === 'exists') {
            const overwrite = confirm(`Preset "${trimmed}" already exists. Overwrite?`);
            if (!overwrite) return;
            try {
              await savePresetRequest(trimmed, payload, true);
            } catch (overwriteErr) {
              showNotification(overwriteErr && overwriteErr.message ? overwriteErr.message : 'Failed to save preset');
              return;
            }
          } else {
            showNotification(err && err.message ? err.message : 'Failed to save preset');
            return;
          }
        }
        try {
          const presets = await fetchAiPresets(true);
          if (presetManagerModal && !presetManagerModal.hidden) {
            renderPresetManager(presets);
          }
          if (presetSelect) {
            populatePresetSelect(presetSelect, presets);
            presetSelect.value = trimmed;
          }
          showNotification(`Preset "${trimmed}" saved`);
        } catch (refreshErr) {
          showNotification(refreshErr && refreshErr.message ? refreshErr.message : 'Preset saved, but list failed to refresh');
        }
      });
    } else {
      fetchAiPresets().catch(() => {});
    }

    if (managePresetBtn) {
      managePresetBtn.addEventListener('click', () => {
        openPresetManager();
      });
    }

    if (openSettingsBtn) {
      openSettingsBtn.addEventListener('click', () => {
        updateSummary();
        openAiSettings(card);
      });
    }
    if (closeSettingsButtons.length) {
      closeSettingsButtons.forEach(btn => btn.addEventListener('click', () => closeAiSettings(card)));
    }
    if (modalBackdrop) {
      modalBackdrop.addEventListener('click', () => closeAiSettings(card));
    }

    const modeSelect = card.querySelector('.mode-select');
    const promptInput = card.querySelector('.ai-prompt-input');
    if (promptInput) {
      promptInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { prompt: e.target.value } });
      });
    }
    const negativeInput = card.querySelector('.ai-negative-input');
    if (negativeInput) {
      negativeInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { negative_prompt: e.target.value } });
      });
    }
    const samplerSelect = card.querySelector('.ai-sampler-select');
    if (samplerSelect) {
      samplerSelect.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { sampler: e.target.value } });
        updateSummary();
      });
    }
    const seedInput = card.querySelector('.ai-seed-input');
    if (seedInput) {
      seedInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { seed: e.target.value } });
      });
    }
    const modelSelect = card.querySelector('.ai-model-select');
    if (modelSelect) {
      modelSelect.addEventListener('focus', () => {
        fetchAiModels().then(models => {
          if (!models || !modelSelect) return;
          const values = new Set(Array.from(modelSelect.options).map(opt => opt.value));
          models.forEach(model => {
            const name = model && model.name ? model.name : '';
            if (!name || values.has(name)) return;
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            modelSelect.appendChild(opt);
            values.add(name);
          });
        });
      });
      modelSelect.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { model: e.target.value } });
        updateSummary();
      });
    }
    const loraSection = card.querySelector('.ai-lora-section');
    const loraList = loraSection ? loraSection.querySelector('.ai-lora-list') : null;
    const loraSearchInput = loraSection ? loraSection.querySelector('.ai-lora-search-input') : null;
    const loraSearchBtn = loraSection ? loraSection.querySelector('.ai-lora-search-btn') : null;
    const loraResultsWrap = loraSection ? loraSection.querySelector('.ai-lora-results') : null;
    const loraResultsHeader = loraResultsWrap ? loraResultsWrap.querySelector('.ai-lora-results-header') : null;
    const loraResultsList = loraResultsWrap ? loraResultsWrap.querySelector('.ai-lora-results-list') : null;


    function bindNumeric(selector, key) {
      const input = card.querySelector(selector);
      if (!input) return;
      input.addEventListener('change', e => {
        const val = parseFloat(e.target.value);
        if (!Number.isFinite(val)) return;
        saveSettings(streamId, { ai_settings: { [key]: val } });
        updateSummary();
      });
    }

    function bindCheckboxSetting(selector, key) {
      const input = card.querySelector(selector);
      if (!input) return;
      input.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { [key]: e.target.checked } });
        updateSummary();
      });
    }

    function bindOptionalNumber(selector, key, parser) {
      const input = card.querySelector(selector);
      if (!input) return;
      input.addEventListener('change', e => {
        const raw = (e.target.value || '').trim();
        if (!raw) {
          saveSettings(streamId, { ai_settings: { [key]: null } });
          updateSummary();
          return;
        }
        const parsed = parser(raw);
        if (Number.isNaN(parsed)) return;
        saveSettings(streamId, { ai_settings: { [key]: parsed } });
        updateSummary();
      });
    }

    function updateLoraAddState() {
      if (!loraSection) return;
      const addBtn = loraSection.querySelector('.ai-add-lora');
      if (!addBtn) return;
      const max = parseInt(loraSection.dataset.max || '0', 10) || 0;
      const current = loraSection.querySelectorAll('.ai-lora-row').length;
      addBtn.disabled = max > 0 && current >= max;
    }

    function appendEmptyLoraRow() {
      if (!loraSection || !loraList) return null;
      const max = parseInt(loraSection.dataset.max || '0', 10) || 0;
      const current = loraList.querySelectorAll('.ai-lora-row').length;
      if (max > 0 && current >= max) {
        showNotification(`Maximum of ${max} LoRAs reached`);
        return null;
      }
      const row = document.createElement('div');
      row.className = 'ai-lora-row';
      row.innerHTML = `
        <input type="text" class="ai-lora-name" placeholder="Name or CivitAI ID">
        <input type="number" class="ai-lora-model" placeholder="Model" step="0.05" min="-5" max="5">
        <input type="number" class="ai-lora-clip" placeholder="Clip" step="0.05" min="-5" max="5">
        <input type="text" class="ai-lora-trigger" placeholder="Trigger (optional)">
        <label class="toggle compact ai-lora-flag"><input type="checkbox" class="ai-lora-is-version"><span class="toggle-switch"></span><span class="toggle-label">Version ID</span></label>
        <button type="button" class="ai-lora-remove">Remove</button>
      `;
      loraList.appendChild(row);
      bindLoraRow(row);
      updateLoraAddState();
      return row;
    }

    function renderLoraResults(results, query) {
      if (!loraResultsWrap || !loraResultsList) return;
      loraResultsWrap.hidden = false;
      loraResultsList.innerHTML = '';
      if (loraResultsHeader) {
        if (results.length) {
          loraResultsHeader.textContent = query ? `Results for "${query}"` : 'LoRA results';
        } else {
          loraResultsHeader.textContent = query ? `No LoRAs found for "${query}"` : 'No LoRAs found';
        }
      }
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'ai-lora-result-empty';
        empty.textContent = 'Try a different search term.';
        loraResultsList.appendChild(empty);
        return;
      }
      results.forEach(result => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'ai-lora-result';
        const title = document.createElement('div');
        title.className = 'ai-lora-result-title';
        const modelName = result.modelName || 'Unnamed LoRA';
        const versionName = result.versionName || `Version ${result.versionId}`;
        title.textContent = `${modelName} - ${versionName}`;
        button.appendChild(title);
        if (Array.isArray(result.triggerWords) && result.triggerWords.length) {
          const triggers = document.createElement('div');
          triggers.className = 'ai-lora-result-triggers';
          triggers.textContent = `Triggers: ${result.triggerWords.slice(0, 3).join(', ')}`;
          button.appendChild(triggers);
        }
        button.addEventListener('click', () => {
          const row = appendEmptyLoraRow();
          if (!row) return;
          const nameInput = row.querySelector('.ai-lora-name');
          if (nameInput) {
            nameInput.value = (result.versionId || '').toString() || modelName;
          }
          const triggerInput = row.querySelector('.ai-lora-trigger');
          if (triggerInput && Array.isArray(result.triggerWords) && result.triggerWords.length) {
            triggerInput.value = result.triggerWords.slice(0, 2).join(', ');
          }
          const isVersionChk = row.querySelector('.ai-lora-is-version');
          if (isVersionChk && result.versionId) {
            isVersionChk.checked = true;
          }
          syncLoras();
          showNotification('LoRA added from search');
        });
        loraResultsList.appendChild(button);
      });
    }

    async function performLoraSearch(query) {
      if (!loraResultsWrap) return;
      const term = (query || '').trim();
      if (!term) {
        showNotification('Enter a search term for LoRAs');
        return;
      }
      loraResultsWrap.hidden = false;
      if (loraResultsHeader) loraResultsHeader.textContent = 'Searching...';
      if (loraResultsList) loraResultsList.innerHTML = '';
      try {
        const res = await fetch(`/ai/loras?q=${encodeURIComponent(term)}`);
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.error) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        renderLoraResults(data.results || [], term);
      } catch (err) {
        if (loraResultsHeader) loraResultsHeader.textContent = 'Search failed';
        if (loraResultsList) {
          const error = document.createElement('div');
          error.className = 'ai-lora-result-error';
          error.textContent = err && err.message ? err.message : 'Unable to load LoRAs';
          loraResultsList.appendChild(error);
        }
      }
    }


    function applyPresetSettings(preset) {
      if (!preset || typeof preset !== 'object') return;
      const aiSection = card.querySelector('.ai-generator');
      const promptInput = card.querySelector('.ai-prompt-input');
      if (promptInput) promptInput.value = preset.prompt || '';
      const negativeInput = card.querySelector('.ai-negative-input');
      if (negativeInput) negativeInput.value = preset.negative_prompt || '';
      const modelSelect = card.querySelector('.ai-model-select');
      if (modelSelect) {
        const value = preset.model || '';
        if (value && !Array.from(modelSelect.options).some(opt => opt.value === value)) {
          const opt = document.createElement('option');
          opt.value = value;
          opt.textContent = value;
          modelSelect.appendChild(opt);
        }
        modelSelect.value = value;
      }
      const samplerSelect = card.querySelector('.ai-sampler-select');
      if (samplerSelect) {
        const samplerValue = preset.sampler || 'k_euler';
        if (samplerValue && !Array.from(samplerSelect.options).some(opt => opt.value === samplerValue)) {
          const opt = document.createElement('option');
          opt.value = samplerValue;
          opt.textContent = samplerValue;
          samplerSelect.appendChild(opt);
        }
        samplerSelect.value = samplerValue;
      }
      const widthInput = card.querySelector('.ai-width-input');
      if (widthInput) {
        const width = Number(preset.width);
        widthInput.value = Number.isFinite(width) ? String(width) : '';
      }
      const heightInput = card.querySelector('.ai-height-input');
      if (heightInput) {
        const height = Number(preset.height);
        heightInput.value = Number.isFinite(height) ? String(height) : '';
      }
      const stepsInput = card.querySelector('.ai-steps-input');
      if (stepsInput) {
        const steps = Number(preset.steps);
        stepsInput.value = Number.isFinite(steps) ? String(steps) : '';
      }
      const cfgInput = card.querySelector('.ai-cfg-input');
      if (cfgInput) {
        const cfg = Number(preset.cfg_scale);
        cfgInput.value = Number.isFinite(cfg) ? String(cfg) : '';
      }
      const samplesInput = card.querySelector('.ai-samples-input');
      if (samplesInput) {
        const samples = Number(preset.samples);
        samplesInput.value = Number.isFinite(samples) ? String(samples) : '';
      }
      const seedInput = card.querySelector('.ai-seed-input');
      if (seedInput) seedInput.value = preset.seed && preset.seed !== 'random' ? preset.seed : '';
      const styleInput = card.querySelector('.ai-style-input');
      if (styleInput) styleInput.value = preset.style || '';
      const clipSkipInput = card.querySelector('.ai-clip-skip');
      if (clipSkipInput) {
        const clip = Number(preset.clip_skip);
        clipSkipInput.value = Number.isFinite(clip) ? String(clip) : '';
      }
      const facefixerInput = card.querySelector('.ai-facefixer');
      if (facefixerInput) {
        const val = Number(preset.facefixer_strength);
        facefixerInput.value = Number.isFinite(val) ? String(val) : '';
      }
      const denoiseInput = card.querySelector('.ai-denoise');
      if (denoiseInput) {
        const val = Number(preset.denoising_strength);
        denoiseInput.value = Number.isFinite(val) ? String(val) : '';
      }
      const hiresDenoiseInput = card.querySelector('.ai-hires-denoise');
      if (hiresDenoiseInput) {
        const val = Number(preset.hires_fix_denoising_strength);
        hiresDenoiseInput.value = Number.isFinite(val) ? String(val) : '';
      }
      const boolPairs = [
        ['.ai-hires-fix', 'hires_fix'],
        ['.ai-karras', 'karras'],
        ['.ai-tiling', 'tiling'],
        ['.ai-transparent', 'transparent'],
        ['.ai-trusted-workers', 'trusted_workers'],
        ['.ai-validated-backends', 'validated_backends'],
        ['.ai-slow-workers', 'slow_workers'],
        ['.ai-extra-slow-workers', 'extra_slow_workers'],
        ['.ai-disable-batching', 'disable_batching'],
        ['.ai-allow-downgrade', 'allow_downgrade']
      ];
      boolPairs.forEach(([selector, key]) => {
        const input = card.querySelector(selector);
        if (input) input.checked = !!preset[key];
      });
      const saveOutput = card.querySelector('.ai-save-output');
      if (saveOutput) saveOutput.checked = !!preset.save_output;
      const nsfw = card.querySelector('.ai-nsfw');
      if (nsfw) nsfw.checked = !!preset.nsfw;
      const censor = card.querySelector('.ai-censor');
      if (censor) censor.checked = !!preset.censor_nsfw;
      const postChecks = card.querySelectorAll('.ai-post-proc');
      if (postChecks.length) {
        const selected = new Set(Array.isArray(preset.post_processing) ? preset.post_processing : []);
        postChecks.forEach(chk => {
          chk.checked = selected.has(chk.value);
        });
      }
      if (loraList) {
        loraList.innerHTML = '';
        const loras = Array.isArray(preset.loras) ? preset.loras : [];
        loras.forEach(lora => {
          const row = appendEmptyLoraRow();
          if (!row) return;
          const nameInput = row.querySelector('.ai-lora-name');
          if (nameInput) nameInput.value = lora && lora.name ? lora.name : '';
          const modelInput = row.querySelector('.ai-lora-model');
          if (modelInput) modelInput.value = lora && lora.model !== undefined && lora.model !== null ? String(lora.model) : '';
          const clipInput = row.querySelector('.ai-lora-clip');
          if (clipInput) clipInput.value = lora && lora.clip !== undefined && lora.clip !== null ? String(lora.clip) : '';
          const triggerInput = row.querySelector('.ai-lora-trigger');
          if (triggerInput) triggerInput.value = lora && lora.inject_trigger ? lora.inject_trigger : '';
          const flagInput = row.querySelector('.ai-lora-is-version');
          if (flagInput) flagInput.checked = !!(lora && lora.is_version);
        });
        updateLoraAddState();
      }
      const autoModeSelect = card.querySelector('.ai-auto-mode');
      if (autoModeSelect) {
        const modeValue = typeof preset.auto_generate_mode === 'string' ? preset.auto_generate_mode.toLowerCase() : 'off';
        autoModeSelect.value = modeValue;
        updateAutoVisibility();
      }
      const autoIntervalInput = card.querySelector('.ai-auto-interval');
      if (autoIntervalInput) {
        const interval = Number(preset.auto_generate_interval_value);
        autoIntervalInput.value = Number.isFinite(interval) ? String(interval) : '';
      }
      const autoUnitSelect = card.querySelector('.ai-auto-interval-unit');
      if (autoUnitSelect) {
        const unit = typeof preset.auto_generate_interval_unit === 'string' ? preset.auto_generate_interval_unit.toLowerCase() : 'minutes';
        autoUnitSelect.value = unit === 'hours' ? 'hours' : 'minutes';
      }
      const autoClockInputEl = card.querySelector('.ai-auto-clock');
      if (autoClockInputEl) autoClockInputEl.value = preset.auto_generate_clock_time || '';
      if (aiSection) {
        const timeoutValue = Number(preset.timeout);
        if (Number.isFinite(timeoutValue) && timeoutValue > 0) {
          aiSection.dataset.timeout = String(timeoutValue);
        } else {
          aiSection.dataset.timeout = '';
        }
      }
      updateSummary();
    }

    async function applyPresetByName(presetName) {
      if (!presetName || applyingPreset) return;
      applyingPreset = true;
      try {
        const presets = await fetchAiPresets();
        const preset = presets.find(item => item.name === presetName);
        if (!preset) {
          showNotification(`Preset "${presetName}" not found`);
          populatePresetSelect(presetSelect, presets);
          return;
        }
        applyPresetSettings(preset.settings || {});
        const payload = collectAiPayload(card);
        const result = await saveSettings(streamId, { ai_settings: payload });
        if (!result || result.error) return;
        showNotification(`Preset "${presetName}" applied`);
      } catch (err) {
        showNotification(err && err.message ? err.message : 'Failed to apply preset');
      } finally {
        applyingPreset = false;
      }
    }

    function syncLoras() {
      if (!loraSection) return;
      const loras = gatherLoras(card);
      saveSettings(streamId, { ai_settings: { loras } });
      updateLoraAddState();
      updateSummary();
    }

    function bindLoraRow(row) {
      if (!row) return;
      const inputs = row.querySelectorAll('input');
      inputs.forEach(input => {
        const handler = () => syncLoras();
        input.addEventListener('change', handler);
        if (input.type === 'text') {
          input.addEventListener('blur', handler);
        }
      });
      const removeBtn = row.querySelector('.ai-lora-remove');
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          row.remove();
          syncLoras();
        });
      }
    }
    bindNumeric('.ai-width-input', 'width');
    bindNumeric('.ai-height-input', 'height');
    bindNumeric('.ai-steps-input', 'steps');
    bindNumeric('.ai-cfg-input', 'cfg_scale');
    bindNumeric('.ai-samples-input', 'samples');
    [
      ['.ai-hires-fix', 'hires_fix'],
      ['.ai-karras', 'karras'],
      ['.ai-tiling', 'tiling'],
      ['.ai-transparent', 'transparent'],
      ['.ai-trusted-workers', 'trusted_workers'],
      ['.ai-validated-backends', 'validated_backends'],
      ['.ai-slow-workers', 'slow_workers'],
      ['.ai-extra-slow-workers', 'extra_slow_workers'],
      ['.ai-disable-batching', 'disable_batching'],
      ['.ai-allow-downgrade', 'allow_downgrade'],
    ].forEach(([selector, key]) => bindCheckboxSetting(selector, key));
    bindOptionalNumber('.ai-clip-skip', 'clip_skip', raw => parseInt(raw, 10));
    bindOptionalNumber('.ai-facefixer', 'facefixer_strength', raw => parseFloat(raw));
    bindOptionalNumber('.ai-denoise', 'denoising_strength', raw => parseFloat(raw));
    bindOptionalNumber('.ai-hires-denoise', 'hires_fix_denoising_strength', raw => parseFloat(raw));
    const saveOutput = card.querySelector('.ai-save-output');
    if (saveOutput) {
      saveOutput.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { save_output: e.target.checked } });
        updateSummary();
      });
    }
    const nsfw = card.querySelector('.ai-nsfw');
    if (nsfw) {
      nsfw.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { nsfw: e.target.checked } });
      });
    }
    const censor = card.querySelector('.ai-censor');
    if (censor) {
      censor.addEventListener('change', e => {
        saveSettings(streamId, { ai_settings: { censor_nsfw: e.target.checked } });
      });
    }
    const styleInput = card.querySelector('.ai-style-input');
    if (styleInput) {
      styleInput.addEventListener('blur', e => {
        saveSettings(streamId, { ai_settings: { style: e.target.value.trim() } });
      });
    }
    const postProcChecks = card.querySelectorAll('.ai-post-proc');
    if (postProcChecks.length) {
      postProcChecks.forEach(chk => {
        chk.addEventListener('change', () => {
          saveSettings(streamId, { ai_settings: { post_processing: gatherPostProcessing(card) } });
          updateSummary();
        });
      });
    }
    if (loraSection) {
      const addLoraBtn = loraSection.querySelector('.ai-add-lora');
      if (addLoraBtn) {
        addLoraBtn.addEventListener('click', () => {
          appendEmptyLoraRow();
          updateSummary();
        });
      }
      if (loraSearchBtn) {
        loraSearchBtn.addEventListener('click', () => {
          performLoraSearch(loraSearchInput ? loraSearchInput.value : '');
        });
      }
      if (loraSearchInput) {
        loraSearchInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            performLoraSearch(loraSearchInput.value);
          }
        });
      }
      if (loraList) {
        loraList.querySelectorAll('.ai-lora-row').forEach(row => bindLoraRow(row));
      }
      updateLoraAddState();
    }
    const generateButtons = card.querySelectorAll('.ai-generate-btn');
    const setGenerateDisabled = disabled => {
      generateButtons.forEach(btn => { btn.disabled = !!disabled; });
    };
    if (generateButtons.length) {
      const handleGenerate = async () => {
        const payload = collectAiPayload(card);
        if (!payload.prompt || !payload.prompt.trim()) {
          showNotification('Prompt is required for AI generation');
          if (promptInput) promptInput.focus();
          return;
        }
        updateSummary();
        setGenerateDisabled(true);
        renderAiStatus(card, { status: 'queued' }, { status: 'queued' });
        try {
          const res = await fetch(`/ai/generate/${encodeURIComponent(streamId)}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || data.error) {
            const note = data.error || `Request failed (${res.status})`;
            showNotification(note);
            renderAiStatus(card, { status: 'error', message: note }, { status: 'error', message: note });
            setGenerateDisabled(false);
            return;
          }
          if (data.job) {
            aiActiveJobs.set(streamId, data.job);
          }
          if (data.state) {
            renderAiStatus(card, data.state, data.job || null);
          }
          showNotification('AI generation queued');
        } catch (err) {
          console.error('AI generate failed', err);
          showNotification('AI generation failed to start');
          renderAiStatus(card, { status: 'error', message: 'Request failed' }, { status: 'error', message: 'Request failed' });
          setGenerateDisabled(false);
        }
      };
      generateButtons.forEach(btn => btn.addEventListener('click', handleGenerate));
    }

    const cancelButtons = card.querySelectorAll('.ai-cancel-btn');
    const setCancelDisabled = disabled => {
      cancelButtons.forEach(btn => { btn.disabled = !!disabled; });
    };
    if (cancelButtons.length) {
      const handleCancel = async event => {
        event.preventDefault();
        const currentJob = aiActiveJobs.get(streamId) || null;
        const currentStatus = (currentJob && currentJob.status) || (card.querySelector('.ai-status')?.dataset.status || 'idle');
        setCancelDisabled(true);
        try {
          const res = await fetch(`/ai/cancel/${encodeURIComponent(streamId)}`, { method: 'POST' });
          let data = null;
          try {
            data = await res.json();
          } catch (parseErr) {
            data = null;
          }
          if (!res.ok || (data && data.error)) {
            const note = data && (data.error || data.detail) || `Request failed (${res.status})`;
            showNotification(note);
            throw new Error(note);
          }
          const updatedJob = Object.assign({}, currentJob || {}, { status: 'cancelling', message: 'Cancellation requested', cancel_requested: true });
          aiActiveJobs.set(streamId, updatedJob);
          renderAiStatus(card, { status: 'cancelling', message: 'Cancellation requested' }, updatedJob);
          const label = data && data.status ? `AI ${data.status}` : 'Cancellation requested';
          showNotification(label);
          if (data && data.warning) {
            showNotification(data.warning);
          }
        } catch (err) {
          console.error('AI cancel failed', err);
          const message = err && err.message ? err.message : 'Failed to cancel job';
          showNotification(message);
          setCancelDisabled(false);
          const revertJob = currentJob ? Object.assign({}, currentJob) : null;
          renderAiStatus(card, { status: currentStatus, message: revertJob && revertJob.message ? revertJob.message : undefined }, revertJob);
        }
      };
      cancelButtons.forEach(btn => btn.addEventListener('click', handleCancel));
    }

    const resultsEl = card.querySelector('.ai-results');
    if (resultsEl) {
      resultsEl.addEventListener('click', e => {
        const target = e.target.closest('.ai-generated-item');
        if (!target || !target.dataset.path) return;
        const path = target.dataset.path;
        highlightAiSelection(resultsEl, path);
        saveSettings(streamId, { selected_image: path });
        const display = card.querySelector('.selected-image-display');
        if (display) display.textContent = path || 'None';
      });
    }
    if (modeSelect) {
      if (modeSelect.value === 'ai' && modelSelect) {
        modelSelect.dispatchEvent(new Event('focus'));
      }
      modeSelect.addEventListener('change', e => {
        if (e.target.value === 'ai' && modelSelect) {
          modelSelect.dispatchEvent(new Event('focus'));
        }
      });
    }
    renderAiStatus(card, { status: card.querySelector('.ai-status')?.dataset.status || 'idle' }, aiActiveJobs.get(streamId) || null);
    highlightAiSelection(resultsEl, resultsEl ? resultsEl.dataset.selected || '' : '');
  }

  function saveSettings(streamId, payload, opts = {}) {
    return fetch(`/settings/${encodeURIComponent(streamId)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
      if (data.status === 'success') {
        showNotification(`Updated settings for ${streamId}`);
        const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
        if (card) {
          const modeCategorySelect = card.querySelector('.mode-category-select');
          const modeVariantSelect = card.querySelector('.mode-select');
          const urlInputEl = card.querySelector('.stream-url-input');
          let updatedMediaMode = (modeCategorySelect ? modeCategorySelect.value : (card.dataset.mediaMode || 'image')).toLowerCase();
          let updatedMode = modeVariantSelect ? (modeVariantSelect.value || '').toLowerCase() : ((updatedMediaMode === 'livestream' || updatedMediaMode === 'ai') ? updatedMediaMode : 'random');

          if (data.new_config && (data.new_config.selected_image !== undefined || data.new_config.selected_media_kind !== undefined)) {
            const selectedPath = data.new_config.selected_image || "";
            const selectedKind = (data.new_config.selected_media_kind || card.dataset.selectedKind || '').toLowerCase();
            card.dataset.selectedPath = selectedPath;
            card.dataset.selectedKind = selectedKind;
            const displayText = selectedPath ? (selectedKind === 'video' ? `${selectedPath} (video)` : selectedPath) : 'None';
            const disp = card.querySelector('.selected-image-display');
            if (disp) disp.textContent = displayText;
            const aiResults = card.querySelector('.ai-results');
            if (aiResults) {
              highlightAiSelection(aiResults, selectedPath);
            }
          }
          if (data.new_config && data.new_config.video_playback_mode !== undefined) {
            const nextMode = (data.new_config.video_playback_mode || 'duration').toLowerCase();
            card.dataset.videoMode = nextMode;
            const videoModeSelect = card.querySelector('.video-mode-select');
            if (videoModeSelect) videoModeSelect.value = nextMode;
          }
          if (data.new_config && data.new_config.video_volume !== undefined) {
            const volumeValue = Number(data.new_config.video_volume);
            card.dataset.videoVolume = String(volumeValue);
            card.dataset.videoVolumePersisted = String(volumeValue);
            const volumeSlider = card.querySelector('.video-volume-slider');
            if (volumeSlider) {
              const pct = Math.max(0, Math.min(1, Number.isFinite(volumeValue) ? volumeValue : 1)) * 100;
              volumeSlider.value = String(Math.round(pct));
            }
          }
          if (data.new_config && data.new_config.image_quality !== undefined) {
            const qualitySelect = card.querySelector('.image-quality-select');
            if (qualitySelect) {
              qualitySelect.value = (data.new_config.image_quality || 'auto');
            }
          }
          if (data.new_config && data.new_config.hide_nsfw !== undefined) {
            card.dataset.hideNsfw = data.new_config.hide_nsfw ? 'true' : 'false';
            const hideToggle = card.querySelector('.hide-nsfw-toggle');
            if (hideToggle) {
              hideToggle.checked = !!data.new_config.hide_nsfw;
            }
          }
          if (data.new_config && data.new_config.background_blur_enabled !== undefined) {
            const enabled = !!data.new_config.background_blur_enabled;
            const bgToggle = card.querySelector('.background-toggle');
            const slider = card.querySelector('.background-blur-slider');
            const wrap = card.querySelector('.background-blur-slider-wrap');
            if (bgToggle) bgToggle.checked = enabled;
            if (slider) slider.disabled = !enabled;
            if (wrap) wrap.classList.toggle('is-disabled', !enabled);
          }
          if (data.new_config && data.new_config.background_blur_amount !== undefined) {
            const amount = Number(data.new_config.background_blur_amount) || 0;
            const slider = card.querySelector('.background-blur-slider');
            const valEl = card.querySelector('.background-blur-value');
            if (slider) slider.value = String(amount);
            if (valEl) valEl.textContent = `${amount}%`;
          }
          if (data.new_config && data.new_config.tags !== undefined) {
            const tagList = Array.isArray(data.new_config.tags) ? data.new_config.tags : [];
            setCardTags(card, tagList);
            applyFiltersAndSorting();
            renderTagManager();
          }
          if (Array.isArray(data.tags)) {
            syncGlobalTags(data.tags);
          }

          if (data.new_config && data.new_config.media_mode !== undefined) {
            updatedMediaMode = String(data.new_config.media_mode || 'image').toLowerCase();
          }
          card.dataset.mediaMode = updatedMediaMode;
          if (modeCategorySelect) modeCategorySelect.value = updatedMediaMode;

          if (data.new_config && data.new_config.mode !== undefined) {
            const normalizedMode = String(data.new_config.mode || '').toLowerCase();
            if (normalizedMode) {
              updatedMode = normalizedMode;
            }
          }
          if (modeVariantSelect && updatedMode) {
            modeVariantSelect.value = updatedMode;
          }
          const effectiveMode = updatedMode || ((updatedMediaMode === 'livestream' || updatedMediaMode === 'ai') ? updatedMediaMode : 'random');
          applyModeState(card, updatedMediaMode, effectiveMode, urlInputEl ? urlInputEl.value : '');

          const aiSettings = data.new_config && data.new_config.ai_settings;
          if (aiSettings) {
            const aiSection = card.querySelector('.ai-generator');
            if (aiSection) {
              const timeoutValue = aiSettings.timeout;
              if (timeoutValue !== undefined && timeoutValue !== null) {
                const numericTimeout = Number(timeoutValue);
                if (Number.isFinite(numericTimeout) && numericTimeout > 0) {
                  aiSection.dataset.timeout = String(numericTimeout);
                } else {
                  aiSection.dataset.timeout = '';
                }
              }
            }
            const autoWrapper = card.querySelector('.ai-auto-settings');
            if (autoWrapper) {
              const modeSelect = autoWrapper.querySelector('.ai-auto-mode');
              const intervalInput = autoWrapper.querySelector('.ai-auto-interval');
              const unitSelect = autoWrapper.querySelector('.ai-auto-interval-unit');
              const clockInput = autoWrapper.querySelector('.ai-auto-clock');
              const timerRow = autoWrapper.querySelector('.ai-auto-timer-row');
              const clockRow = autoWrapper.querySelector('.ai-auto-clock-row');
              const normalizedMode = typeof aiSettings.auto_generate_mode === 'string' ? aiSettings.auto_generate_mode.toLowerCase() : 'off';
              if (modeSelect) modeSelect.value = normalizedMode;
              if (intervalInput && aiSettings.auto_generate_interval !== undefined) {
                intervalInput.value = aiSettings.auto_generate_interval;
              }
              if (unitSelect && aiSettings.auto_generate_interval_unit) {
                unitSelect.value = aiSettings.auto_generate_interval_unit;
              }
              if (clockInput && aiSettings.auto_generate_clock) {
                clockInput.value = aiSettings.auto_generate_clock;
              }
              if (timerRow) timerRow.hidden = normalizedMode !== 'timer';
              if (clockRow) clockRow.hidden = normalizedMode !== 'clock';
            }
          }
          if (data.new_config && data.new_config.ai_state) {
            updateAutoIndicators(card, data.new_config.ai_state);
          }
          const updater = aiSummaryUpdaters.get(card);
          if (updater) updater();
        }
        if (opts.onSuccess) opts.onSuccess(data, card);
      } else {
        console.error(data.error || 'Unknown error updating settings.');
        showNotification(data.error || 'Error updating settings');
        if (opts.onError) opts.onError(data);
      }
      return data;
    })
    .catch(err => {
      console.error('Error saving settings:', err);
      showNotification('Error updating settings');
      if (opts.onError) opts.onError(err);
      return null;
    })
    .finally(() => {
      if (opts.onFinally) opts.onFinally();
    });
  }

  function filterFolderOptions(card, mediaMode) {
    const select = card.querySelector('.folder-select');
    if (!select) {
      return;
    }
    const normalized = typeof mediaMode === 'string' ? mediaMode.toLowerCase() : 'image';
    const wantsImages = normalized === 'image';
    const wantsVideos = normalized === 'video';
    const shouldFilter = wantsImages || wantsVideos;
    const options = Array.from(select.options);
    options.forEach(option => {
      if (option.dataset.filtered === 'true') {
        option.hidden = false;
        return;
      }
      if (!shouldFilter) {
        option.hidden = false;
        return;
      }
      const hasImages = option.dataset.hasImages === 'true';
      const hasVideos = option.dataset.hasVideos === 'true';
      const isVisible = wantsImages ? hasImages : hasVideos;
      option.hidden = !isVisible;
    });
    const selectedOption = select.options[select.selectedIndex];
    if (selectedOption && selectedOption.hidden) {
      const fallback = options.find(opt => !opt.hidden && opt.dataset.filtered !== 'true');
      if (fallback) {
        select.value = fallback.value;
        select.dataset.currentFolder = fallback.value || 'all';
        const streamId = card.dataset.stream;
        if (streamId) {
          const folder = fallback.value || 'all';
          card.dataset.selectedPath = '';
          card.dataset.selectedKind = '';
          const display = card.querySelector('.selected-image-display');
          if (display) display.textContent = 'None';
          saveSettings(streamId, { folder, selected_image: null, selected_media_kind: null });
          loadMediaFor(streamId, folder);
        }
      }
    }
  }

  async function refreshFoldersForCard(card, hideNsfw) {
    const folderSelect = card.querySelector('.folder-select');
    if (!folderSelect) {
      return null;
    }
    const url = hideNsfw ? '/folders?hide_nsfw=1' : '/folders';
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to fetch folders');
      }
      const items = await response.json();
      if (!Array.isArray(items)) {
        return null;
      }
      const assigned = folderSelect.dataset.currentFolder || 'all';
      const assignedLower = (assigned || '').toLowerCase();
      const hasAssigned = items.some(entry => entry && entry.name === assigned);
      const shouldShowPlaceholder = Boolean(hideNsfw) && assigned && assignedLower.includes('nsfw') && !hasAssigned;
      const frag = document.createDocumentFragment();
      if (shouldShowPlaceholder) {
        const placeholder = document.createElement('option');
        placeholder.value = '__filtered__';
        placeholder.textContent = `Filtered (${assigned})`;
        placeholder.title = assigned;
        placeholder.dataset.filtered = 'true';
        placeholder.selected = true;
        frag.appendChild(placeholder);
      }
      items.forEach(entry => {
        if (!entry || !entry.name) {
          return;
        }
        const name = String(entry.name);
        if (hideNsfw && name.toLowerCase().includes('nsfw')) {
          return;
        }
        const opt = document.createElement('option');
        opt.value = name;
        opt.title = name;
        opt.textContent = name;
        opt.dataset.hasImages = entry.has_images ? 'true' : 'false';
        opt.dataset.hasVideos = entry.has_videos ? 'true' : 'false';
        if (!shouldShowPlaceholder && assigned === name) {
          opt.selected = true;
        }
        frag.appendChild(opt);
      });
      folderSelect.replaceChildren(frag);
      let currentSelection = folderSelect.dataset.currentFolder || 'all';
      if (shouldShowPlaceholder) {
        folderSelect.value = '__filtered__';
        folderSelect.title = assigned;
        folderSelect.dataset.currentFolder = assigned;
        currentSelection = assigned || 'all';
      } else {
        const selectedOption = folderSelect.options[folderSelect.selectedIndex];
        if (selectedOption) {
          folderSelect.dataset.currentFolder = selectedOption.value || 'all';
          folderSelect.title = selectedOption.title || selectedOption.textContent || folderSelect.value;
          currentSelection = folderSelect.dataset.currentFolder;
        } else if (folderSelect.options.length) {
          const first = folderSelect.options[0];
          first.selected = true;
          folderSelect.dataset.currentFolder = first.value || 'all';
          folderSelect.title = first.title || first.textContent || folderSelect.value;
          currentSelection = folderSelect.dataset.currentFolder;
        } else {
          folderSelect.dataset.currentFolder = 'all';
          folderSelect.title = 'all';
          currentSelection = 'all';
        }
      }
      filterFolderOptions(card, card.dataset.mediaMode || 'image');
      const streamId = card.dataset.stream;
      if (streamId) {
        loadMediaFor(streamId, currentSelection || 'all');
      }
      return currentSelection;
    } catch (err) {
      console.error('Failed to refresh folders', err);
      return null;
    }
  }

  function applyModeState(card, mediaMode, mode, streamUrl) {
    const normalizedMedia = typeof mediaMode === 'string' ? mediaMode.toLowerCase() : 'image';
    const normalizedMode = typeof mode === 'string' ? mode.toLowerCase() : '';
    const isImage = normalizedMedia === 'image';
    const isVideo = normalizedMedia === 'video';
    const isLivestream = normalizedMedia === 'livestream';
    const isAi = normalizedMedia === 'ai';
    const isRandom = normalizedMode === 'random';
    const isSpecific = normalizedMode === 'specific';

    const durationDiv = card.querySelector('.duration-container');
    const shuffleChk = card.querySelector('.shuffle-chk');
    const shuffleLabel = shuffleChk ? shuffleChk.closest('label') : null;
    const urlDiv = card.querySelector('.stream-url-container');
    const imagePicker = card.querySelector('.image-picker');
    const variantWrapper = card.querySelector('.mode-variant-wrapper');
    const modeSelect = card.querySelector('.mode-select');
    const videoModeRow = card.querySelector('.video-mode-row');
    const videoModeSelect = card.querySelector('.video-mode-select');
    const playbackRow = card.querySelector('.playback-controls-row');
    const ytSettingsDiv = card.querySelector('.yt-settings');
    const selectedRow = card.querySelector('.selected-image-row');
    const folderRow = card.querySelector('.folder-row');
    const qualityRow = card.querySelector('.image-quality-row');
    const nsfwRow = card.querySelector('.nsfw-row');
    const backgroundRow = card.querySelector('.background-row');
    const aiSection = card.querySelector('.ai-generator');
    const aiSummary = card.querySelector('.ai-summary');

    const showVariant = isImage || isVideo;
    if (variantWrapper) {
      variantWrapper.style.display = showVariant ? '' : 'none';
    }
    if (modeSelect) {
      const options = Array.from(modeSelect.options);
      options.forEach(opt => {
        const category = (opt.dataset.category || 'image').toLowerCase();
        const visible = showVariant && category === normalizedMedia;
        opt.hidden = !visible;
      });
      if (showVariant) {
        const matching = options.find(opt => !opt.hidden && opt.value === normalizedMode);
        if (matching) {
          modeSelect.value = matching.value;
        } else {
          const fallback = options.find(opt => !opt.hidden);
          if (fallback) modeSelect.value = fallback.value;
        }
        modeSelect.disabled = false;
      } else {
        modeSelect.disabled = true;
      }
    }

    if (durationDiv) durationDiv.style.display = (isRandom && (isImage || isVideo)) ? '' : 'none';
    if (shuffleLabel) shuffleLabel.style.display = (isRandom && (isImage || isVideo)) ? '' : 'none';
    if (urlDiv) urlDiv.style.display = isLivestream ? '' : 'none';
    if (imagePicker) imagePicker.style.display = (isSpecific && (isImage || isVideo)) ? '' : 'none';
    if (videoModeRow) videoModeRow.style.display = (isVideo && isRandom) ? '' : 'none';
    if (playbackRow) playbackRow.style.display = isVideo ? '' : 'none';

    if (isAi) {
      if (aiSummary) aiSummary.style.display = '';
      if (aiSection && !card.classList.contains('ai-settings-open')) {
        aiSection.setAttribute('aria-hidden', 'true');
      }
    } else {
      if (aiSummary) aiSummary.style.display = 'none';
      if (aiSection) aiSection.setAttribute('aria-hidden', 'true');
      closeAiSettings(card);
    }
    const summaryUpdater = aiSummaryUpdaters.get(card);
    if (summaryUpdater) summaryUpdater();

    if (selectedRow) {
      const showSelected = (isSpecific && (isImage || isVideo)) || isAi;
      selectedRow.style.display = showSelected ? '' : 'none';
    }
    if (folderRow) folderRow.style.display = (isImage || isVideo) ? '' : 'none';
    if (nsfwRow) nsfwRow.style.display = isLivestream ? 'none' : '';
    if (qualityRow) qualityRow.style.display = (isLivestream || isVideo) ? 'none' : '';
    if (backgroundRow) backgroundRow.style.display = (isLivestream || isVideo) ? 'none' : '';

    if (videoModeSelect) {
      if (isVideo && isRandom) {
        const current = (videoModeSelect.value || '').toLowerCase();
        if (current !== 'duration' && current !== 'until_end') {
          videoModeSelect.value = 'duration';
        }
        videoModeSelect.disabled = false;
      } else {
        videoModeSelect.disabled = true;
        if (isVideo) {
          videoModeSelect.value = 'loop';
        }
      }
    }

    const urlType = detectUrlType(streamUrl);
    if (ytSettingsDiv) ytSettingsDiv.style.display = (isLivestream && urlType === 'YouTube') ? '' : 'none';

    filterFolderOptions(card, normalizedMedia);
  }

  function loadMediaFor(streamId, folder) {
    const card = document.querySelector(`.stream-card[data-stream="${streamId}"]`);
    if (!card) return;
    const grid = card.querySelector('.image-picker .image-grid');
    if (!grid) return;
    const hideNsfw = card.dataset.hideNsfw === 'true';
    const params = new URLSearchParams({ folder });
    if (hideNsfw) {
      params.set('hide_nsfw', '1');
    }
    if (mediaMode === 'image') {
      params.set('kind', 'image');
    } else if (mediaMode === 'video') {
      params.set('kind', 'video');
    }
    grid.textContent = 'Loading...';
    fetch(`/media?${params.toString()}`)
      .then(res => res.json())
      .then(items => {
        const list = Array.isArray(items) ? items : [];
        const selectedPath = card.dataset.selectedPath || '';
        const selectedKind = card.dataset.selectedKind || '';
        grid.innerHTML = '';
        if (!list.length) {
          grid.textContent = '(No media found in this folder)';
          return;
        }
        const frag = document.createDocumentFragment();
        list.forEach(item => {
          if (!item || !item.path) {
            return;
          }
          const kind = (item.kind || '').toLowerCase() === 'video' ? 'video' : 'image';
          if (mediaMode === 'image' && kind !== 'image') {
            return;
          }
          if (mediaMode === 'video' && kind !== 'video') {
            return;
          }
          const tile = document.createElement('div');
          tile.className = 'picker-thumbnail media-thumb';
          tile.dataset.path = item.path;
          tile.dataset.kind = kind;
          if (item.path === selectedPath && (!selectedKind || selectedKind === kind)) {
            tile.classList.add('selected-thumb');
          }
          if (kind === 'image') {
            const img = document.createElement('img');
            img.src = `/stream/image/${item.path}?size=thumb`;
            img.alt = item.path;
            tile.appendChild(img);
          } else {
            tile.classList.add('media-thumb-video');
            const icon = document.createElement('span');
            icon.className = 'media-icon';
            icon.textContent = 'Video';
            const label = document.createElement('span');
            label.className = 'media-label';
            label.textContent = item.path.split('/').pop();
            tile.append(icon, label);
          }
          tile.addEventListener('click', () => {
            card.dataset.selectedPath = item.path;
            card.dataset.selectedKind = kind;
            grid.querySelectorAll('.media-thumb').forEach(el => el.classList.remove('selected-thumb'));
            tile.classList.add('selected-thumb');
            const display = card.querySelector('.selected-image-display');
            if (display) {
              display.textContent = kind === 'video' ? `${item.path} (video)` : item.path;
            }
            saveSettings(streamId, { selected_image: item.path, selected_media_kind: kind });
          });
          frag.appendChild(tile);
        });
        grid.appendChild(frag);
      })
      .catch(err => {
        console.error('Error fetching media for folder:', err);
        grid.textContent = 'Error loading media.';
      });
  }

  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.stream-card').forEach(card => {
      const streamId = card.dataset.stream;
      if (streamId) {
        attachTagEditor(card);
      }
      setupAiControls(card, streamId);
      // Card menu toggle per card
      const menuBtn = card.querySelector('.menu-button');
      const menuDd = card.querySelector('.card-menu .menu-dropdown');
      if (menuBtn && menuDd) {
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const isOpen = !menuDd.hidden;
          document.querySelectorAll('.card-menu .menu-dropdown').forEach(dd => dd.hidden = true);
          menuDd.hidden = isOpen;
          menuBtn.setAttribute('aria-expanded', String(!isOpen));
        });
      }
      // Folder change
      const folderSelect = card.querySelector('.folder-select');
      if (folderSelect) {
        const initialOption = folderSelect.options[folderSelect.selectedIndex];
        const initialAssigned = folderSelect.dataset.currentFolder || (initialOption ? (initialOption.dataset.filtered === 'true' ? (initialOption.title || 'all') : (initialOption.value || 'all')) : 'all');
        folderSelect.dataset.currentFolder = initialAssigned || 'all';
        if (initialOption) {
          folderSelect.title = initialOption.title || initialOption.textContent || folderSelect.value;
        } else {
          folderSelect.title = folderSelect.dataset.currentFolder || 'all';
        }
        folderSelect.addEventListener('change', e => {
          const selectEl = e.target;
          if (selectEl.value === '__filtered__') {
            const filteredOption = selectEl.options[selectEl.selectedIndex];
            selectEl.title = filteredOption ? (filteredOption.title || filteredOption.textContent || selectEl.title) : selectEl.title;
            return;
          }
          const folder = selectEl.value || 'all';
          selectEl.dataset.currentFolder = folder;
          const filteredOption = selectEl.querySelector('option[data-filtered="true"]');
          if (filteredOption) {
            filteredOption.remove();
          }
          const selectedOption = selectEl.options[selectEl.selectedIndex];
          if (selectedOption) {
            selectEl.title = selectedOption.title || selectedOption.textContent || folder;
          } else {
            selectEl.title = folder;
          }
          card.dataset.selectedPath = '';
          card.dataset.selectedKind = '';
          const display = card.querySelector('.selected-image-display');
          if (display) display.textContent = 'None';
          saveSettings(streamId, { folder, selected_image: null, selected_media_kind: null });
          loadMediaFor(streamId, folder);
        });
      }
      const hideNsfwToggle = card.querySelector('.hide-nsfw-toggle');
      if (hideNsfwToggle) {
        hideNsfwToggle.addEventListener('change', e => {
          const enabled = e.target.checked;
          hideNsfwToggle.disabled = true;
          saveSettings(streamId, { hide_nsfw: enabled }, {
            onSuccess: () => {
              const refreshResult = refreshFoldersForCard(card, enabled);
              if (refreshResult && typeof refreshResult.then === 'function') {
                refreshResult.finally(() => {
                  hideNsfwToggle.disabled = false;
                });
              } else {
                hideNsfwToggle.disabled = false;
              }
            },
            onError: () => {
              hideNsfwToggle.checked = !enabled;
              hideNsfwToggle.disabled = false;
            }
          });
        });
      }
      const imageQualitySelect = card.querySelector('.image-quality-select');
      if (imageQualitySelect) {
        imageQualitySelect.addEventListener('change', e => {
          const nextValue = e.target.value || 'auto';
          saveSettings(streamId, { image_quality: nextValue });
        });
      }
      const backgroundToggle = card.querySelector('.background-toggle');
      const backgroundSlider = card.querySelector('.background-blur-slider');
      const backgroundValue = card.querySelector('.background-blur-value');
      const backgroundWrap = card.querySelector('.background-blur-slider-wrap');
      if (backgroundToggle) {
        backgroundToggle.addEventListener('change', e => {
          const enabled = e.target.checked;
          if (backgroundSlider) backgroundSlider.disabled = !enabled;
          if (backgroundWrap) backgroundWrap.classList.toggle('is-disabled', !enabled);
          saveSettings(streamId, { background_blur_enabled: enabled });
        });
      }
      if (backgroundSlider) {
        backgroundSlider.addEventListener('input', e => {
          if (backgroundValue) backgroundValue.textContent = `${e.target.value}%`;
        });
        backgroundSlider.addEventListener('change', e => {
          const amount = Number(e.target.value);
          saveSettings(streamId, { background_blur_amount: amount });
        });
      }
      const videoModeSelect = card.querySelector('.video-mode-select');
      if (videoModeSelect) {
        const initialMode = (card.dataset.videoMode || videoModeSelect.value || 'duration').toLowerCase();
        videoModeSelect.value = initialMode;
        card.dataset.videoMode = initialMode;
        videoModeSelect.addEventListener('change', e => {
          const nextMode = (e.target.value || 'duration').toLowerCase();
          card.dataset.videoMode = nextMode;
          saveSettings(streamId, { video_playback_mode: nextMode });
        });
      }
      const playbackButtons = card.querySelectorAll('.playback-controls .playback-btn');
      playbackButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (!action) return;
          socket.emit('video_control', { stream_id: streamId, action });
        });
      });
      const volumeSlider = card.querySelector('.video-volume-slider');
      if (volumeSlider) {
        const fromSlider = value => {
          const num = Number(value);
          if (!Number.isFinite(num)) return 1;
          return Math.max(0, Math.min(100, num)) / 100;
        };
        const datasetAttr = card.dataset.videoVolume;
        const datasetVol = (datasetAttr !== undefined && datasetAttr !== '') ? Number(datasetAttr) : NaN;
        const initialVol = Number.isFinite(datasetVol) ? Math.max(0, Math.min(1, datasetVol)) : fromSlider(volumeSlider.value);
        volumeSlider.value = String(Math.round(initialVol * 100));
        card.dataset.videoVolume = String(initialVol);
        card.dataset.videoVolumePersisted = card.dataset.videoVolumePersisted || String(initialVol);
        volumeSlider.addEventListener('input', e => {
          const normalized = fromSlider(e.target.value);
          card.dataset.videoVolume = String(normalized);
          socket.emit('video_control', { stream_id: streamId, action: 'set_volume', volume: normalized });
        });
        volumeSlider.addEventListener('change', e => {
          const normalized = fromSlider(e.target.value);
          card.dataset.videoVolume = String(normalized);
          const persisted = Number(card.dataset.videoVolumePersisted);
          if (Number.isFinite(persisted) && Math.abs(normalized - persisted) <= 0.005) {
            volumeSlider.value = String(Math.round(Math.max(0, Math.min(1, persisted)) * 100));
            return;
          }
          saveSettings(streamId, { video_volume: normalized });
        });
      }
      // Mode change
      const modeCategorySelect = card.querySelector('.mode-category-select');
      const modeSelect = card.querySelector('.mode-select');
      const urlInput = card.querySelector('.stream-url-input');

      const getCurrentMediaMode = () => {
        return (modeCategorySelect ? modeCategorySelect.value : (card.dataset.mediaMode || 'image')).toLowerCase();
      };

      const getStreamUrl = () => (urlInput ? urlInput.value : '');

      if (modeCategorySelect) {
        modeCategorySelect.addEventListener('change', e => {
          const mediaMode = (e.target.value || 'image').toLowerCase();
          card.dataset.mediaMode = mediaMode;
          let nextMode = (modeSelect && !modeSelect.disabled) ? (modeSelect.value || 'random').toLowerCase() : 'random';
          if (mediaMode === 'image' || mediaMode === 'video') {
            if (nextMode !== 'random' && nextMode !== 'specific') {
              nextMode = 'random';
              if (modeSelect) modeSelect.value = nextMode;
            }
          } else if (mediaMode === 'livestream') {
            nextMode = 'livestream';
          } else {
            nextMode = 'ai';
          }
          const payload = { media_mode: mediaMode, mode: nextMode };
          if ((mediaMode === 'image' || mediaMode === 'video') && nextMode === 'random') {
            const durInput = card.querySelector('.duration-input');
            if (durInput) payload.duration = durInput.value;
          }
          if (mediaMode === 'livestream') {
            if (urlInput) payload.stream_url = urlInput.value;
            const ccChk = card.querySelector('.yt-cc-chk');
            const muteChk = card.querySelector('.yt-mute-chk');
            const qualitySelect = card.querySelector('.yt-quality-select');
            if (ccChk) payload.yt_cc = ccChk.checked;
            if (muteChk) payload.yt_mute = muteChk.checked;
            if (qualitySelect) payload.yt_quality = qualitySelect.value;
            const urlType = detectUrlType(getStreamUrl());
            if (urlType !== 'YouTube' && qualitySelect) {
              qualitySelect.value = 'auto';
              payload.yt_quality = 'auto';
            }
          }
          saveSettings(streamId, payload);
          applyModeState(card, mediaMode, nextMode, getStreamUrl());
          if (nextMode === 'specific' && (mediaMode === 'image' || mediaMode === 'video')) {
            const effectiveFolder = folderSelect ? (folderSelect.value === '__filtered__' ? (folderSelect.dataset.currentFolder || 'all') : folderSelect.value) : 'all';
            loadMediaFor(streamId, effectiveFolder);
          }
        });
      }

      if (modeSelect) {
        modeSelect.addEventListener('change', e => {
          const mediaMode = getCurrentMediaMode();
          const mode = (e.target.value || 'random').toLowerCase();
          const payload = { media_mode: mediaMode, mode };
          if ((mediaMode === 'image' || mediaMode === 'video') && mode === 'random') {
            const durInput = card.querySelector('.duration-input');
            if (durInput) payload.duration = durInput.value;
          }
          saveSettings(streamId, payload);
          applyModeState(card, mediaMode, mode, getStreamUrl());
          if (mode === 'specific' && (mediaMode === 'image' || mediaMode === 'video')) {
            const effectiveFolder = folderSelect ? (folderSelect.value === '__filtered__' ? (folderSelect.dataset.currentFolder || 'all') : folderSelect.value) : 'all';
            loadMediaFor(streamId, effectiveFolder);
          }
        });
      }

      // Duration change
      const durInput = card.querySelector('.duration-input');
      if (durInput) {
        durInput.addEventListener('change', e => {
          saveSettings(streamId, { duration: e.target.value });
        });
      }
      // Shuffle toggle
      const shuffleChk = card.querySelector('.shuffle-chk');
      if (shuffleChk) {
        shuffleChk.addEventListener('change', e => {
          saveSettings(streamId, { shuffle: e.target.checked });
        });
      }
      // URL helpers: type badge + background embed test + save
      function setUrlBadge(url) {
        const badge = card.querySelector('.url-type-badge');
        if (!badge) return;
        const t = detectUrlType(url);
        badge.textContent = t || '';
        badge.dataset.type = (t || '').toLowerCase();
        badge.style.visibility = t ? 'visible' : 'hidden';
      }
      let testAbort = null;
      let testTimer = null;
      async function runEmbedTest(url) {
        const statusEl = card.querySelector('.embed-status-badge');
        if (!statusEl || !url) { if (statusEl) statusEl.textContent=''; return; }
        // Debounce rapid typing
        if (testTimer) clearTimeout(testTimer);
        statusEl.textContent = 'Testing...';
        statusEl.dataset.state = 'testing';
        testTimer = setTimeout(async () => {
          if (testAbort) { try { testAbort.abort(); } catch {} }
          const ctrl = new AbortController();
          testAbort = ctrl;
          try {
            const res = await fetch('/test_embed', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url }),
              signal: ctrl.signal
            });
            const data = await res.json();
            const state = (data.status || 'error').toLowerCase();
            statusEl.dataset.state = state;
            statusEl.textContent = (data.note || data.status || '').toUpperCase();
          } catch (e) {
            statusEl.dataset.state = 'error';
            statusEl.textContent = 'ERROR';
          }
        }, 700);
      }
      if (urlInput) {
        setUrlBadge(urlInput.value || '');
        runEmbedTest(urlInput.value || '');
        urlInput.addEventListener('input', e => {
          setUrlBadge(e.target.value);
          applyModeState(card, getCurrentMediaMode(), modeSelect ? modeSelect.value : '', e.target.value);
          runEmbedTest(e.target.value);
        });
        urlInput.addEventListener('change', e => {
          saveSettings(streamId, { stream_url: e.target.value });
          applyModeState(card, getCurrentMediaMode(), modeSelect ? modeSelect.value : '', e.target.value);
          // If not YouTube, force quality AUTO
          const qualitySelect = card.querySelector('.yt-quality-select');
          const t = detectUrlType(e.target.value);
          if (t !== 'YouTube' && qualitySelect) {
            qualitySelect.value = 'auto';
            saveSettings(streamId, { yt_quality: 'auto' });
          }
        });
      }
      // YT settings changes
      const ccChk = card.querySelector('.yt-cc-chk');
      const muteChk = card.querySelector('.yt-mute-chk');
      const qualitySelect = card.querySelector('.yt-quality-select');
      const renameBtn = card.querySelector('.menu-rename');
      if (ccChk) {
        ccChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_cc: e.target.checked });
        });
      }
      if (muteChk) {
        muteChk.addEventListener('change', e => {
          saveSettings(streamId, { yt_mute: e.target.checked });
        });
      }
      if (qualitySelect) {
        qualitySelect.addEventListener('change', e => {
          saveSettings(streamId, { yt_quality: e.target.value });
        });
      }
      
      function slugify(s){
        return (s||'').toLowerCase().trim().replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,'');
      }
      if (renameBtn) {
        renameBtn.addEventListener('click', () => {
          const a = card.querySelector('.card-header h2 a.stream-link');
          const current = a ? a.textContent.trim() : streamId;
          const next = prompt('Rename stream', current);
          if (next === null) return; // cancelled
          // preemptive duplicate check
          const currentSlug = slugify(current || streamId);
          const nextSlug = slugify(next || '');
          if (!nextSlug) { showNotification('Name cannot be empty'); return; }
          if (takenSlugs[nextSlug] && takenSlugs[nextSlug] !== streamId) {
            showNotification('Another stream already uses this name');
            return;
          }
          // Update map to new slug
          if (takenSlugs[currentSlug] === streamId) { delete takenSlugs[currentSlug]; }
          takenSlugs[nextSlug] = streamId;
          saveSettings(streamId, { label: next });
          if (a) {
            a.textContent = next || streamId;
            const slug = slugify(next || streamId);
            a.href = '/stream/' + encodeURIComponent(slug);
          }
          const dd = card.querySelector('.card-menu .menu-dropdown');
          if (dd) dd.hidden = true;
        });
      }
      // Reload images button
      const reloadBtn = card.querySelector('.reload-images-btn');
      if (reloadBtn) {
        reloadBtn.addEventListener('click', () => {
          const folder = folderSelect ? (folderSelect.value === '__filtered__' ? (folderSelect.dataset.currentFolder || 'all') : folderSelect.value) : 'all';
          loadMediaFor(streamId, folder);
        });
      }

      const initialMediaMode = (modeCategorySelect ? modeCategorySelect.value : (card.dataset.mediaMode || 'image')).toLowerCase();
      const initialModeValue = modeSelect ? (modeSelect.value || '').toLowerCase() : ((initialMediaMode === 'livestream' || initialMediaMode === 'ai') ? initialMediaMode : 'random');
      applyModeState(card, initialMediaMode, initialModeValue, urlInput ? urlInput.value : '');
    });
    originalCardOrder = Array.from(cardTagsMap.keys());
    renderTagManager();
    renderFilterChips();
    currentSortMode = (sortSelect && sortSelect.value === 'group') ? 'group' : 'default';
    applyFiltersAndSorting();
    if (tagFilterInput) {
      tagFilterInput.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ',') {
          e.preventDefault();
          commitFilterInput();
        }
      });
      tagFilterInput.addEventListener('blur', () => {
        commitFilterInput();
      });
    }
    if (sortSelect) {
      sortSelect.addEventListener('change', e => {
        currentSortMode = e.target.value === 'group' ? 'group' : 'default';
        applyFiltersAndSorting();
      });
    }
    if (createTagBtn) {
      createTagBtn.addEventListener('click', createGlobalTag);
    }
    if (newTagInput) {
      newTagInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          createGlobalTag();
        }
      });
    }
  });
</script>
</body>
</html>









































